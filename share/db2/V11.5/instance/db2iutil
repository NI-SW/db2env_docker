#!/bin/sh
#############################################################################
#
# Licensed Materials - Property of IBM
#
# "Restricted Materials of IBM" 
#
# (C) COPYRIGHT IBM Corp. 1993, 2019 All Rights Reserved.
#
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
#
#############################################################################

#
# NAME: db2iutil
#
# FUNCTION: Defines a set of global functions and variables to be used
#           in the instance related scripts
#
#############################################################################
# Options for "set" command
setopts="${setopts:-+x}"
set ${setopts?}

# Current DB2 installation directory

DB2LOCAL=`echo $DB2LOCAL`

if [ "X${DB2LOCAL?}" != "X" -a  -f ${DB2LOCAL?}/.mount ]; then
   DB2DIR=${DB2LOCAL?}/instance
   curdir=`/bin/pwd`
else
   curdir=`/bin/pwd`
   DB2DIR=`dirname $0`
   cd ${DB2DIR?}
   DB2DIR=`/bin/pwd`
fi

cd ${DB2DIR?}
DB2DIR=`dirname ${DB2DIR?}`
if [ ! -d ${DB2DIR?}/instance ]
then
    DB2DIR=`dirname ${DB2DIR?}`
fi
cfg_tmp="${DB2DIR?}/cfg/installcopy.cfg"
cmd_db2fupdt_tmp="${DB2DIR?}/bin/db2fupdt"
DB2_KEEP_IN_ORIGINAL_DB2DIR="${DB2_KEEP_IN_ORIGINAL_DB2DIR:-FALSE}"

if [ -f "${cfg_tmp?}" -a -f "${cmd_db2fupdt_tmp?}"  -a "X${DB2_KEEP_IN_ORIGINAL_DB2DIR?}" != "XTRUE" ]; then
   db2dir_tmp=`${cmd_db2fupdt_tmp?} -f ${cfg_tmp?} -p DB2DIR`
   if [ $? -eq 0 ]; then
      if [ -d ${db2dir_tmp?} ]; then
         cd ${db2dir_tmp?} 2>/dev/null 1>/dev/null
         if [ $? -eq 0 ]; then
            DB2DIR=`echo ${db2dir_tmp?} | sed 's/\/$//'`
         fi
     fi
   fi
fi 
cd ${curdir?}
unset curdir cfg_tmp cmd_db2fupdt_tmp db2dir_tmp DB2_KEEP_IN_ORIGINAL_DB2DIR

DB2LOCAL=`echo $DB2LOCAL`

if [ "X${DB2LOCAL?}" != "X" -a  -f ${DB2LOCAL?}/.mount ]; then
   if [ -d ${DB2LOCAL?}/instance ]; then
      PROGDIR=${DB2LOCAL?}/instance
      curdir=`/bin/pwd`
   fi

else

   # Set the directory name where this file is located.
   curdir=`/bin/pwd`
   PROGDIR=`dirname $0`
   cd ${PROGDIR?}
   PROGDIR=`/bin/pwd`
   cd ${curdir?}

fi

TMPDIR=${DB2TMPDIR:-/tmp}

if [ -f ${DB2DIR?}/instance/db2idefs ]; then
    . ${DB2DIR?}/instance/db2idefs
else
    echo "File db2idefs not found."
    echo "Exiting..."
    exit 1
fi

if [ -f ${DB2DIR?}/instance/db2iver ]; then
    . ${DB2DIR?}/instance/db2iver
else
    echo "File db2iver not found."
    echo "Exiting..."
    exit 1
fi

# Unset the LIBPATH variable that the user might have set
#unset LIBPATH

# Highest bit width for the current DB2 installation
HIGHEST_BIT=64

# The following variables hold first level links that will be created/validated.
LIBS="lib32 lib64"
SQLLNKDIR="adsm bin bnd cf conv java doc include ${LIBS?} map misc pd rdf federation function/db2rdf tools json "
SQLLNKDIR=${SQLLNKDIR?}"msg samples Readme gskit "
SQLLNKDIR=${SQLLNKDIR?}"icuweb odbc templates demo infopop cfg/mq cfg/lsdc gse lua "
DSLNKDIR="ruby32 ruby64 php32 php64 python32 python64"

handle_gskit_symlink()
{
    trac handle_gskit_symlink $@
    set ${setopts?}

    DB2DIR_OLD=$1
    BITS=$2

    # sanity:  bail if DB2DIR is not set
    if [ "X${DB2DIR?}" = "X" ]; then
        return ${TRUE?}
    fi

    # bail if DB2DIR_OLD isn't there for some reason
    if [ ! -d ${DB2DIR_OLD?} ]; then
        return ${TRUE?}
    fi
    
    # if old DB2DIR and new DB2DIR are same,  nothing to do
    if [ "${DB2DIR_OLD?}" = "${DB2DIR?}" ]; then
        return ${TRUE?}
    fi
    
    # get the gskit link in old DB2DIR -- if it isn't there, quit now - this is
    # probably pre-v10
    GSKIT_OLD_LIB=${DB2DIR_OLD?}/lib${BITS?}/gskit
    if [ ! -h ${GSKIT_OLD_LIB?} ]; then
        return ${TRUE?}
    fi
    GSKIT_OLD_LIB=`ls -ld ${GSKIT_OLD_LIB?} | awk '{ print $NF }'`
    
    # construct old default gskit path
    GSKIT_OLD_DEFAULT_LIB=${DB2DIR_OLD?}/lib${BITS?}/gskit_db2

    # compare.  if customer is using default gskit,  we're done.
    if [ "${GSKIT_OLD_LIB?}" = "${GSKIT_OLD_DEFAULT_LIB}" ]; then    
        return ${TRUE?}
    fi

    # now get the gskit link in the new DB2DIR -- if it isn't there,  customer has
    # done something bad to their installation and we bail.
    GSKIT_LIB=${DB2DIR?}/lib${BITS?}/gskit
    if [ ! -h ${GSKIT_LIB?} ]; then
        return ${TRUE?}
    fi
    GSKIT_LIB=`ls -ld ${GSKIT_LIB?} | awk '{ print $NF }'`
    GSKIT_DEFAULT_LIB=${DB2DIR?}/lib${BITS?}/gskit_db2
    
    # if there is already a custom link here,  DO NOT UPDATE IT.  we're done.
    if [ "${GSKIT_LIB?}" != "${GSKIT_DEFAULT_LIB}" ]; then    
        return ${TRUE?}
    fi

    # at this point,  we have a custom link in DB2DIR_OLD,  and a default link 
    # in DB2DIR.  update it,  and make note.
    dmsg "Found custom GSKit link in ${DB2DIR_OLD?}/lib${BITS?}.  Updating ${DB2DIR?}/lib${BITS?}..."
    GSKIT_LIB=${DB2DIR?}/lib${BITS?}/gskit
    rm -f ${GSKIT_LIB?}
    ln -s ${GSKIT_OLD_LIB?} ${GSKIT_LIB?}

    trax handle_gskit_symlink
}
# Function to add or remove certain path to or from the specified
# environment variable.

AddRemoveString()
{
    if [ $# -ne 3 ]; then
       return 0
    fi
    var=$1        #The enviornment variable to be processed
    addrm_str=$2  #The new path to be used
    action=$3     #Action: a -> add, r -> remove
    if [ "X${action?}" != "Xa" -a "X${action?}" != "Xr" ]; then
        return 0  # return without doing anything
    fi
    awkval='$1 != "'${addrm_str?}'"{print $0}'
    newval=`eval echo \\${$var:-""} | awk '{for (i=1; i<= NF; ++i) \
          if( $i != VAR && length($i) > 0 ) print $i":"}' FS=":" VAR=${addrm_str?} | \
          tr -d '\n'`
    if [ "X${action?}" = "Xa" ]; then
        newval=${newval?}"${addrm_str?}"
    else
        newval=`echo ${newval?} | sed 's/:$//'`
    fi
    eval $var=\"${newval?}\"
    unset var addrm_str awkval newval
}

setRootEnv () {
  set ${setopts?}

  DB2_INSTNAME=${DB2INSTANCE:=""}
  if [ "X${DB2_INSTNAME?}" = "X" ]; then
     return 0
  fi 
  if [ $# -ne 1 ]; then
     echo "Usage: $0 <directory which contains db2usrinf"
     exit 67
  fi
  db2ustinf_dir=$1
  db2ustinf_cmd="${db2ustinf_dir?}/db2usrinf"
  if [ ! -f "${db2ustinf_cmd?}" ]; then
     echo "ERROR: The command db2usrinf can not be found at ${db2ustinf_dir?}"
     exit 67
  fi

  if [ `${db2ustinf_cmd?} -E` -ne 0 ]; then
     return 0
  fi

  CUR_INSTHOME=`${db2ustinf_cmd?} -d ${DB2_INSTNAME?}`
  path_list="bin adm misc"
  class_list="java/db2java.zip java/db2jcc4.jar java/sqlj4.zip function \
  java/db2jcc_license_cisuz.jar java/db2jcc_license_cu.jar \
               java/runtime.zip"

  for tmp_entry in ${path_list?}; do
        AddRemoveString PATH ${CUR_INSTHOME?}/sqllib/${tmp_entry?} r
        AddRemoveString PATH_ORG ${CUR_INSTHOME?}/sqllib/${tmp_entry?} r
  done
  for tmp_entry in ${class_list?}; do
        AddRemoveString CLASSPATH ${CUR_INSTHOME?}/sqllib/${tmp_entry?} r
        AddRemoveString CLASSPATH_ORG ${CUR_INSTHOME?}/sqllib/${tmp_entry?} r
  done

  for path_name in LD_LIBRARY_PATH LIBPATH SHLIB_PATH LD_LIBRARY_PATH_32 \
        LD_LIBRARY_PATH_64 LD_LIBRARY_PATH_ORG LIBPATH_ORG SHLIB_PATH_ORG \
        LD_LIBRARY_PATH_32_ORG LD_LIBRARY_PATH_64_ORG ; do
        for tmp_path in lib lib32 lib64; do
           AddRemoveString ${path_name?} ${CUR_INSTHOME?}/sqllib/${tmp_path?} r
        done
  done

  for path_name in PATH CLASSPATH LD_LIBRARY_PATH LIBPATH SHLIB_PATH \
        LD_LIBRARY_PATH_32 LD_LIBRARY_PATH_64 PATH_ORG CLASSPATH_ORG \
        LD_LIBRARY_PATH_ORG LIBPATH_ORG SHLIB_PATH_ORG LD_LIBRARY_PATH_32_ORG \
        LD_LIBRARY_PATH_64_ORG ; do
        eval path_value=\$$path_name
        if [ "X${path_value}" = "X" ]; then
           unset ${path_name?}
        else
           export ${path_name?}
        fi
  done

  DASWORKDIR=${DASWORKDIR:=""}
  if [ "X${DASWORKDIR}" != "X" ]; then
    AddRemoveString PATH ${DASWORKDIR?}/bin r
    AddRemoveString PATH_ORG ${DASWORKDIR?}/adm r
    for path_name in LIBPATH SHLIB_PATH LD_LIBRARY_PATH LIBPATH_ORG SHLIB_PATH_ORG \
                     LD_LIBRARY_PATH_ORG; do
      for tmp_path in lib function; do
          AddRemoveString ${path_name?} ${DASWORKDIR?}/${tmp_path?} r
      done
    done
    for path_name in PATH LIBPATH SHLIB_PATH LD_LIBRARY_PATH \
                     PATH_ORG SHLIB_PATH_ORG LIBPATH_ORG LD_LIBRARY_PATH_ORG ; do
        if [ "X${path_name}" = "X" ]; then
           unset ${path_name?}
        else
           export ${path_name?}
        fi
    done
  fi
  unset DB2_INSTNAME path_list class_list tmp_entry path_name path_value DB2INSTANCE DASWORKDIR
}

sh_which_ ()
{
    set ${setopts?}

    file=$1
    search_path=$2
    if [ -z "${search_path?}" ]
    then
      search_path="$PATH"
    fi
    echo ${search_path?} | sed -e 's/:/\
/g' | while read path; do
    if [ -x "${path?}/${file?}" ]
    then
        echo "${path?}/${file?}"
        return 0
    fi
    done
}

sh_which ()
{
    set ${setopts?}
    text=`sh_which_ "$@"`
    # set return code based on whether there is any output.
    if [ -z "${text?}" ]
    then
        return 1
    else
        echo "${text?}"
        return 0
    fi
}

create_fencedid_file ()
{
   setopts="${setopts:-+x}"
   func_name="create_fencedid_file"
   trac ${func_name?} $@
   set ${setopts?}

   fenced_usr_name=$1
   fenced_grp_name=$2

   instance_home=$(${DB2DIR?}/bin/db2usrinf -d ${INSTNAME?})
   fencedid_filepath=${instance_home?}/sqllib/adm/fencedid

   fenced_usr_uid=$(${DB2DIR?}/bin/db2usrinf -u ${fenced_usr_name?})
   rc=$?

   if [ ${rc?} -ne ${TRUE?} ]; then
       echo "ERROR: Unable to find uid for ${fenced_usr_name?}\n"
   fi

   fenced_grp_gid=$(${DB2DIR?}/bin/db2gpinf -n ${fenced_grp_name?})
   rc=$?

   if [ ${rc?} -ne ${TRUE?} ]; then
       echo "ERROR: Unable to find the gid for ${fenced_grp_name?}\n"
   fi

   string_to_cat="db2fencedid:${INSTNAME?}:${fenced_usr_uid?}:${fenced_grp_gid?}"
   echo ${string_to_cat?} > ${fencedid_filepath?}

   trax ${func_name?} 
}

setRootEnv ${DB2DIR?}/bin 
DB2ITMALOG="db2itma.log"

#--------------------------------------------------------------------------
# Name          - set_shared_files
# Function      - creates/updates the shared files on shared file system.
#
# Parameters    - fileList - list of files with appropriate flag
#                 program - parent program name, ie db2iupgrade
# Returns       - 0 if successful
#                 Non Zero if failed
#--------------------------------------------------------------------------
set_shared_files ()
{
   trac set_shared_files $@
   set ${setopts?}
    
   get_instance #Init instance variables
   file_List=$1
   program=$2
   new_DB2DIR=${DB2DIR?}
   hostname=`hostname`
   instprof_insthome=${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared
   sshdir=${SD_INSTPROF?}/${INSTNAME?}/.ssh
   insthome=${INSTHOME?}/sqllib
   new_DB2DIR_vrmf=${DB2DIR?}:${Cur_VRMF?}

   if [ "X${program?}" = "X" ] || [ "X${file_List?}" = "X" ]
   then
      dmsg "Usage: set_shared_files <FileList> <Parent program>"
      trax set_shared_files
      return ${FALSE?}
   fi
   
   if [ ! -f "${file_List?}" ]
   then
      display_msg ${DB2CAT?} 1081 'DBI1081E  The file or directory "%s" is missing.' ${file_List?}
      trax set_shared_files
      return ${FALSE?}
   fi
   
   if [ ! -f "${instprof_insthome?}/.update" ]
   then
      if [ "${program?}" = "db2idrop_local" ]
      then
         display_msg ${DB2CAT?} 1081 'DBI1081E  The file or directory "%s" is missing.' ${instprof_insthome?}/.update
         trax set_shared_files
         return ${FALSE?}
      else
         #create the .update file and add this host with DB2DIR
         ${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${hostname?} -v ${new_DB2DIR_vrmf?}
         chg_owngrp -R ${INSTNAME?} ${INSTPGRP?} $instprof_insthome/.update
         mkpermission -R "u=rwx,g=r,o=r" ${instprof_insthome?}/.update
      fi
   else #update file exist
      if [ ${DEBUG?} -eq ${TRUE?} ]; then
        dmsg ".update file contents:"
        tee -a ${DB2INSTLOG?} < ${instprof_insthome?}/.update
      fi

      if [ "${program?}" = "db2idrop_local" ]
      then
         if [ `${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${hostname?}` ]
         then
            #If .update has one entry and that is for this host then remove the remote instance home
            if [ "`wc -l ${instprof_insthome?}/.update | awk '{ print $1 }'`" = "1" ]
            then
               echo null 2>&1 1>/dev/null
               #rm -rf ${instprof_insthome?}
               #rm -rf ${sshdir?}
            else #Remove this host entry from .update
               sed "/${hostname?}=/d" ${instprof_insthome?}/.update > /tmp/.update
               cp -f /tmp/.update ${instprof_insthome?}/.update
               find_and_execute /bin/sync
            fi
            trax set_shared_files
            return ${TRUE?}      
         else
            dmsg "Host: ${hostname?} does not exist in .update file"
            #Check for hostname changes 
             # Check if any record exisits with long or short name
            if [ ${DEBUG?} -eq ${TRUE?} ]; then
               dmsg ".update file contents:"
               tee -a ${DB2INSTLOG?} < ${instprof_insthome?}/.update
            fi
            dmsg "hostname : ${hostname?}"
            shortHost=`echo ${hostname?} | awk -F'.' '{print $1}'`
            dmsg "shortHost : ${shortHost?}"
            updateHost=`grep -w ${shortHost?} ${instprof_insthome?}/.update | awk -F'=' '{print $1}'`
            dmsg "Host name in .update file :${updateHost?}"
            if [ "X${updateHost?}" != "X" ]
            then
               if [ `${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${updateHost?}` ]
                  then
               sed "/${updateHost?}=/d" ${instprof_insthome?}/.update > /tmp/.update
               cp -f /tmp/.update ${instprof_insthome?}/.update
               find_and_execute /bin/sync
               fi
            fi
            trax set_shared_files
            return ${FALSE?}
         fi
      elif [ "${program?}" = "db2icrt_local" ]
      then
         if [ "X`${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${hostname?}`" = "X" ]
         then 
            # Check if any record exisits with long or short name 
            if [ ${DEBUG?} -eq ${TRUE?} ]; then
               dmsg ".update file contents:"
               tee -a ${DB2INSTLOG?} < ${instprof_insthome?}/.update
            fi
            dmsg "hostname : ${hostname?}"
            shortHost=`echo ${hostname?} | awk -F'.' '{print $1}'`
            dmsg "shortHost : ${shortHost?}"
            updateHost=`grep -w ${shortHost?} ${instprof_insthome?}/.update | awk -F'=' '{print $1}'`
            dmsg "Host name in .update file :${updateHost?}"
            if [ "X${updateHost?}" != "X" ]
            then
               if [ `${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${updateHost?}` ]
                  then 
                  # hostname command was changed.We should only reach here incase of upgrade or update 
                  #Replace with current hostName 
                  rm -rf /tmp/.update_dup
                  sed "s/${updateHost?}/${hostname?}/" ${instprof_insthome?}/.update > /tmp/.update_dup
                  cp -f /tmp/.update_dup ${instprof_insthome?}/.update
                  tee -a ${DB2INSTLOG?} < /tmp/.update_dup
                  tee -a ${DB2INSTLOG?} < ${instprof_insthome?}/.update
                  rm -rf /tmp/.update_dup
                  find_and_execute /bin/sync
                  trax set_shared_files
              fi     
           fi
        fi    
          ${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${hostname?} -v ${new_DB2DIR_vrmf?}
      else #if program is NOT db2idrop_local    
         if [ "X`${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${hostname?}`" = "X" ]
         then 
            # Check if any record exisits with long or short name 
            if [ ${DEBUG?} -eq ${TRUE?} ]; then
               dmsg ".update file contents:"
               tee -a ${DB2INSTLOG?} < ${instprof_insthome?}/.update
            fi
            dmsg "hostname : ${hostname?}"
            shortHost=`echo ${hostname?} | awk -F'.' '{print $1}'`
            dmsg "shortHost : ${shortHost?}"
            updateHost=`grep -w ${shortHost?} ${instprof_insthome?}/.update | awk -F'=' '{print $1}'`
            dmsg "Host name in .update file :${updateHost?}"
            if [ "X${updateHost?}" != "X" ]
            then
               if [ `${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${updateHost?}` ]
                  then 
                  #Replace with current hostName 
                  rm -rf /tmp/.update_dup
                  sed "s/${updateHost?}/${hostname?}/" ${instprof_insthome?}/.update > /tmp/.update_dup
                  cp -f /tmp/.update_dup ${instprof_insthome?}/.update
                  tee -a ${DB2INSTLOG?} < /tmp/.update_dup
                  tee -a ${DB2INSTLOG?} < ${instprof_insthome?}/.update
                  rm -rf /tmp/.update_dup
                  find_and_execute /bin/sync
                  trax set_shared_files
              fi     
            fi
         fi

         dmsg "Updating ${instprof_insthome?} for host: ${hostname?} db2dir: ${new_DB2DIR_vrmf?}."
         ${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${hostname?} -v ${new_DB2DIR_vrmf?}
      fi
   fi #end of .update exist
   home=`/bin/pwd`
   cd ${insthome?}
   while read line
   do

      flag=`echo $line | awk -F':' '{ print $2 }'`
      file=`echo $line | awk -F':' '{ print $1 }'`
      #removing the end '/' for linux os
      file=`echo ${file?} | sed 's/\/*$//'`
      dmsg "Processing file ${instprof_insthome?}/${file?} with flag ${flag?}"
              
      case ${flag?} in
      0)#If there is no file/dir in shared path then copy it
         link_path_equal "${insthome?}/${file?}" "${instprof_insthome?}/${file?}"
         if [ $? -eq ${FALSE?} ] && [ ! -d "${instprof_insthome?}/${file?}" ] && [ ! -f "${instprof_insthome?}/${file?}" ]
         then
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
            then
               #Create dir with appropriate ownership and permission
               tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)
             else
                dmsg "Unable to find file ${file?} in local and shared location, ignoring this file."
                continue
             fi
         fi
         rm -rf ${insthome?}/${file?}
         ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}
         ;;
      1)#always update
         
         #If file doesn't exist then create it
         if [ ! -d "${instprof_insthome?}/${file?}" ] && [ ! -f "${instprof_insthome?}/${file?}" ]
         then
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
            then
               #Create dir with appropriate ownership and permission
               tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)
               rm -rf ${insthome?}/${file?}
               ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}
               continue
            else
               dmsg "Unable to find file ${file?} in local and shared location, ignoring this file."
               continue
            fi
         fi

         #Make sure we are not doing a link cycle
         if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
         then
            link_path_equal "${insthome?}/${file?}" "${instprof_insthome?}/${file?}"
            if [ $? -eq ${FALSE?} ]
            then
               tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)                          
            fi
         fi
         rm -rf ${insthome?}/${file?}
         ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?} 
         ;;
      2)#last update

         #If file doesn't exist then create it
         if [ ! -d "${instprof_insthome?}/${file?}" ] && [ ! -f "${instprof_insthome?}/${file?}" ]
         then
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
            then
               #Create dir with appropriate ownership and permission
               tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)
               rm -rf ${insthome?}/${file?}
               ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}
            else
               dmsg "Unable to find file ${file?} in local and shared location, ignoring this file."
            fi
         continue
         fi
         
         simplePath=`${new_DB2DIR?}/bin/db2fupdt -f ${instprof_insthome?}/.update -p ${hostname?}`         
         if [ "`grep "=${simplePath?}$" ${instprof_insthome?}/.update | wc -l | awk '{ print $1 }'`" = "1" ]
         then
            #Make sure we are not doing a link cycle
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
            then
               link_path_equal "${insthome?}/${file?}" "${instprof_insthome?}/${file?}"
               if [ $? -eq ${FALSE?} ]
               then
                  tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)                                  
               fi
            fi
            rm -rf ${insthome?}/${file?}
            ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}  
         fi
         ;;
      4)#update in db2iupgrade only
      
         #If file doesn't exist then create it
         if [ ! -d "${instprof_insthome?}/${file?}" ] && [ ! -f "${instprof_insthome?}/${file?}" ]
         then
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
            then
               #Create dir with appropriate ownership and permission
               tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)
               rm -rf ${insthome?}/${file?}
               ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}
               continue
            fi
         fi         
         
         if [ "${program?}" = "db2iupgrade_local" ]
         then
            #Make sure we are not doing a link cycle
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ] 
            then
               link_path_equal "${insthome?}/${file?}" "${instprof_insthome?}/${file?}"
               if [ $? -eq ${FALSE?} ]
               then
                  tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)
               fi
            fi
            rm -rf ${insthome?}/${file?}
            ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}
         fi
         ;;
      8)#Runtime files
        #If file/dir doesn't exist at SD_INSTPROF, we copy from INSTHOME
         link_path_equal "${insthome?}/${file?}" "${instprof_insthome?}/${file?}"
         if [ $? -eq ${FALSE?} ] && [ ! -d "${instprof_insthome?}/${file?}" ] && [ ! -f "${instprof_insthome?}/${file?}" ]
         then
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
            then
               #Create dir with appropriate ownership and permission
               tar -chf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)
             else
                dmsg "Unable to find file ${file?} in local and shared location, ignoring this file."
                continue
             fi
         fi
         rm -rf ${insthome?}/${file?}
         ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}
         ;;
      3)#Always update and keep the links[if there is any]
         if [ ! -d "${instprof_insthome?}/${file?}" ] && [ ! -f "${instprof_insthome?}/${file?}" ]
         then
            if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
            then
               #Create dir with appropriate ownership and permission
               tar -cf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)
               rm -rf ${insthome?}/${file?}
               ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?}
               continue
            else
               dmsg "Unable to find file ${file?} in local and shared location, ignoring this file."
               continue
            fi
         fi

         #Make sure we are not doing a link cycle
         if [ -d "${insthome?}/${file?}" ] || [ -f "${insthome?}/${file?}" ]
         then
            link_path_equal "${insthome?}/${file?}" "${instprof_insthome?}/${file?}"
            if [ $? -eq ${FALSE?} ]
            then
               tar -cf - ${file?} | (cd ${instprof_insthome?}; tar -pxf -)                          
            fi
         fi
         rm -rf ${insthome?}/${file?}
         ln -s -f ${instprof_insthome?}/${file?} ${insthome?}/${file?} 
         ;;
      *)
         say "Bad flag in the file list, ${file?} ignored"
         dmsg "Bad flag in the file list, ${file?} ignored"
         continue
         ;;
      esac

   done < ${file_List?}
   cd ${home?}
   
   chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${instprof_insthome?}/cfg
   mkpermission "u=rwx,g=rwxs,o=rx,+t"    ${instprof_insthome?}/cfg
   chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${instprof_insthome?}/security
   mkpermission -R "u=rwx,go=rx" ${instprof_insthome?}/security

   chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${instprof_insthome?}/security32
   mkpermission -R "u=rwx,go=rx" ${instprof_insthome?}/security32
   chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${instprof_insthome?}/security64
   mkpermission -R "u=rwx,go=rx" ${instprof_insthome?}/security64

   find_and_execute /bin/sync
   trax set_shared_files
   return ${TRUE?}
}  
#--------------------------------------------------------------------------
# Name          - find_and_execute
# Function      - Attempts to find the command in common unix paths and execute.
#                 Actual command will be attempted to run as is.  If it fails 
#                 then it will look at common paths.
#
# Parameters    - $@ - All the parameters for the function.  
#                      
#                 
# Returns       - 0 if successful
#                 Non Zero if failed
#--------------------------------------------------------------------------
find_and_execute ()
{
    trac find_and_execute $@
    find_and_execute_rc=${FALSE?}
    find_and_execute_path=""
    already_executed=${FALSE?}
    program_name=""
    
    # Attempt to run the command as is if not get the program name from the args
    if [ "X$1" != "X" ] && [ -x $1 ]
    then
        $@
        already_executed=${TRUE?}
        find_and_execute_rc=${TRUE?}
    else
        # Copy the basename and remove that argument from $@
        program_name=`basename $1`
        shift
    fi
    
    if [ "X$program_name" != "X" ]
    then
        if [ -x "/bin/${program_name?}" ]
        then
            find_and_execute_path="/bin/"
        elif [ -x "/sbin/${program_name?}" ]
        then
            find_and_execute_path="/sbin/"
        elif [ -x "/usr/bin/${program_name?}" ]
        then
            find_and_execute_path="/usr/bin/"
        elif [ -x "/usr/sbin/${program_name?}" ]
        then
            find_and_execute_path="/usr/sbin/"
        fi
    fi
    if [ "X$find_and_execute_path" != "X" ] && [ ${already_executed?} -eq ${FALSE?} ]
    then
        find_and_execute_rc=${TRUE?}
        ${find_and_execute_path?}/${program_name?} $@
    fi
    trax find_and_execute
    return ${find_and_execute_rc?}
}

#--------------------------------------------------------------------------
# Name          - link_path_equal
# Function      - Checks if the the file's link path is equal to path2
#
# Parameters    - file - A symbolic link file
#                 destinationPath - A path which will be compared against 'file's path
# Returns       - 0 if successful
#                 Non Zero if failed
#--------------------------------------------------------------------------
link_path_equal ()
{
   trac link_path_equal $@
   set ${setopts?}   
   linked_file=$1
   destination=$2
   link_path_equal_rc=${FALSE?}
   
   if [ "X${linked_file?}" != "X" ] && [ "X${destination?}" != "X" ]
   then
      ls -l `dirname ${linked_file?}`/`basename ${linked_file?}` 2>/dev/null | grep "\-\> ${destination?}" 2>/dev/null 1>/dev/null
      if [ $? -eq 0 ]
      then
         link_path_equal_rc=${TRUE?}
      fi
   fi
   
   trax link_path_equal
   return ${link_path_equal_rc?}

}
#--------------------------------------------------------------------------
# Name          - clone_dirs
# Function      - Clone directory name/owner/permission.  This will not work with 
#                 special permission for file such as sbit
#
# Parameters    - source - source directory
#                 destination - destination directory
#                 directories - this path is with respect to source
# Returns       - 0 if successful
#                 Non Zero if failed
#--------------------------------------------------------------------------
clone_dirs ()
{
   trac clone_dirs $@
   set ${setopts?}   
   clone_dirs_rc=${TRUE?}
   
   source=$1
   destination=$2
   dirs=$3
   if [ "X${source?}" = "X" ] || [ "X${destination?}" = "X" ] || [ "X${dirs?}" = "X" ]
   then
      trax clone_dirs
      return ${FALSE?}
   fi
   
   if [ "${dirs?}" != "." ]
   then
      for i in `echo ${dirs?} | sed 's/\//\ /g'`
      do
         #Grab all the necessary values from current source directory
         user_per=`ls -ldH $source/$i | awk -F' ' '{print $1}' | tail -c10 | head -c3 | sed 's/-//g'`
         group_per=`ls -ldH $source/$i | awk -F' ' '{print $1}' | tail -c7 | head -c3 | sed 's/-//g'`
         other_per=`ls -ldH $source/$i | awk -F' ' '{print $1}' | tail -c4 | head -c3 | sed 's/-//g'`
         owner=`ls -ld $source/$i | awk -F' ' '{print $3}'`
         group=`ls -ld $source/$i | awk -F' ' '{print $4}'`

         if [ ! -d $destination/$i ]
         then
            mkdirectory $destination/$i
         fi
         mkpermission "u=$user_per,g=$group_per,o=$other_per" $destination/$i
         chg_owngrp $owner $group $destination/$i

         #Increment the directory name
         source=$source/$i
         destination=$destination/$i
      done
   fi
   
   trax clone_dirs
   return ${clone_dirs_rc?}
}

#-----------------------------------------------------------------------
# Name      - InstanceBitWidth
# Functions - Returns Bit Width of Instance
# Params.   - None
# Returns   - 32 or 64
#-----------------------------------------------------------------------
InstanceBitWidth ()
{
    trac InstanceBitWidth $@
    set ${setopts?}
    find_homedir ${INSTNAME?}
    ibw=32
    tmp_instuse_file="${USERHOME?}/sqllib/ctrl/.instuse"
    if [ -f "${USERHOME?}/sqllib/.instuse" ]; then
         tmp_instuse_file="${USERHOME?}/sqllib/.instuse"
    fi
    grep 'BitWidth=64' "${tmp_instuse_file?}" 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
            ibw=64
    fi
    trax InstanceBitWidth
    return ${ibw?}
}

checkRPATH ()
{
    trac checkRPATH
    set ${setopts?}

    if [ -f "${CHGPATHCFG?}" ]
    then
        EMBEDDEDRPATH=`${DB2DIR?}/bin/db2fupdt -f ${CHGPATHCFG?} -p DB2DIR`
    else
        # If the config file doesn't exist, most likely this is a manual
        # install where db2chgpath hasn't been run at all (a required
        # step).  In that case, we'll use the default path - since the RPATH
        # defaults to that anyway.
        EMBEDDEDRPATH="/opt/ibm/db2/V11.5"
    fi

    # Let's see if we can fully resolve these paths.  It's important that
    # we fully resolve symlinks.  Although DB2 doesn't really support installing
    # through a symlink, some users find it works, so we shouldn't just
    # disrupt them here.
    if [ -n "${EMBEDDEDRPATH?}" -a -d "${EMBEDDEDRPATH?}" ]
    then
       EMBEDDEDRPATH=`cd "${EMBEDDEDRPATH?}"; /bin/pwd`
    fi
    # if we can't cd to DB2DIR, we have huge problems ...
    REALDB2DIR=`cd ${DB2DIR?}; /bin/pwd`

    # if the embedded path doesn't match the current path, we're going to
    # have problems.
    if [ -z "${EMBEDDEDRPATH?}" -o "${EMBEDDEDRPATH?}" != "${REALDB2DIR?}" ]
    then
        display_msg ${DB2CAT?} 277 \
            'DBI1277E Install path and runtime path do not match'
        stop_prog 1
    fi

    unset EMBEDDEDRPATH REALDB2DIR

    trax checkRPATH
}

#-----------------------------------------------------------------------
# Name       - remove_links
# Function   - Remove links in /usr/include and /usr/lib to a
#              DB2 release
# Parameters - $1 is the product directory of the DB2 release
#              that the links are pointing to.
# Returns    - 0
#-----------------------------------------------------------------------
remove_links ()
{
    set ${setopts?}

    lppdir=$1

    #---------------------------------------------------------------------
    # Remove all links in /usr/include to ${lppdir?}/include.
    #---------------------------------------------------------------------
    cd /usr/include ; ls -1 | while read file; do
        rmlink /usr/include/${file?} ${lppdir?}/include
    done

    #---------------------------------------------------------------------
    # Remove the link /usr/lib/libdb2.so to ${lppdir?}/lib/libdb2.so
    #---------------------------------------------------------------------
    rmlink /usr/lib/libdb2.so ${lppdir?}/lib/libdb2.so
    rmlink /usr/lib/libdb2.so ${lppdir?}/lib32/libdb2.so
    rmlink /usr/lib/libdb2.so ${lppdir?}/lib64/libdb2.so

    rmlink /usr/lib64/libdb2.so ${lppdir?}/lib64/libdb2.so

    #---------------------------------------------------------------------
    # Remove the link /usr/lib/libdb2.so.1 to ${lppdir?}/lib/libdb2.so.1
    #---------------------------------------------------------------------
    rmlink /usr/lib/libdb2.so.1 ${lppdir?}/lib/libdb2.so.1
    rmlink /usr/lib/libdb2.so.1 ${lppdir?}/lib32/libdb2.so.1
    rmlink /usr/lib/libdb2.so.1 ${lppdir?}/lib64/libdb2.so.1

    rmlink /usr/lib64/libdb2.so.1 ${lppdir?}/lib64/libdb2.so.1

    #---------------------------------------------------------------------
    # Remove the link /usr/lib/libdb2.so.1.0 to ${lppdir?}/lib/libdb2.so.1.0
    #---------------------------------------------------------------------
    rmlink /usr/lib/libdb2.so.1.0 ${lppdir?}/lib/libdb2.so.1.0
    rmlink /usr/lib/libdb2.so.1.0 ${lppdir?}/lib32/libdb2.so.1.0
    rmlink /usr/lib/libdb2.so.1.0 ${lppdir?}/lib64/libdb2.so.1.0

    rmlink /usr/lib64/libdb2.so.1.0 ${lppdir?}/lib64/libdb2.so.1.0

    #---------------------------------------------------------------------
    # Remove the link /usr/lib/libdb2e.so to ${lppdir?}/lib/libdb2e.so
    #---------------------------------------------------------------------
    rmlink /usr/lib/libdb2e.so ${lppdir?}/lib/libdb2e.so
    rmlink /usr/lib/libdb2e.so ${lppdir?}/lib32/libdb2e.so
    rmlink /usr/lib/libdb2e.so ${lppdir?}/lib64/libdb2e.so

    rmlink /usr/lib64/libdb2e.so ${lppdir?}/lib64/libdb2e.so

    #---------------------------------------------------------------------
    # Remove the link /usr/lib/libdb2e.so.1 to ${lppdir?}/lib/libdb2e.so.1
    #---------------------------------------------------------------------
    rmlink /usr/lib/libdb2e.so.1 ${lppdir?}/lib/libdb2e.so.1
    rmlink /usr/lib/libdb2e.so.1 ${lppdir?}/lib32/libdb2e.so.1
    rmlink /usr/lib/libdb2e.so.1 ${lppdir?}/lib64/libdb2e.so.1

    rmlink /usr/lib64/libdb2e.so.1 ${lppdir?}/lib64/libdb2e.so.1

    #---------------------------------------------------------------------
    # Remove the link /usr/lib/libdb2e.so.1.0 to ${lppdir?}/lib/libdb2e.so.1.0
    #---------------------------------------------------------------------
    rmlink /usr/lib/libdb2e.so.1.0 ${lppdir?}/lib/libdb2e.so.1.0
    rmlink /usr/lib/libdb2e.so.1.0 ${lppdir?}/lib32/libdb2e.so.1.0
    rmlink /usr/lib/libdb2e.so.1.0 ${lppdir?}/lib64/libdb2e.so.1.0

    rmlink /usr/lib64/libdb2e.so.1.0 ${lppdir?}/lib64/libdb2e.so.1.0

}

#--------------------------------------------------------------------------
# Name          - copy_blu_libs
# Function      - This function copy the libblu.a for power processors
#
# Returns       - 0 if successful
#                 Non Zero if failed
#--------------------------------------------------------------------------
copy_blu_libs()
{

    return 0;

}

copy_nr_blu_libs()
{
 trac copy_nr_blu_libs
 if [ -f /usr/sbin/prtconf ] ; then
    /usr/sbin/prtconf  |  grep "Processor Type"  | grep "PowerPC_POWER" > /dev/null 2>&1
    foundit=$?
 fi  

curdir=`/bin/pwd`
cd ${DB2DIR?}/lib64

 if [ ${foundit?} -eq 0 ]; then
 #if power system find out the versoin number ; for example get nunmber 5 from "Processor Type: PowerPC_POWER5"
     ver=`/usr/sbin/prtconf | grep "Processor Implementation Mode" | grep "POWER" | cut -d ":" -f 2 | cut -d "R" -f 2`
     if [ $ver -ge 7 ]; then
         rm -f libdb2blu.a
         ln -sf libdb2blu_s.a  libdb2blu.a
         chmod ugo=rx libdb2blu.a
     else
         rm -f libdb2blu.a
         ln -sf libdb2blu_ns.a libdb2blu.a
         chmod ugo=rx libdb2blu.a
     fi
 else
    rm -f libdb2blu.a
    ln -sf libdb2blu_ns.a libdb2blu.a
    chmod ugo=rx libdb2blu.a
 fi

cd ${curdir?}

trax copy_nr_blu_libs
}

#-----------------------------------------------------------------------
# Name       - create_links
# Function   - Create links to DB2 in /usr/include and /usr/lib
# Parameters - None
# Returns    - 0
#-----------------------------------------------------------------------
create_links ()
{
    set ${setopts?}

    # Handle 64-bit lib directories.
    bit="$1"
    # 32-bit is default, no extention.
    # if we don't have this bitness, use default.
    if [ ! -d ${DB2DIR?}/lib${bit?} ]
    then
        bit=""
    fi

    #---------------------------------------------------------------------
    # For each file ".h" and ".f" file in the DB2DIR/include
    # directory create the link /usr/include/file. If /usr/include/file
    # already exists then the link is not created and a warning is issued.
    #---------------------------------------------------------------------
    inc_dir="${DB2DIR?}/include"
    if [ "X${bit?}" = "X32" ]; then
        inc_dir="${inc_dir?}${bit?}"
    fi
    if [ -d ${inc_dir?} ]; then
        cd ${inc_dir?}
        find *.[hf] -prune -type f -print 2>/dev/null | \
            while read file; do
               mklink /usr/include/${file} ${inc_dir?}/${file?}
            done
    fi

    if [ -d "/usr/lib64" -o -h "/usr/lib64" ]; then
        if [ -d "${DB2DIR?}/lib64" ]; then
           mklink /usr/lib64/libdb2.so ${DB2DIR?}/lib64/libdb2.so 
        fi
    fi
    mklink /usr/lib/libdb2.so ${DB2DIR?}/lib32/libdb2.so

    if [ -d "/usr/lib64" -o -h "/usr/lib64" ]; then
        if [ -d "${DB2DIR?}/lib64" ]; then
           mklink /usr/lib64/libdb2.so.1 ${DB2DIR?}/lib64/libdb2.so.1 
        fi
    fi
    mklink /usr/lib/libdb2.so.1 ${DB2DIR?}/lib32/libdb2.so.1

    if [ -d "/usr/lib64" -o -h "/usr/lib64" ]; then
        if [ -d "${DB2DIR?}/lib64" ]; then
           mklink /usr/lib64/libdb2.so.1.0 ${DB2DIR?}/lib64/libdb2.so.1.0 
        fi
    fi
    mklink /usr/lib/libdb2.so.1.0 ${DB2DIR?}/lib32/libdb2.so.1.0

    if [ -d "/usr/lib64" -o -h "/usr/lib64" ]; then
        if [ -d "${DB2DIR?}/lib64" ]; then
           mklink /usr/lib64/libdb2e.so ${DB2DIR?}/lib64/libdb2e.so 
        fi
    fi
    mklink /usr/lib/libdb2e.so ${DB2DIR?}/lib32/libdb2e.so

    if [ -d "/usr/lib64" -o -h "/usr/lib64" ]; then
        if [ -d "${DB2DIR?}/lib64" ]; then
           mklink /usr/lib64/libdb2e.so.1 ${DB2DIR?}/lib64/libdb2e.so.1 
        fi
    fi
    mklink /usr/lib/libdb2e.so.1 ${DB2DIR?}/lib32/libdb2e.so.1

    if [ -d "/usr/lib64" -o -h "/usr/lib64" ]; then
        if [ -d "${DB2DIR?}/lib64" ]; then
           mklink /usr/lib64/libdb2e.so.1.0 ${DB2DIR?}/lib64/libdb2e.so.1.0 
        fi
    fi
    mklink /usr/lib/libdb2e.so.1.0 ${DB2DIR?}/lib32/libdb2e.so.1.0

}

validate_sqllib_link()
{
    trac validate_sqllib_link $@
    set ${setopts?}

    rc=${VAL_OK?}

    link_list="lib ${DSLNKDIR?}"
    if [ ${ROOTUSER?} -eq ${TRUE?} ]; then
       link_list="${link_list?} ${SQLLNKDIR?}"
    fi

    for wlink in ${link_list?}; do
       if [ -h ${insthome?}/sqllib/${wlink?} ]; then
          targetdir=`ls -l ${insthome?}/sqllib/${wlink?} | awk '{print $NF}'`

          # special handling for the lib directory
          # if the directory exists, it must point to lib32 or lib64
          if [ "X${wlink?}" = "Xlib" ]; then
             rc=${VAL_VALIDATION_ERROR?}
             for liblink in ${LIBS?}; do
                if [ "X${liblink?}" = "X${targetdir?}" ]; then
                   rc=${VAL_OK?}
                   break
                fi
             done

          else
             srcpath="${DB2DIR?}/${wlink?}"

             # set path for dsdriver links
             for dslink in ${DSLNKDIR?}; do
                if [ "X${dslink?}" = "X${wlink?}" ]; then
                   srcpath="${DB2DIR?}/dsdriver/${wlink?}"
                  break
                fi
             done

             # check all other links
             if [ "X${srcpath?}" != "X${targetdir?}" ]; then
                rc=${VAL_VALIDATION_ERROR?}
                break
             fi
          fi
       fi
    done

    trax validate_sqllib_link 
    return ${rc?}
}     

#
# Find free space in the filesystem
# Input ($1) - complete path name of the directory
find_free_space ()
{
    trac find_free_space $@
    set ${setopts?}

    dirname2="$1"
    chk_dir ${dirname2?}
    if [ $? -ne ${TRUE?} ]; then
        display_msg ${DB2CAT?} 88 \
            'DBI1088E Invailid access permissions detected for directory %s.\n' \
            ${dirname2?}
        stop_prog 1
    fi

    # Get output of the "df" command

    output_df="`df -k  ${dirname2?} | sed -n '$ p'`"

    # On some platforms, the filesystem is on the previous line causing us
    # one less token for awk to find.
    free_space_in_fs=`echo ${output_df?} | awk '{if ($4 !~ /%/) {print $4} else {print $3}}'`

    dmsg "Free space in filesystem = ${free_space_in_fs?} KB"
    trax find_free_space
    return ${TRUE?}
}

chk_spacereq_dir ()
{
    set ${setopts?}
    srdir="$1"

    du -sk $srdir | awk '{print $1}'
}

chk_spacereq ()
{
    trac chk_spacereq "$@"
    set ${setopts?}

    srBASEDIR=${DB2DIR?}

    if [ -d "${srBASEDIR?}/${1:-no_such_dir}" ]
    then
      srBASEDIR="${srBASEDIR?}/$1"
      shift
    fi

    SPACEREQ="${1:-0} + 20480" # default to 20MB of "extras"
    # (note that this may not be enough for sqllib/db2dump in some cases)

    # big directories that are copied over.
    for subdir in acs adm db2tss
    do
        if [ -d ${srBASEDIR?}/${subdir?} ]
        then
          SPACEREQ="${SPACEREQ?} + `chk_spacereq_dir ${srBASEDIR?}/${subdir?}`"
        fi
    done
    SPACEREQ=`expr ${SPACEREQ?}`

    trax chk_spacereq
}

# Check space in the given filesytem/directory
chk_fsysspace ()
{
    trac chk_fsysspace $@
    set ${setopts?}

    dirname3="$1"
    minspace=$2

    find_free_space ${dirname3?}
    free_space=${free_space_in_fs?}  # Free disk space in $dirname3 (in KB)

    dmsg "Dirname = ${dirname3?}"
    dmsg "Space available = ${free_space?} KB, Required = ${minspace?} KB"

    if [ ${free_space?} -lt ${minspace?} ]; then
        display_msg ${DB2CAT?} 80 \
            'DBI1080E Disk full. Minimum space required in %s is %s KB, whereas only %s KB space is available.\n' \
             ${dirname3?} ${minspace?} ${free_space?}
        stop_prog 1
    fi

    trax chk_fsysspace
}

# Check that the filesystem type for directory "dirname2" is valid
chk_fsystype ()
{
    trac chk_fsystype $@
    set ${setopts?}

    dirname2="$1"
    chk_dir ${dirname2?}
    if [ $? -ne ${TRUE?} ]; then
        display_msg ${DB2CAT?} 88 \
            'DBI1088E Invalid access permissions detected for directory %s.\n' \
            ${dirname2?}
        stop_prog 1
    fi

    rm -f ${TMPFILE3?}

    # Get the name of the filesystem where dir $dirname2 resides.

    df -k ${dirname2?} | awk 'NR>=2{print}' > ${TMPFILE3?}

    # There must be only one line in TMPFILE3 file
    lcount=`wc -l ${TMPFILE3?} | awk '{print $1}'`
    if [ ${lcount?} -lt 1 ]; then
        echo " lcount = $lcount "
        cat $TMPFILE3
        display_msg ${DB2CAT?} 69 \
            'DBI1069E Unexpected error. Function = %s, Return code = %s.\n' \
            chk_fsystype 22
        stop_prog 1
    fi
    fsname=`awk '{print $NF}' ${TMPFILE3?} | sed -n '$ p'`

    rm -f ${TMPFILE3?}
    foundit=${FALSE?}

    # Get info about the filesystem type
    fstype=UNKNOWN

    rm -f ${TMPFILE3?}
    mount -v | egrep " ${fsname?} "  | \
        while read junk junk fsysname junk fsystype junk; do
        echo "${fsysname?} ${fsystype?}" >> ${TMPFILE3?}
    done

    for fs2 in `cat ${TMPFILE3?}`; do
        if [ ${foundit?} -eq ${TRUE?} ]; then
            fstype="${fs2?}"
            break
        fi
        if [ "X${fsname?}" = "X${fs2?}" ]; then
            foundit=${TRUE?}
        fi
    done

    rm -f ${TMPFILE3?}

    dmsg "Filesys name = ${fsname?}, Filesys type = ${fstype?}"

    # Check that the fstype is unsupported
    findwordinstr ${fstype?} "${UNSUPPFSTYPES?}"
    if [ $? -eq ${TRUE?} ]; then
        display_msg ${DB2CAT?} 53 \
            'DBI1053E File system of type %s is not supported.\n' ${fstype?}
        stop_prog 1
    fi

    trax chk_fsystype
    return ${TRUE?}
}

#-----------------------------------------------------------------------
# Name       - server_installed
# Function   - Determine if a DB2 Server product is installed.
# Parameters - none
# Returns    - 0 - if the DB2 Server product is installed.
#              non-zero - if the DB2 Server product is not installed.
#-----------------------------------------------------------------------
server_installed ()
{
    trac server_installed $@
    set ${setopts?}

    rc=${FALSE?}       # Return code

    # Check if DB2 engine library exists
    
    if [ -f ${DB2DIR?}/cfg/db2syssv -o \
         -f ${DB2DIR?}/cfg/db2syssr -o \
         -f ${DB2DIR?}/cfg/db2sysmp ]; then
        rc=${TRUE?}
    fi

    dmsg "server_installed return code = ${rc?}"
    trax server_installed
    return ${rc?}
}
#-----------------------------------------------------------------------
# Name       - server_instance
# Function   - Determine if an instance is DB2 Server Enabled
# Parameters - $1 is the OLDSQLLIB dir if called from non-root install
# Returns    - 0 - if the instance is a DB2 Server instance.
#              non-zero - if the instance is not a DB2 Server instance.
#-----------------------------------------------------------------------

server_instance ()
{
    trac server_instance $@
    set ${setopts?}
    OLDSQLLIBDIR=$1

    rc=${FALSE?}       # Return code

    if [ ${DB2INSTVER?} -eq ${DB2VER_DJ?} ]
    then
        rc=${TRUE?}
    else
        if [ "X${OLDSQLLIBDIR?}" != "X" ]; then
        chk_itype_nr ${OLDSQLLIBDIR?}
        else
        chk_itype ${OLDSQLLIBDIR?}
        fi
        if [ ${INSTTYPE?} -ne ${ITYPE_CLN?} ]
        then
            rc=${TRUE?}
        fi
    fi
    
    dmsg "server_instance return code = ${rc?}"
    trax server_instance
    return ${rc?}
}

#-----------------------------------------------------------------------
# Name       - get_instance
# Function   - Sets the INSTHOME and INSTPGRP environment variables
#              and verifies that INSTNAME is a valid user.
#              Sets path name for instance type identifier file ITYPEFILE.
#              Also checks that the instance name and the instance
#              name's primary group name do not violate the following
#              restrictions:
#              a) Group names cannot have the names GUESTS, ADMINS,
#                 USERS or LOCAL.
#              b) User and group names cannot start with SQL, IBM or SYS.
#              c) User and group names cannot start with a numeral or
#                 contain characters other than A-Z (caps) $,#,@,0-9.
#              d) User and group names must be <= 8 chars
# Returns    - Exits 1 if INSTNAME or INSTPGRP is not valid
#-----------------------------------------------------------------------
get_instance ()
{
    trac get_instance $@
    set ${setopts?}

    #---------------------------------------------------------------------
    # Sets the environment variable INSTHOME - home directory of INSTNAME.
    #---------------------------------------------------------------------
    find_homedir ${INSTNAME?}
    INSTHOME=${USERHOME?}

    #---------------------------------------------------------------------
    # Sets the environment variable INSTPGRP - primary group of the INSTNAME.
    #---------------------------------------------------------------------
    find_primgrp ${INSTNAME?}
    if [ $? -eq 0 ]; then
        INSTPGRP=${USERPGRP?}
    else
        display_msg ${DB2CAT?} 135 \
            'DBI1135E The primary group %s of the user ID %s is invalid.\n' \
            ${USERPGRP?} ${INSTNAME?}
        stop_prog 1
    fi

    # Length of instance userid must be <= 8 chars
    instidlen=`echo ${INSTNAME?} | awk '{print length($1)}'`
    if [ ${instidlen?} -gt 8 ]; then
        display_msg ${DB2CAT?} 101 \
            'DBI1101E The instance name %s is invalid.\n' ${INSTNAME?}
        stop_prog 1
    fi

    # Length of instance's primary group must be <= 8 chars
    instgrplen=`echo ${INSTPGRP?} | awk '{print length($1)}'`
    if [ ${instgrplen?} -gt 8 ]; then
        display_msg ${DB2CAT?} 135 \
            'DBI1135E The primary group %s of the user ID %s is invalid.\n' \
            ${INSTPGRP?} ${INSTNAME?}
        stop_prog 1
    fi

    #---------------------------------------------------------------------
    # Check that the INSTNAME and INSTPGRP name are valid.
    # db2icknm returns:
    #   0 - both names are valid.
    #   1 - incorrect call
    #   2 - the INSTNAME is invalid.
    #   3 - the INSTPGRP name is invalid.
    #---------------------------------------------------------------------
    EXIT_INVALID_USER=2
    EXIT_INVALID_GROUP=3

    ${DB2DIR?}/instance/db2icknm ${INSTNAME?} ${INSTPGRP?}
    exitcode=$?
    if [ ${exitcode?} -eq ${EXIT_INVALID_USER?} ]; then
        dmsg "Invalid instance name = ${INSTNAME?}"
        display_msg ${DB2CAT?} 101 \
            'DBI1101E The instance name %s is invalid.\n' ${INSTNAME?}
        stop_prog 1
    elif [ ${exitcode?} -eq ${EXIT_INVALID_GROUP?} ]; then
        dmsg "Invalid primary group \"${INSTPGRP?}\" or user ID \"${INSTNAME?}\""
        display_msg ${DB2CAT?} 135 \
            'DBI1135E The primary group %s of the user ID %s is invalid.\n' \
            ${INSTPGRP?} ${INSTNAME?}
        stop_prog 1
    elif [ ${exitcode?} -ne 0 ]; then
        display_msg ${DB2CAT?} 69 \
            'DBI1069E Unexpected error. Function = %s, Return code = %s.\n' \
            get_instance ${exitcode?}
        stop_prog 1
    fi

    # Set variable for the "ctrl" dir of the instance
    INSTCTRLDIR="${INSTHOME?}/sqllib/ctrl"

    # Full path name for FencedID Info file
    FENCINFOFILE="${INSTCTRLDIR?}/${FENCINFOFNAME?}"

    # Set name for the instance-type identifier file
    ITYPEFILE="${INSTHOME?}/sqllib/${ITYPEFNAME?}"
    if [ ! -f ${ITYPEFILE?} ] && [ -f ${INSTHOME?}/sqllib/ctrl/.instuse ]
    then
        db2_inst_ver=`${DB2DIR?}/bin/db2fupdt -f ${INSTHOME?}/sqllib/ctrl/.instuse -p INSTVER`
        if [ ${db2_inst_ver?} -le ${DB2VER_V97?} ]
        then
            ITYPEFILE="${INSTHOME?}/sqllib/ctrl/${ITYPEFNAME?}"
        fi
    fi

    # Set bit type currently in use.
    query_instuse ${INSTNAME?} "BitWidth" 0
    INSTBITWIDTH="${INSTUSE_VALUE?}"

    # if the bit width hasn't been set, set it now.
    if [ ${INSTBITWIDTH?} -eq 0 -a -d ${INSTHOME?}/sqllib/ctrl ]
    then
        INSTBITWIDTH=32
        update_instuse ${INSTNAME?} "BitWidth" ${HIGHEST_BIT?}
    fi
    ORIGBITWIDTH=${INSTBITWIDTH?}

    dmsg "INSTNAME = ${INSTNAME?}"
    dmsg "INSTPGRP = ${INSTPGRP?}"
    dmsg "INSTHOME = ${INSTHOME?}"

    dmsg "INSTCTRLDIR = ${INSTCTRLDIR?}"
    dmsg "FENCINFOFILE = ${FENCINFOFILE?}"
    dmsg "ITYPEFILE = ${ITYPEFILE?}"
    dmsg "INSTBITWIDTH = ${INSTBITWIDTH?}"

    trax get_instance
    return ${TRUE?}
}

# check if the ulimit of server instance meets DB2 requirement
# and gives warning msg if not
chk_ulimit()
{
    trac chk_ulimit $@
    set ${setopts?}

    if [ ${INSTTYPE?} -ne ${ITYPE_EEE?} -a ${INSTTYPE?} -ne ${ITYPE_SRV?} ]; then
        #no checking is needed if instance is not server
        return ${TRUE?}
    fi

    cur_data=`ulimit -d | egrep "^[0-9]+$|^unlimited+$" `
    cur_nofiles=`ulimit -n | egrep "^[0-9]+$|^unlimited+$" `

    min_nofiles=32767

    if [ "X${cur_data?}" != "X" -a "${cur_data?}" != "unlimited" -o \
         "X${cur_nofiles?}" != "X" -a "${cur_nofiles?}" != "unlimited" -a ${cur_nofiles?} -lt ${min_nofiles?} ]; then
        display_msg ${DB2CAT?} 321 \
        'DBI1321W The ulimit setting for the DB2 instance %s does not comply with the recommended values from IBM DB2 for the current platform.\n' \
        ${INSTNAME?}
    fi

    trax chk_ulimit
}

# Check that the specified authentication type is valid
chk_authtype ()
{
    trac chk_authtype $@
    set ${setopts?}

    # Valid authentication types that can be
    # specified on the command line
    ValidAuthTypes="server client dcs server_encrypt dcs_encrypt SERVER CLIENT DCS SERVER_ENCRYPT DCS_ENCRYPT"

    findwordinstr ${AUTHTYPE?} "${ValidAuthTypes?}"
    if [ $? -ne ${TRUE?} ]; then
        display_msg ${DB2CAT?} 115 \
            'DBI1115E Invalid AuthType parameter %s specified with -a flag.\n' \
            ${AUTHTYPE?}
        stop_prog 1
    fi

    trax chk_authtype
}

# Create and initialize the file (ITYPEFILE) to
# identify the type of the instance
make_itype ()
{
    trac make_itype $@
    set ${setopts?}

    if [ $# -ne 1 ] ; then
        dmsg "Usage: make_itype instance_type"
        stop_prog 1
    fi

    instancetype=$1         # Instance type

    #ITYPEFILE needs to be updated when 97 and lower to 98 or above
    if [ -f ${INSTHOME?}/sqllib/.instuse ]
    then
        ITYPEFILE=${INSTHOME?}/sqllib/.insttype
    fi

    # Variable ITYPEFILE is set in function get_instance
    rm -f ${ITYPEFILE?}

    # Create new FencedID Info file
    echo ${instancetype?} > ${ITYPEFILE?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create file %s failed.\n' ${ITYPEFNAME?}
        stop_prog 1
    fi

    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${ITYPEFILE?}
    mkpermission "ug=rw,o=r" ${ITYPEFILE?}

    dmsg "instancetype = ${instancetype?}"
    trax make_itype
    return ${TRUE?}
}
# Create and initialize the file (ITYPEFILE) to
# identify the type of the instance
make_itype_online ()
{
    trac make_itype_online $@
    set ${setopts?}

    if [ $# -ne 1 ] ; then
        dmsg "Usage: make_itype instance_type"
        stop_prog 1
    fi

    instancetype=$1         # Instance type

    #ITYPEFILE needs to be updated when 97 and lower to 98 or above
    ITYPEFILE=${INSTHOME?}/${SQLLIB_DIR_NAME?}/.insttype

    # Variable ITYPEFILE is set in function get_instance
    rm -f ${ITYPEFILE?}

    # Create new FencedID Info file
    echo ${instancetype?} > ${ITYPEFILE?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create file %s failed.\n' ${ITYPEFNAME?}
        stop_prog 1
    fi

    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${ITYPEFILE?}
    mkpermission "ug=rw,o=r" ${ITYPEFILE?}

    dmsg "instancetype = ${instancetype?}"
    trax make_itype_online
    return ${TRUE?}
}

# Find out the instance "type", 
# Sets the variable INSTTYPE.
# $1 is OLDSQLLIB if non-root install
chk_itype ()
{
    trac chk_itype $@
    set ${setopts?}
    OLDSQLLIBDIR=$1

    ITYPEFILE="${INSTHOME?}/sqllib/${ITYPEFNAME?}"
    if [ ! -f ${ITYPEFILE?} ] && [ -f ${INSTHOME?}/sqllib/ctrl/.instuse ]
    then
        db2_inst_ver=`${DB2DIR?}/bin/db2fupdt -f ${INSTHOME?}/sqllib/ctrl/.instuse -p INSTVER`
        if [ ${db2_inst_ver?} -le ${DB2VER_V97?} ]
        then
            ITYPEFILE="${INSTHOME?}/sqllib/ctrl/${ITYPEFNAME?}"
            if [ "X${OLDSQLLIBDIR?}" != "X" ]; then
               ITYPEFILE="${OLDSQLLIBDIR?}/ctrl/${ITYPEFNAME?}"
            fi
        else
            ITYPEFILE="${INSTHOME?}/sqllib/${ITYPEFNAME?}"
            if [ "X${OLDSQLLIBDIR?}" != "X" ]; then
               ITYPEFILE="${OLDSQLLIBDIR?}/${ITYPEFNAME?}"
            fi

        fi
    fi

    # Set INSTTYPE
    if [ -f ${ITYPEFILE?} ]; then
        INSTTYPE=`cat ${ITYPEFILE?}`
    else
        INSTTYPE=${ITYPE_UNK?}    # Instance type unknown
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' ${ITYPEFILE?}
        stop_prog 1
    fi

    dmsg " INSTTYPE = ${INSTTYPE?}"
    trax chk_itype
    return ${INSTTYPE?}
}

# Find instance type in case of non-root
# can be removed once above function is corrected to work for both root and non root
chk_itype_nr ()
{
    trac chk_itype $@
    set ${setopts?}
    OLDSQLLIBDIR=$1

    # Set INSTTYPE
    if [ "X${OLDSQLLIBDIR?}" != "X" ]; then
        ITYPEFILE_NR="${OLDSQLLIBDIR?}/${ITYPEFNAME?}"
        if [ -f ${ITYPEFILE_NR?} ]; then
            INSTTYPE=`cat ${ITYPEFILE_NR?}`
        fi
    elif [ -f ${ITYPEFILE?} -a "X${OLDSQLLIBDIR?}" = "X" ]; then
        INSTTYPE=`cat ${ITYPEFILE?}`
    else
        INSTTYPE=${ITYPE_UNK?}    # Instance type unknown
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' ${ITYPEFNAME?}
        stop_prog 1
    fi

    dmsg " INSTTYPE = ${INSTTYPE?}"
    trax chk_itype
    return ${INSTTYPE?}
}

#-----------------------------------------------------------------------
# Name       - chk_version
# Function   - Check the DB2 version of the given instance
# Parameters - $1 is the name of the instance
# Returns    - 1  if the given instance is a Version 1 instance
#              2  if the given instance is a Version 2 instance
#              5  if the given instance is a Version 5 instance
#              61 if the given instance is a Version 6.1 instance
#              71 if the given instance is a Version 7.1 instance
#              81 if the given instance is a Version 8.1 instance
#              91 if the given instance is a Version 9.1 instance
#              95 if the given instance is a Version 9.5 instance
#              97 if the given instance is a Version 9.7 instance
#              11 if the given instance is a Version PE 1.1 instance
#              12 if the given instance is a Version PE 1.2 instance
#              119 unknown
#-----------------------------------------------------------------------
chk_version ()
{
    trac chk_version $@
    set ${setopts?}

    instname=$1
    das=$2
    db2version=${DB2VER_UNKNOWN?}  # DB2 version number (Default=unknown)
    db2proddir="UNKNOWN"           # DB2 product directory for current instance
                                   # (Default=unknown)

    find_homedir ${instname?}
    instlibdir="${USERHOME?}/sqllib/lib"     # sqllib/lib dir of the instance
    if [ "${das?}" = "das" ]; then
        instbindir="${USERHOME?}/das/bin"     # das/bin dir of the instance
        instlibdir="${USERHOME?}/das/lib"     # das/lib dir of the instance
    fi
    
    if [ ! -f "${USERHOME?}/sqllib/.instuse" -a ! -f "${USERHOME?}/sqllib/ctrl/.instuse" ]; then
        return ${db2version?}
    fi

    check_instuse=${FALSE?}
    query_instuse_string ${instname?} V "PRE_V9"
    if [ "${das?}" = "das" ]; then
        query_instuse_string ${instname?} V "PRE_V9" "das"
    fi
    if [ "X${INSTUSE_VALUE?}" != "XPRE_V9" ]; then
       dmsg "INSTUSE_VALUE for V is ${INSTUSE_VALUE?}"
       check_instuse=${TRUE?}
    fi

    # use instuse for V8 - for multiple FP implementation
    query_instuse_string ${instname?} INSTVER 0
    if [ "${das?}" = "das" ]; then
        query_instuse_string ${instname?} INSTVER 0 "das"
    fi
    dmsg "INSTUSE_VALUE for INSTVER is ${INSTUSE_VALUE?}"

    # if INSTVER is 81 then it is a V8 instance - can be anyone of the multiple FP
    if [ "X${INSTUSE_VALUE?}" = "X81" -o ${check_instuse} -eq ${TRUE?} ]; then
           db2version=${INSTUSE_VALUE?}
           # find out what is its install path - use that to set db2proddir
           query_instuse_string ${instname?} DB2DIR ${DB2DIR?}
           dmsg "INSTUSE_VALUE for DB2DIR is ${INSTUSE_VALUE?}"
           db2proddir=${INSTUSE_VALUE?}
           return ${db2version?}
    fi

    ls -l ${instlibdir?} | grep ${DB2V71DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V71?} ; db2proddir="${DB2V71DIR?}"
    fi
    ls -l ${instlibdir?} | grep ${DB2V61DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V61?} ; db2proddir="${DB2V61DIR?}"
    fi
    ls -l ${instlibdir?} | grep ${DB2V5DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V5?} ; db2proddir="${DB2V5DIR?}"
    fi
    ls -l ${instlibdir?} | grep ${DB2V2DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V2?} ; db2proddir="${DB2V2DIR?}"
    fi

    dmsg "db2version=${db2version?}"
    dmsg "db2proddir=${db2proddir?}"
    trax chk_version
    return ${db2version?}
}

#-----------------------------------------------------------------------
# Name       - chk_version_nr
# Function   - Check the DB2 version of the given instance during nr upgrade
# Parameters - $1 is the name of the instance
#            - $2 is the old sqllib directory
# Returns    - 1  if the given instance is a Version 1 instance
#              2  if the given instance is a Version 2 instance
#              5  if the given instance is a Version 5 instance
#              61 if the given instance is a Version 6.1 instance
#              71 if the given instance is a Version 7.1 instance
#              81 if the given instance is a Version 8.1 instance
#              91 if the given instance is a Version 9.1 instance
#              95 if the given instance is a Version 9.5 instance
#              97 if the given instance is a Version 9.7 instance
#              11 if the given instance is a Version PE 1.1 instance
#              12 if the given instance is a Version PE 1.2 instance
#              119 unknown
#-----------------------------------------------------------------------
chk_version_nr ()
{
    trac chk_version_nr $@
    set ${setopts?}

    instname=$1
    OLDSQLLIBDIR=$2
    db2version=${DB2VER_UNKNOWN?}  # DB2 version number (Default=unknown)
    db2proddir="UNKNOWN"           # DB2 product directory for current instance
                                   # (Default=unknown)

    find_homedir ${instname?}
    instlibdir="${OLDSQLLIBDIR?}/lib"     # sqllib/lib dir of the instance
    
    if [ ! -f "${OLDSQLLIBDIR?}/.instuse" -a ! -f "${OLDSQLLIBDIR?}/ctrl/.instuse" ]; then
        return ${db2version?}
    fi

    check_instuse=${FALSE?}
    query_instuse_string_nr ${instname?} V "PRE_V9" ${OLDSQLLIBDIR?}
    if [ "X${INSTUSE_VALUE?}" != "XPRE_V9" ]; then
       dmsg "INSTUSE_VALUE for V is ${INSTUSE_VALUE?}"
       check_instuse=${TRUE?}
    fi

    # use instuse for V8 - for multiple FP implementation
    query_instuse_string_nr ${instname?} INSTVER 0 ${OLDSQLLIBDIR?}
    dmsg "INSTUSE_VALUE for INSTVER is ${INSTUSE_VALUE?}"

    # if INSTVER is 81 then it is a V8 instance - can be anyone of the multiple FP
    if [ "X${INSTUSE_VALUE?}" = "X81" -o ${check_instuse} -eq ${TRUE?} ]; then
           db2version=${INSTUSE_VALUE?}
           # find out what is its install path - use that to set db2proddir
           query_instuse_string_nr ${instname?} DB2DIR ${DB2DIR?} ${OLDSQLLIBDIR?}
           dmsg "INSTUSE_VALUE for DB2DIR is ${INSTUSE_VALUE?}"
           db2proddir=${INSTUSE_VALUE?}
           return ${db2version?}
    fi

    ls -l ${instlibdir?} | grep ${DB2V71DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V71?} ; db2proddir="${DB2V71DIR?}"
    fi
    ls -l ${instlibdir?} | grep ${DB2V61DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V61?} ; db2proddir="${DB2V61DIR?}"
    fi
    ls -l ${instlibdir?} | grep ${DB2V5DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V5?} ; db2proddir="${DB2V5DIR?}"
    fi
    ls -l ${instlibdir?} | grep ${DB2V2DIR?}/lib 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        db2version=${DB2VER_V2?} ; db2proddir="${DB2V2DIR?}"
    fi

    dmsg "db2version=${db2version?}"
    dmsg "db2proddir=${db2proddir?}"
    trax chk_version
    return ${db2version?}
}

# Check if the passed DB2 instance is stopped
chk_instance_stopped ()
{
    setopts="${setopts:-+x}"
    TRUE="${TRUE:-0}"
    FALSE="${FALSE:-1}"
    DEBUG="${DEBUG:-${FALSE?}}"
    set ${setopts?}

    instancename=$1
    gcfdir="$2"
    gcf_cmd="$3"
    status=${TRUE?}

    if [ ${DEBUG?} -eq ${TRUE?} ]; then
        # wsdbu01226334myk... this was appearing in main log
        ps -elf | grep ${instancename?} >&2
        ipcs -a | grep ${instancename?} >&2
    fi

    if [ -x ${gcfdir?}/db2gcf ]
    then
        if [ "X${gcf_cmd?}" = "Xdb2iexec" ]; then
           ${DB2DIR?}/instance/${gcf_cmd?} -n ${instancename?} "${gcfdir?}/db2gcf -i ${instancename?} -s" 1> /dev/null 2> /dev/null
           status=$?
        else 
           ${gcfdir?}/db2gcf -i ${instancename?} -s 1> /dev/null 2> /dev/null
           status=$?
        fi
        case ${status?} in
            1) # ok, it's stopped.
               status=${TRUE?} ;;
            *)
               status=${FALSE?} ;;
        esac
    fi

    return ${status?}
}

# Stop or disable  DB2 ACS services
#-----------------------------------------------------------------------
# Name       - db2_acs_stop_disable
# Function   - Stop or disable DB2 ACS services
# Parameters - $1: the instance name
#              $2: the actions - 'stop' or 'disable'
#              $3: the DB2DIR related to the DB2 instance
#              $4: the program name calling this function
# Returns    - 0 for success
#              Non Zero for failure
#-----------------------------------------------------------------------
db2_acs_stop_disable ()
{
    setopts="${setopts:-+x}"
    TRUE="${TRUE:-0}"
    FALSE="${FALSE:-1}"
    DEBUG="${DEBUG:-${FALSE?}}"
    set ${setopts?}
    instancename=$1
    action=$2
    acs_db2dir=$3
    acs_caller=$4
    db2_acs_stop_disable_rc=0;
    query_rc=0;
    TMPDIR=${DB2TMPDIR:-/tmp}

    acs_tmp_log=${TMPDIR?}/db2_acs_stop_disable_${instancename?}.$$
    if [ -f ${acs_tmp_log?} ]; then
       rm -f ${acs_tmp_log?} 2>/dev/null
    fi

    if [ "X${instancename?}" = "X" -o \
         $# -ne 4 -o \
         "X${action?}" != "Xstop" -a \
         "X${action?}" != "Xdisable" ]; then
       echo "ERROR: Usage db2_acs_stop_disable <instance name> 'stop!disable' <DB2IPRDDIR>"
       exit 67
    fi

    insthome=`${acs_db2dir?}/bin/db2usrinf -d ${instancename?}`
    instpgrp=`${acs_db2dir?}/bin/db2usrinf -g ${instancename?}`

    if [ ! -f ${insthome?}/sqllib/acs/setup_db2.sh -o ! -f ${acs_db2dir?}/acs/setup_db2.sh ]; then
       return ${TRUE?}
    fi

    ${acs_db2dir?}/acs/setup_db2.sh -a query  -d ${insthome?}/sqllib \
          -u ${instancename?} -g ${instpgrp?} 2>/dev/null 1>/dev/null
    if [ $? -ne ${TRUE?} ]; then
       return ${TRUE?}
    fi
 
    ${acs_db2dir?}/acs/setup_db2.sh -a ${action?} -d ${insthome?}/sqllib \
               -u ${instancename?} -g ${instpgrp?} 2>&1 > ${acs_tmp_log?}
    db2_acs_stop_disable_rc=$?

    if [ ${db2_acs_stop_disable_rc?} -eq ${TRUE?}  \
         -a ${DEBUG?} -ne ${TRUE?} ]; then
       rm -f ${acs_tmp_log?} 2>/dev/null
    fi
    return ${db2_acs_stop_disable_rc?}
}

_dbmchk ()
{
    trac _dbmchk $@
    set ${setopts?}
    rc=0
    g_rc=0
    instHome=$1
    gcf_cmd=${instHome?}/sqllib/bin/db2gcf
    updt_cmd=${instHome?}/sqllib/bin/db2fupdt
    rec_dir=${instHome?}/sqllib/ctrl/.dbmchk
    host=`hostname`

    if [ -x ${gcf_cmd?} ]; then
        ${gcf_cmd?} -s 1> /dev/null 2> /dev/null
        g_rc=$?
        case ${g_rc?} in
            1) # ok, it's stopped.
                touch "${rec_dir?}/${host?}.success"
            ;;
            *)
                rc=1
                touch "${rec_dir?}/${host?}.failure"
                ${updt_cmd?} -f ${rec_dir?}/${host?} -p ${host?} -v ${rc?}
            ;;
        esac
    fi
        
    trax _dbmchk
    return ${rc?}
}

_libchk ()
{
    trac _libchk $@
    set ${setopts?}
    rc=0

    cmd=fuser

    cmd_opt="-u"

    cmdFound=${FALSE?}

    sh_which ${cmd?} > /dev/null
    if [ $? -eq 0 ]; then
        cmdFound=${TRUE?}
    else

        if [ -x "/usr/bin/lsof" ]; then
            cmd="/usr/bin/lsof"
            cmdFound=${TRUE?}
            cmd_opt=""
        elif [ -x "/usr/sbin/lsof" ]; then
            cmd="/usr/sbin/lsof"
            cmdFound=${TRUE?}
            cmd_opt=""
        else
            rc=2
        fi        

    fi

    if [ ${cmdFound?} -eq ${TRUE?} ]; then
        #if $1 is a file, check if it's open
        if [ -f $1 ]; then

            # as far as we know, the return code is more stable than output on Linux
            ${cmd?} ${cmd_opt?} $1 1>/dev/null 2>/dev/null
            #return code 0 means the file is loaded 
            if [ $? -eq 0 ]; then
                rc=1
            fi

            if [ ${rc?} -gt 0 ]; then
                rc=1
            fi
        #if $1 is a directory, check if any file inside is open
        elif [ -d $1 ]; then
            find $1 -type f | while read filename; do

                ${cmd?} ${cmd_opt?} $filename 1>/dev/null 2>/dev/null
                if [ $? -eq 0 ]; then
                    rc=1
                fi

                if [ ${rc?} -gt 0 ]; then
                    rc=1
                    break
                fi
            done
        fi
    fi

    trax _libchk
    return ${rc?}
}

# Generate a new name for "archieve" file.
# Set variables:
#     archfullname = full pathname for the archieve file
#        archfname = file name for the archieve file
gen_archfile ()
{
    trac gen_archfile $@
    set ${setopts?}

    fullname="$1"     # file name -fullpath

    dname2=`dirname ${fullname?}`
    fname2=`basename ${fullname?}`

    # If the file $fullname exists, generate a new name
    # for the archive file
    if [ -f ${fullname?} ]; then
        eval cnt=0
        archfname="${fname2?}.${DATESTAMP?}"
        while [ -f ${dname2?}/${archfname?} ]; do
            archfname="${fname2?}.${DATESTAMP?}.${cnt?}"
            cnt=`expr ${cnt?} + 1`
        done
    else
        archfname="${fname2?}"
    fi

    # Full path name for the new archive file
    archfullname="${dname2?}/${archfname?}"

    dmsg "archfname = ${archfname?} "
    dmsg "archfullname = ${archfullname?} "
    trax gen_archfile
}

# Gets the DB2 product directory for the given release level of DB2
get_db2dir_ver()
{
    trac get_db2dir_ver $@
    set ${setopts?}

    db2ver=$1       # DB2 version
    instname=$2

    # use instuse for V8 or later versions
    # find out what is its install path - use that to set db2proddir
    query_instuse_string ${instname?} DB2DIR ""
    dmsg "INSTUSE_VALUE for DB2DIR is ${INSTUSE_VALUE?}"
    db2pdir=${INSTUSE_VALUE?}

    if [ "X${db2pdir?}" = "X" ]
    then
      case ${db2ver?} in
          ${DB2VER_V1?})   db2pdir=${DB2V1DIR?} ;;
          ${DB2VER_PE11?}) db2pdir=${DB2PE11DIR?} ;;
          ${DB2VER_PE12?}) db2pdir=${DB2PE12DIR?} ;;
          ${DB2VER_V2?})   db2pdir=${DB2V2DIR?} ;;
          ${DB2VER_DJ?})   db2pdir=${DJV211DIR?} ;;
          ${DB2VER_V5?})   db2pdir=${DB2V5DIR?} ;;
          ${DB2VER_V61?})  db2pdir=${DB2V61DIR?} ;;
          ${DB2VER_V71?})  db2pdir=${DB2V71DIR?} ;;
          ${DB2VER_CURRENT?}) db2pdir=${DB2DIR?} ;;
          *)
               display_msg ${DB2CAT?} 69 \
                'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                get_db2dir_ver ${db2ver?} ;;
      esac
    fi 
    trax get_db2dir_ver
}

# Gets the DB2 product directory for the given release level of DB2
get_db2dir_ver_nr()
{
    trac get_db2dir_ver_nr $@
    set ${setopts?}

    db2ver=$1       # DB2 version
    instname=$2
    OLDSQLLIBDIR=$3

    # use instuse for V8 or later versions
    # find out what is its install path - use that to set db2proddir
    query_instuse_string_nr ${instname?} DB2DIR "" ${OLDSQLLIBDIR?}
    dmsg "INSTUSE_VALUE for DB2DIR is ${INSTUSE_VALUE?}"
    db2pdir=${INSTUSE_VALUE?}

    if [ "X${db2pdir?}" = "X" ]
    then
      case ${db2ver?} in
          ${DB2VER_V1?})   db2pdir=${DB2V1DIR?} ;;
          ${DB2VER_PE11?}) db2pdir=${DB2PE11DIR?} ;;
          ${DB2VER_PE12?}) db2pdir=${DB2PE12DIR?} ;;
          ${DB2VER_V2?})   db2pdir=${DB2V2DIR?} ;;
          ${DB2VER_DJ?})   db2pdir=${DJV211DIR?} ;;
          ${DB2VER_V5?})   db2pdir=${DB2V5DIR?} ;;
          ${DB2VER_V61?})  db2pdir=${DB2V61DIR?} ;;
          ${DB2VER_V71?})  db2pdir=${DB2V71DIR?} ;;
          ${DB2VER_CURRENT?}) db2pdir=${DB2DIR?} ;;
          *)
               display_msg ${DB2CAT?} 69 \
                'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                get_db2dir_ver ${db2ver?} ;;
      esac
    fi 
    trax get_db2dir_ver
}

# Gets the instance type (DLFM or regular) given
# the instance name and version.  It defaults to ITYPE_UNK.
get_insttype ()
{
    trac get_insttype $@
    set ${setopts?}

    instname=$1     # Instance name
    db2ver=$2       # DB2 version
    INSTTYPE=${ITYPE_UNK?}

    get_db2dir_ver ${db2ver?} ${instname?}

    query_instuse_string ${instname?} InstanceType ""
    INSTTYPE=${INSTUSE_VALUE?}

    if [ "X${INSTTYPE?}" = "X" ]; then
       case ${db2ver?} in
         ${DB2VER_V5?}|${DB2VER_V61?}|${DB2VER_V71?}|${DB2VER_V81?}|${DB2VER_V91?})
            # ITYPEFILE is set by a call to get_instance
            if [ -f "${ITYPEFILE?}" ]; then
                INSTTYPE=`cat ${ITYPEFILE?} 2>/dev/null`
            fi
            ;;
       esac
    fi

    # Check if a DLFM instance
    if [ -x "${db2pdir?}/instance/dlfmlist" ]; then
         tmp=`${db2pdir?}/instance/dlfmlist 2>/dev/null`
         if [ "${tmp?}" = "${instname?}" ]; then
             INSTTYPE=${ITYPE_DLN?}
         fi
    fi

    dmsg "INSTTYPE = ${INSTTYPE?}"
    trax get_insttype
    return ${INSTTYPE?}
}

# Gets the instance type (DLFM or regular) given
# the instance name and version. Nonroot install. It defaults to ITYPE_UNK.
get_insttype_nr ()
{
    trac get_insttype_nr $@
    set ${setopts?}

    instname=$1     # Instance name
    db2ver=$2       # DB2 version
    OLDSQLLIBDIR=$3
    INSTTYPE=${ITYPE_UNK?}

    get_db2dir_ver_nr ${db2ver?} ${instname?} ${OLDSQLLIBDIR?}

    query_instuse_string_nr ${instname?} InstanceType "" ${OLDSQLLIBDIR?}
    INSTTYPE=${INSTUSE_VALUE?}

    if [ "X${INSTTYPE?}" = "X" ]; then
       case ${db2ver?} in
         ${DB2VER_V5?}|${DB2VER_V61?}|${DB2VER_V71?}|${DB2VER_V81?}|${DB2VER_V91?})
            # ITYPEFILE is set by a call to get_instance
            if [ -f "${ITYPEFILE?}" ]; then
                INSTTYPE=`cat ${ITYPEFILE?} 2>/dev/null`
            fi
            ;;
       esac
    fi

    # Check if a DLFM instance
    if [ -x "${db2pdir?}/instance/dlfmlist" ]; then
         tmp=`${db2pdir?}/instance/dlfmlist 2>/dev/null`
         if [ "${tmp?}" = "${instname?}" ]; then
             INSTTYPE=${ITYPE_DLN?}
         fi
    fi

    dmsg "INSTTYPE = ${INSTTYPE?}"
    trax get_insttype
    return ${INSTTYPE?}
}

# Function to check whether an instance name
# exists in a given version's instance list
chk_instlist ()
{
    trac chk_instlist $@
    set ${setopts?}

    instname=$1     # Instance name
    db2ver=$2       # DB2 version
    db2path=$3      # DB2 installation path to be used
    # Instance type
    if [ $# -ge 4 ]; then
        insttype=$4
    else
        insttype=${ITYPE_UNK?}
    fi

    rc=${FALSE?}

    if [ "X${db2path?}" = "X" ]; then
       get_db2dir_ver ${db2ver?} ${instname?}
       db2path=${db2pdir?}
    fi

    case ${db2ver?} in
        ${DB2VER_V2?})
            for instinlist in `cat ${DB2V2ILIST?}`; do
                if [ "X${instname?}" = "X${instinlist?}" ]; then
                    rc=${TRUE?}
                fi
            done
            ;;
        ${DB2VER_DJ?})
            for instinlist in `cat ${DJV211ILIST?}`; do
                if [ "X${instname?}" = "X${instinlist?}" ]; then
                    rc=${TRUE?}
                fi
            done
            ;;
        *)
            # Check for regular instances
            ${db2path?}/instance/db2iset -q ${instname?} 1>/dev/null 2>/dev/null
            if [ $? -eq 0 ]; then
                rc=${TRUE?}
            fi

            # Check for DLFM instances
            if [ ${insttype?} -eq ${ITYPE_DLN?} -o \
                 ${insttype?} -eq ${ITYPE_UNK?} ]; then
                tmp=`${db2path?}/instance/db2iset DB2DLFMADMIN -g 2>/dev/null`
                if [ "${tmp?}" = "${instname?}" ]; then
                    rc=${TRUE?}
                fi
            fi
            ;;
    esac

    trax chk_instlist
    return ${rc?}
}

# Function to add an instance name from the 
# instance list of DB2 version $db2ver
add_instlist ()
{
    trac add_instlist $@
    set ${setopts?}

    instname=$1     # Instance name
    db2ver=$2       # DB2 version

    # Instance type
    if [ $# -ge 3 ]; then
        insttype=$3
    else
        insttype=${ITYPE_UNK?}
    fi

    if [ $# -ge 4 ]; then
        db2path=$4      # The DB2 path where the db2iset is used.
    else
        db2path=""
    fi
    if [ "X${db2path?}" = "X" ]; then
        get_db2dir_ver ${db2ver?} ${instname?}
        if [ "X$db2pdir" != "X" ]; then
            db2path=${db2pdir?}
        fi
    fi

    DB2REGDIR_VX=""
    get_db2dir_ver ${db2ver?} ${instname?}
    # Update the instance list
    case ${db2ver?} in
          ${DB2VER_V5?})
            db2regver="${DB2VER_V5?}"
            ;;
          ${DB2VER_V61?})
            db2regver="${DB2VER_V61?}"
            ;;
          ${DB2VER_V71?})
            db2regver="${DB2VER_V71?}"
            ;;
          ${DB2VER_V81?})
            db2regver="${DB2VER_V81?}"
            ;;
          *)
            DB2REGDIR_VX=${db2pdir?}
            ;;
    esac
    if [ "X${DB2REGDIR_VX?}" = "X" ]; then

       DB2REGDIR_VX="/var/db2/v${db2regver?}"

    fi

    case ${db2ver?} in
        ${DB2VER_V2?})

            # Check if the db2idir file already exists
            if [ ! -f ${DB2V2ILIST?} ] ; then
                echo "DB2-INSTANCE-DIRECTORY" > ${DB2V2ILIST?}
            fi

            # Check if the instance is already in the instance list
            chk_instlist ${instname?} ${db2ver?}

            if [ $? -eq ${FALSE?} ]; then
                # Place instance back into the V2 Registry
                echo "${instname?}" >> ${DB2V2ILIST?}
            fi
            ;;
        ${DB2VER_DJ?})
            # Check if the db2idir file already exists
            if [ ! -f ${DJV211ILIST?} ] ; then
                echo "DB2-INSTANCE-DIRECTORY" > ${DJV211ILIST?}
            fi

            # Check if the instance is already in the instance list
            chk_instlist ${instname?} ${db2ver?}

            if [ $? -eq ${FALSE?} ]; then
                # Place instance back into the DJ V2.2.1 Registry
                echo "${instname?}" >> ${DJV211ILIST?}
            fi
            ;;
        *)
            # Check that the instance to be added is not already present
            chk_instlist ${instname?} ${db2ver?} ${db2path?} ${insttype?}
            if [ $? -eq ${TRUE?} ]; then
                display_msg ${DB2CAT?} 292 \
                    'DBI1292E The instance %s is already in the instance list.\n' \
                    ${instname?}
                return ${FALSE?}
            fi

            # Add the new instance to the list.
            LD_LIBRARY_PATH=  ${db2path?}/instance/db2iset -a ${instname?} 1> /dev/null 2> /dev/null
            if [ $? -ne 0 ]; then
                display_msg ${DB2CAT?} 295 \
                    'DBI1295E The instance list could not updated.\n'
                return ${FALSE?}
            fi

            if [ ${insttype?} -eq ${ITYPE_DLN?} ]; then
                ${db2path?}/instance/db2iset -g DB2DLFMADMIN=${INSTNAME?} 1>/dev/null 2>/dev/null
            fi
            ;;
    esac
# wsdbu01226334myk this was appearing in main log
#    if [ ${DEBUG?} -eq ${TRUE?} ]; then
#        dmsg "List of instances = "
#        ${db2path?}/instance/db2ilist
#    fi

    trax add_instlist
    return ${TRUE?}
}

# Function to remove an instance name from the 
# instance list of DB2 version $db2ver
rm_instlist ()
{
    trac rm_instlist $@
    set ${setopts?}

    instname=$1     # Instance name
    db2ver=$2       # DB2 version
    db2path=$3      # The DB2 path where the db2iset is used.

    if [ "X${db2path?}" = "X" ]; then
        get_db2dir_ver ${db2ver?} ${instname?}
        if [ "X$db2pdir" != "X" ]; then
            db2path=${db2pdir?}
        fi
    fi
    # Update the instance list
    case ${db2ver?} in
        ${DB2VER_DJ?})
            # File containing names of instances

            db2instlist="${DJV211ILIST?}"

            # If there is no instance list, return
            if [ ! -s ${db2instlist?} ]; then
                echo "Instance list not found..."
                return ${TRUE?}
            fi

            rm -f ${TMPFILE2?}
            touch ${TMPFILE2?}
            found=${FALSE?}

            # Search for the instance to removed in the instance list.
            for instinlist in `cat ${db2instlist?}`; do
                if [ "X${instname?}" != "X${instinlist?}" ] ; then
                    echo ${instinlist?} >> ${TMPFILE2?}
                    if [ $? -ne 0 ] ; then
                        display_msg ${DB2CAT?} 295 \
                            'DBI1295E The instance list could not updated.\n'
                        return ${FALSE?}
                    fi
                else
                    found=${TRUE?}
                fi
            done

            # If the instance name is found in the list then the
            # list is replaced with the updated file.
            if [ ${found?} -eq ${TRUE?} ] ; then
                cp ${TMPFILE2?} ${db2instlist?} 1>/dev/null 2>/dev/null
                if [ $? -ne 0 ] ; then
                    display_msg ${DB2CAT?} 295 \
                        'DBI1295E The instance list could not updated.\n'
                    rm -f ${TMPFILE2?}
                    return ${FALSE?}
                fi
                chown root ${db2instlist?}
                chmod u=rw,og=r ${db2instlist?}
            else
                display_msg ${DB2CAT?} 291 \
                    'DBI1291E The instance %s was not found in the instance list.\n' ${instname?}
                rm -f ${TMPFILE2?}
                return ${FALSE?}
            fi

            rm -f ${TMPFILE2?}

            # Remove the instance list if there are no instances remaining.
            numOfInstances=`wc -l ${db2instlist?} | awk '{printf "%s", $1}'`
            if [ ${numOfInstances?} -le 1 ] ; then
                rm -f ${db2instlist?}
            fi
            ;;
        ${DB2VER_V2?})
            # File containing names of instances

            db2instlist="${DB2V2ILIST?}"

            # If there is no instance list, return
            if [ ! -s ${db2instlist?} ]; then
                echo "Instance list not found..."
                return ${TRUE?}
            fi

            rm -f ${TMPFILE2?}
            touch ${TMPFILE2?}
            found=${FALSE?}

            # Search for the instance to removed in the instance list.
            for instinlist in `cat ${db2instlist?}`; do
                if [ "X${instname?}" != "X${instinlist?}" ] ; then
                    echo ${instinlist?} >> ${TMPFILE2?}
                    if [ $? -ne 0 ] ; then
                        display_msg ${DB2CAT?} 295 \
                            'DBI1295E The instance list could not updated.\n'
                        return ${FALSE?}
                    fi
                else
                    found=${TRUE?}
                fi
            done

            # If the instance name is found in the list then the
            # list is replaced with the updated file.
            if [ ${found?} -eq ${TRUE?} ] ; then
                cp ${TMPFILE2?} ${db2instlist?} 1>/dev/null 2>/dev/null
                if [ $? -ne 0 ] ; then
                    display_msg ${DB2CAT?} 295 \
                        'DBI1295E The instance list could not updated.\n'
                    rm -f ${TMPFILE2?}
                    return ${FALSE?}
                fi
                chown root ${db2instlist?}
                chmod u=rw,og=r ${db2instlist?}
            else
                display_msg ${DB2CAT?} 291 \
                    'DBI1291E The instance %s was not found in the instance list.\n' ${instname?}
                rm -f ${TMPFILE2?}
                return ${FALSE?}
            fi

            rm -f ${TMPFILE2?}

            # Remove the instance list if there are no instances remaining.
            numOfInstances=`wc -l ${db2instlist?} | awk '{printf "%s", $1}'`
            if [ ${numOfInstances?} -le 1 ] ; then
                rm -f ${db2instlist?}
            fi
            ;;
        *)
            # Check that the instance to be deleted is there.
            if [ "X${db2path?}" = "X" ]; then
                chk_instlist ${instname?} ${db2ver?}
            else
                chk_instlist ${instname?} ${db2ver?} ${db2path?}
            fi
            if [ $? -ne ${TRUE?} ]; then
                display_msg ${DB2CAT?} 291 \
                    'DBI1291E The instance %s was not found in the instance list.\n' \
                    ${instname?}
                return ${FALSE?}
            fi

            # Remove the instance from the list
            is_dpf ${instname?} ${db2ver?}
            if [ $? -eq ${TRUE?} -a -f ${INSTHOME?}/sqllib/adm/db2iclean ]; then
                _clean_dpf
            else
                ${db2path?}/instance/db2iset -d ${instname?} 1> /dev/null 2> /dev/null
            fi
            if [ $? -ne ${TRUE?} ]; then
                display_msg ${DB2CAT?} 295 \
                    'DBI1295E The instance list could not updated.\n'
                return ${FALSE?}
            fi

            tmp=`${db2path?}/instance/db2iset DB2ADMINSERVER -g`
            if [ "${instname?}" = "${tmp?}" ]; then
                ${db2path?}/instance/db2iset DB2ADMINSERVER= -g 1>/dev/null 2>/dev/null
            fi

            tmp=`${db2path?}/instance/db2iset DB2DLFMADMIN -g`
            if [ "${instname?}" = "${tmp?}" ]; then
                ${db2path?}/instance/db2iset DB2DLFMADMIN= -g 1>/dev/null 2>/dev/null
            fi

            tmp=`${db2path?}/instance/db2iset DQPSERVER -g`
            if [ "${instname?}" = "${tmp?}" ]
            then
                ${db2path?}/instance/db2iset DQPSERVER= -g 1>/dev/null 2>/dev/null
            fi
            ;;
    esac

    if [ ${DEBUG?} -eq ${TRUE?} ]; then
        dmsg "List of instances using ${db2path?} = "
        ${db2path?}/instance/db2ilist
    fi

    trax rm_instlist
    return ${TRUE?}
}

#-----------------------------------------------------------------------
# Name       - cleanup_reg_list
# Function   - (1) If the instname ID does not exist in the system, and
#              db2idrop, dasdrop, dlfmdrop or qpdrop called this function:
#              clean the db2 registry and instance global profiles
#            - (2) If the instname ID exists in the system, and db2icrt,
#              dascrt, dlfmcrt or qpcrt called this function, and the
#              the sqllib for non-das, or das for das directory is missing
#              we clean the registry and global profiles.
# Parameters - $1: the type of the "ID": das, dlfm, or instance
#              $2: either crt or drop
#              $3: the das or instance name
# Returns    - 1  Caller should continute
#              0  Caller should exit successfully (stop_prog 0)
#-----------------------------------------------------------------------
cleanup_reg_list ()
{
   trac cleanup_reg_list $@
   set ${setopts?}

   clean_type=$1
   clean_caller_type=$2
   clean_instname=$3
   clean_id_exist=${TRUE?}
   clean_id_onlist=${FALSE?}
   clean_greg_instance=${FALSE?}
   clean_id_sqllib_das=${TRUE?}
   clean_rc=${FALSE?}
   clean_syntax="Usage: cleanup_reg_list das|dlfm|instance crt|drop username"

   if [ $# -ne 3 ]; then
       echo "ERROR ${clean_syntax?}"
       return ${FALSE?}
   fi

   if [ "${clean_caller_type?}" != "crt" ] \
      && [ "${clean_caller_type?}" != "drop" ]; then
        echo "ERROR ${clean_syntax?}"
        return ${FALSE?}
   fi 

   #Check if the user name exists in the system
   userId=`${DB2DIR?}/bin/db2usrinf -u ${clean_instname?}`
   if [ "X${userId}" = "X" ]; then
       clean_id_exist=${FALSE?}
   elif [ "${userId}" = "0" ]; then
       return ${FALSE?}
   else
        clean_id_home=`${DB2DIR?}/bin/db2usrinf -d ${clean_instname?}`
        if [ "X${clean_id_home?}" = "X" ]; then
            return ${FALSE?}
        fi
        clean_id_exist=${TRUE?}
   fi

   #
   #Check if the user name is on das|instance|dlfm list
   #
   case ${clean_type?} in
      das)
         if [ -f "${DB2DIR?}/instance/daslist" ]; then
             clean_query=`${DB2DIR?}/instance/daslist`
         else
             return ${FALSE?}
         fi
         ;;
      dlfm)
         if [ -f "${DB2DIR?}/instance/dlfmlist" ]; then
             clean_query=`${DB2DIR?}/instance/dlfmlist`
         else
             return ${FALSE?}
         fi
      ;;
      instance)
         if [ -f "${DB2DIR?}/instance/db2ilist" ]; then
             clean_query=`${DB2DIR?}/instance/db2ilist`
         else
             return ${FALSE?}
         fi
      ;;
      *)
          echo "ERROR ${clean_syntax?}"
          return ${FALSE?}
      ;;
   esac
   for tmp_id in ${clean_query?}; do
     if [ "${clean_instname?}" = "${tmp_id?}" ]; then
        clean_id_onlist=${TRUE?}
        break
     fi
   done
   #Return if ${clean_instname?} is not on any list
   if [ "${clean_id_onlist?}" = "${FALSE?}" ]; then

     # return if there is no instance record in global reg (nothing to clean)
     existing_greg_instance=`${DB2DIR?}/bin/db2greg -getinstrec InstanceName=${clean_instname?} | grep InstanceName | sed 's/.*|\(.*\)|.*/\1/'`

     if [ "X${existing_greg_instance?}" = "X" ]; then
         trax cleanup_reg_list
         return ${FALSE?}
     else
         clean_id_onlist=${TRUE?}
         clean_greg_instance=${TRUE?}
     fi
   fi

   #
   # Check if db2 registry needs to be cleaned for ${clean_instname?}
   #
   clean_registry=${FALSE?}
   if [ "${clean_caller_type?}" = "crt" ] && [ "${clean_id_exist?}" = "${TRUE?}" ] \
      && [ "${clean_id_onlist?}" = "${TRUE?}" ]; then
      case ${clean_type?} in
          das)
             if  [ ! -d "${clean_id_home?}/das" ]; then
                 clean_registry=${TRUE?}
             fi
             ;;
          dlfm|instance)
             if [ ! -d "${clean_id_home?}/sqllib" ]; then
                clean_registry=${TRUE?}
             fi
             ;;
         *)
             return ${FALSE?}
             ;;
      esac
   elif [ "${clean_caller_type?}" = "drop" ] && [ "${clean_id_exist?}" = "${TRUE?}" ]  \
      && [ "${clean_id_onlist}" = "${TRUE?}" ]; then
      clean_registry=${TRUE?}
   else
       return ${FALSE?}
   fi

   #Clean DB2 registry
   if [ "${clean_registry?}" = "${TRUE?}" ]; then
      case ${clean_type?} in
          das)
              if [ ${DEBUG?} -eq ${TRUE?} ]; then
                 ${DB2DIR?}/bin/db2greg -dump 1>&2
              fi
              ${DB2DIR?}/das/bin/db2dascfg ${DEBUGFLAG?} drop ${clean_instname?}
              ${DB2DIR?}/instance/db2iset -g DB2ADMINSERVER=
              if [ ${DEBUG?} -eq ${TRUE?} ]; then
                 ${DB2DIR?}/bin/db2greg -dump 1>&2
              fi
              tmp=`${DB2DIR?}/das/bin/db2dascfg get dasusr`
              if [ "X${tmp?}" = "X" ] && [ "${clean_caller_type?}" = "drop" ]; then
                  clean_rc=${TRUE?}
              fi
              ;;
          dlfm|instance)
              # Remove the instance from the list
              if [ "${clean_greg_instance?}" = "${FALSE?}" ]; then
                  ${DB2DIR?}/instance/db2iset -d ${clean_instname?} 1> /dev/null 2> /dev/null
              else
                  ${DB2DIR?}/bin/db2greg -delinstrec instancename=${clean_instname?} 1> /dev/null 2> /dev/null
              fi

              if [ $? -ne 0 ]; then
                display_msg ${DB2CAT?} 295 \
                    'DBI1295E The instance list could not updated.\n'
                return ${FALSE?}
              else 
                if [ "${clean_caller_type?}" = "drop" ]; then
                    clean_rc=${TRUE?}
                fi
              fi
              
              tmp=`${DB2DIR?}/instance/db2iset DB2DLFMADMIN -g`
              if [ "${clean_instname?}" = "${tmp?}" ]; then
                ${DB2DIR?}/instance/db2iset DB2DLFMADMIN= -g 1>/dev/null 2>/dev/null
                ${DB2DIR?}/instance/db2iset DLFM_INSTANCE_NAME= -g 1>/dev/null 2>/dev/null
                if [ -f /var/adm/dlfslog ]; then
                    /usr/bin/rm -f /var/adm/dlfslog
                fi
                clean_config_file
              fi
              ;;
         *)
             echo "ERROR ${clean_syntax?}"
             return ${FALSE?}
             ;;
      esac

   fi
   trax cleanup_reg_list
   return ${clean_rc?}
}

# If FencedID name is NOT given on the command line then read it
# from FENCINFOFILE file. Verify that the FencedID name is valid.
# Sets env variable FENCEDID and FENCPGRP. Variable
# FENCEDID is only set if not given on the command line
verify_fencinfo ()
{
    trac verify_fencinfo $@
    set ${setopts?}

    # If FENCEDID is not given on the command line (using -u flag)
    # check the FENCINFOFILE file.
    if [ -z "${FENCEDID?}" ]; then
        if [ -f ${FENCINFOFILE?} ]; then
            FENCEDID=`cat ${FENCINFOFILE?}`
        else
            display_msg ${DB2CAT?} 111 \
                'DBI1111E The FencedID parameter must be specified using -u flag.\n'
            stop_prog 1
        fi
#    else
#        # If FENCEDID is given on the command-line AND FENCINFOFILE file
#        # also exists, then ignore the value in FENCINFOFILE
#        if [ -f ${FENCINFOFILE?} ]; then
#            tempID=`cat ${FENCINFOFILE?}`
#            if [ "X${tempID?}" != "X${FENCEDID?}" ]; then
#                display_msg ${DB2CAT?} 113 \
#                    'DBI1113W Previous value of FencedID parameter %s is different. New value %s is ignored.\n' \
#                    ${tempID?} ${FENCEDID?}
#                FENCEDID="${tempID?}"
#            fi
#        fi
    fi

    # Verify FENCEDID
    #get_userinfo ${FENCEDID?}
    # Set the value of FENCPGRP
    find_primgrp ${FENCEDID?}
    FENCPGRP="${USERPGRP?}"

    dmsg "FENCEDID = ${FENCEDID?}"
    dmsg "FENCPGRP = ${FENCPGRP?}"

    # Length of user name of the fenced id must be <= 8 chars
    fencedidlen=`echo ${FENCEDID?} | awk '{print length($1)}'`
    if [ ${fencedidlen?} -gt 8 ]; then
        echo "ERROR: The length of the fenced user name ${FENCEDID?} is invalid. It must not be longer than 8."
        stop_prog 1
    fi

    trax verify_fencinfo
}

# Create the FencedID Info file for server instances
create_fencinfo ()
{
    trac create_fencinfo $@
    set ${setopts?}

    # If server is not installed, do not create FencedID info file
    if [ ${INSTTYPE?} -eq ${ITYPE_CLN?} ]; then
        return ${TRUE?}
    fi

#    # If FencedID Info file exists, do not re-create it
#    if [ -f ${FENCINFOFILE?} ]; then
#        return ${TRUE?}
#    fi

    # Create new FencedID Info file
    echo ${FENCEDID?} > ${FENCINFOFILE?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create file %s failed.\n' ${FENCINFOFILE?}
        stop_prog 1
    fi

    chg_owngrp ${FENCEDID?} ${FENCPGRP?} ${FENCINFOFILE?}
    mkpermission "ug=rw,o=r" ${FENCINFOFILE?}

    trax create_fencinfo
    return ${TRUE?}
}

# Copy all the License Support files and bldlevel file
copy_licsupp ()
{
    trac copy_licsupp $@
    set ${setopts?}

    rm -f ${INSTHOME?}/sqllib/cfg/*.lvl 1> /dev/null 2> /dev/null
    ln -s ${DB2DIR?}/cfg/*.lvl ${INSTHOME?}/sqllib/cfg \
        1> /dev/null 2> /dev/null

    # Copy bldlevel file
    rm -f ${INSTHOME?}/sqllib/cfg/bldlevel
    cp ${DB2DIR?}/cfg/bldlevel ${INSTHOME?}/sqllib/cfg \
        1> /dev/null 2> /dev/null
    if [ $? -eq 0 ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/bldlevel
        mkpermission "ugo=r" ${INSTHOME?}/sqllib/cfg/bldlevel
    fi

    # copy health monitor defaults
    if [ -f ${DB2DIR?}/cfg/DefHealthRules.reg ]
    then
        rm -f ${INSTHOME?}/sqllib/cfg/DefHealthRules.reg
        ln -s ${DB2DIR?}/cfg/DefHealthRules.reg ${INSTHOME?}/sqllib/cfg \
            1> /dev/null 2> /dev/null
    fi

    # copy DigiCertGlobalRootCA.arm w01277625mk
    if [ -f ${DB2DIR?}/cfg/DigiCertGlobalRootCA.arm ]
    then
        rm -f ${INSTHOME?}/sqllib/cfg/DigiCertGlobalRootCA.arm
        ln -s ${DB2DIR?}/cfg/DigiCertGlobalRootCA.arm ${INSTHOME?}/sqllib/cfg \
            1> /dev/null 2> /dev/null
    fi

    # II Wrapper config files
    ls ${DB2DIR?}/cfg/*.xml > /dev/null 2> /dev/null
    if [ $? -eq 0 ]
    then
        rm -f ${INSTHOME?}/sqllib/cfg/*.xml 1> /dev/null 2> /dev/null
        ln -s ${DB2DIR?}/cfg/*.xml ${INSTHOME?}/sqllib/cfg
    fi
    ls ${DB2DIR?}/cfg/*.dtd > /dev/null 2> /dev/null
    if [ $? -eq 0 ]
    then
        rm -f ${INSTHOME?}/sqllib/cfg/*.dtd 1> /dev/null 2> /dev/null
        ln -s ${DB2DIR?}/cfg/*.dtd ${INSTHOME?}/sqllib/cfg
    fi

    if [ -f ${DB2DIR?}/cfg/db2md_config.xml ]
    then
        if [ ! -f ${INSTHOME?}/sqllib/db2md_config.xml ]
        then
            cp ${DB2DIR?}/cfg/db2md_config.xml ${INSTHOME?}/sqllib
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2md_config.xml
            mkpermission "u=rw,go=r" ${INSTHOME?}/sqllib/db2md_config.xml
        fi
        rm -f ${INSTHOME?}/sqllib/cfg/db2md_config.xml 1> /dev/null 2> /dev/null
    fi

    if [ -f ${DB2DIR?}/cfg/db2cos ]
    then
        cp ${DB2DIR?}/cfg/db2cos ${INSTHOME?}/sqllib/cfg
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/db2cos
        mkpermission "u=r,go=" ${INSTHOME?}/sqllib/cfg/db2cos

        if [ ! -f ${INSTHOME?}/sqllib/db2cos ]
        then
            echo "#! /bin/sh
. ${INSTHOME?}/sqllib/cfg/db2cos
" > ${INSTHOME?}/sqllib/db2cos
        fi
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2cos
        mkpermission "u=r,go=" ${INSTHOME?}/sqllib/db2cos
    fi

    # Federation support profile, generete db2dj.ini and odbcinst.ini
    if [ -f ${DB2DIR?}/cfg/db2dj.ini.sample ]
    then
        if [ ! -f ${INSTHOME?}/sqllib/cfg/db2dj.ini ]
        then
            sed "s#INSTHOME#${INSTHOME?}#g" < ${DB2DIR?}/cfg/db2dj.ini.sample > ${INSTHOME?}/sqllib/cfg/db2dj.ini
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/db2dj.ini
            mkpermission "u=rw,go=r" ${INSTHOME?}/sqllib/cfg/db2dj.ini
        else
            # when update and upgrade db2, there is former db2dj.ini existing, just modify
            # odbc configuration. Add odbc/netezza library path into the following variables
            DB2_ODBC_NETEZZA_LIBPATH="${INSTHOME?}/sqllib/federation/odbc/lib:${INSTHOME?}/sqllib/federation/netezza/lib64:"

            # Check if DB2_FED_LIBPATH is already set
            DB2_FED_LIBPATH=`${INSTHOME?}/sqllib/bin/db2fupdt -f ${INSTHOME?}/sqllib/cfg/db2dj.ini -p DB2_FED_LIBPATH`
            if [ $? -eq 1 ];
            then
                # DB2_FED_LIBPATH is not set, just insert one line
                ${INSTHOME?}/sqllib/bin/db2fupdt -f ${INSTHOME?}/sqllib/cfg/db2dj.ini -p DB2_FED_LIBPATH -v ${DB2_ODBC_NETEZZA_LIBPATH?}
            fi

            # Remove duplicate values in db2dj.ini which mostly are inherited from previous releases, then add correct values (only once) later to these env var's to guarantee correct setup
            sed -i "s#${INSTHOME?}/sqllib/federation/odbc/lib:##g" ${INSTHOME?}/sqllib/cfg/db2dj.ini 
            sed -i "s#${INSTHOME?}/sqllib/federation/netezza/lib64:##g" ${INSTHOME?}/sqllib/cfg/db2dj.ini
            sed -i "s#DB2_FED_LIBPATH=#&${DB2_ODBC_NETEZZA_LIBPATH?}#" ${INSTHOME?}/sqllib/cfg/db2dj.ini 

            # The following three env vars are not used, should be removed.
            sed -i "/^DB2LIBPATH=$/d"  ${INSTHOME?}/sqllib/cfg/db2dj.ini
            sed -i "/^LIBPATH=$/d"  ${INSTHOME?}/sqllib/cfg/db2dj.ini
            sed -i "/^LD_LIBRARY_PATH=$/d"  ${INSTHOME?}/sqllib/cfg/db2dj.ini

            # The following three env vars are fixed value.
            ${INSTHOME?}/sqllib/bin/db2fupdt -f ${INSTHOME?}/sqllib/cfg/db2dj.ini -p DJX_ODBC_LIBRARY_PATH -v ${DB2_ODBC_NETEZZA_LIBPATH?}
            ${INSTHOME?}/sqllib/bin/db2fupdt -f ${INSTHOME?}/sqllib/cfg/db2dj.ini -p ODBCINST -v "${INSTHOME?}/sqllib/cfg/odbcinst.ini"
            ${INSTHOME?}/sqllib/bin/db2fupdt -f ${INSTHOME?}/sqllib/cfg/db2dj.ini -p NZ_ODBC_INI_PATH -v "${INSTHOME?}/sqllib/cfg"
        fi
    fi

    if [ -f ${DB2DIR?}/cfg/odbcinst.ini.sample ]
    then
       if [ -f ${INSTHOME?}/sqllib/cfg/odbcinst.ini ]
       then  mv ${INSTHOME?}/sqllib/cfg/odbcinst.ini ${INSTHOME?}/sqllib/cfg/odbcinst.ini.bak
       fi
       sed "s#INSTHOME#${INSTHOME?}#g" < ${DB2DIR?}/cfg/odbcinst.ini.sample > ${INSTHOME?}/sqllib/cfg/odbcinst.ini
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/odbcinst.ini
       mkpermission "u=rw,go=r" ${INSTHOME?}/sqllib/cfg/odbcinst.ini
    fi

    #Create the ITLMready.properties file if ${DB2DIR?}/tivready exists
    ITLMready_file=${INSTHOME?}/sqllib/cfg/ITLMready.properties
    if [ -f ${ITLMready_file?} ]; then
       grep "=${DB2DIR?}\/" ${ITLMready_file?} 2>/dev/null 1>/dev/null
       if [ $? -ne ${TRUE?} ]; then
          rm -f ${ITLMready_file?}
       fi
    fi
    if [ ! -f  ${ITLMready_file?} -a -d ${DB2DIR?}/tivready ]; then
        echo "ITLM.install.instance.scope=${DB2DIR?}/tivready" > ${ITLMready_file?}
        mkpermission "ugo=r" ${ITLMready_file?}
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${ITLMready_file?}
    fi

    trax copy_licsupp
}

# Copy all the License Support files and bldlevel file
copy_licsupp_online ()
{
    trac copy_licsupp_online $@
    set ${setopts?}

    ln -s ${DB2DIR?}/cfg/*.lvl ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg \
        1> /dev/null 2> /dev/null

    # Copy bldlevel file
    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/bldlevel
    cp ${DB2DIR?}/cfg/bldlevel ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg \
        1> /dev/null 2> /dev/null
    if [ $? -eq 0 ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/bldlevel
        mkpermission "ugo=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/bldlevel
    fi

    # copy health monitor defaults
    if [ -f ${DB2DIR?}/cfg/DefHealthRules.reg ]
    then
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/DefHealthRules.reg
        ln -s ${DB2DIR?}/cfg/DefHealthRules.reg ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg \
            1> /dev/null 2> /dev/null
    fi

    # II Wrapper config files
    ls ${DB2DIR?}/cfg/*.xml > /dev/null 2> /dev/null
    if [ $? -eq 0 ]
    then
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/*.xml 1> /dev/null 2> /dev/null
        ln -s ${DB2DIR?}/cfg/*.xml ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg
    fi
    ls ${DB2DIR?}/cfg/*.dtd > /dev/null 2> /dev/null
    if [ $? -eq 0 ]
    then
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/*.dtd 1> /dev/null 2> /dev/null
        ln -s ${DB2DIR?}/cfg/*.dtd ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg
    fi

    if [ -f ${DB2DIR?}/cfg/db2md_config.xml ]
    then
        if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2md_config.xml ]
        then
            cp ${DB2DIR?}/cfg/db2md_config.xml ${INSTHOME?}/${SQLLIB_DIR_NAME?}
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2md_config.xml
            mkpermission "u=rw,go=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2md_config.xml
        fi
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/db2md_config.xml 1> /dev/null 2> /dev/null
    fi

    if [ -f ${DB2DIR?}/cfg/db2cos ]
    then
        cp ${DB2DIR?}/cfg/db2cos ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/db2cos
        mkpermission "u=r,go=" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/db2cos

        if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2cos ]
        then
            echo "#! /bin/sh
. ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/db2cos
" > ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2cos
        fi
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2cos
        mkpermission "u=r,go=" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2cos
    fi

    #Create the ITLMready.properties file if ${DB2DIR?}/tivready exists
    ITLMready_file=${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/ITLMready.properties
    if [ -f ${ITLMready_file?} ]; then
       grep "=${DB2DIR?}\/" ${ITLMready_file?} 2>/dev/null 1>/dev/null
       if [ $? -ne ${TRUE?} ]; then
          rm -f ${ITLMready_file?}
       fi
    fi
    if [ ! -f  ${ITLMready_file?} -a -d ${DB2DIR?}/tivready ]; then
        echo "ITLM.install.instance.scope=${DB2DIR?}/tivready" > ${ITLMready_file?}
        mkpermission "ugo=r" ${ITLMready_file?}
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${ITLMready_file?}
    fi

    trax copy_licsupp_online
}

nr_copy_licsupp ()
{
    trac nr_copy_licsupp $@
    set ${setopts?}

    if [ -f ${DB2DIR?}/cfg/db2md_config.xml ]
    then
        if [ ! -f ${INSTHOME?}/sqllib/db2md_config.xml ]
        then
            cp ${DB2DIR?}/cfg/db2md_config.xml ${INSTHOME?}/sqllib
            mkpermission "u=rw,go=r" ${INSTHOME?}/sqllib/db2md_config.xml
        fi
        rm -f ${INSTHOME?}/sqllib/cfg/db2md_config.xml 1> /dev/null 2> /dev/null
    fi

    if [ -f ${DB2DIR?}/cfg/db2cos ]
    then
        mkpermission "u=r,go=" ${INSTHOME?}/sqllib/cfg/db2cos

        if [ ! -f ${INSTHOME?}/sqllib/db2cos ]
        then
            echo "#! /bin/sh
. ${INSTHOME?}/sqllib/cfg/db2cos
" > ${INSTHOME?}/sqllib/db2cos
        fi
        mkpermission "u=r,go=" ${INSTHOME?}/sqllib/db2cos
    fi

    #Create the ITLMready.properties file if ${DB2DIR?}/tivready exists
    ITLMready_file=${INSTHOME?}/sqllib/cfg/ITLMready.properties
    if [ -f ${ITLMready_file?} ]; then
       grep "=${DB2DIR?}\/" ${ITLMready_file?} 2>/dev/null 1>/dev/null
       if [ $? -ne ${TRUE?} ]; then
          rm -f ${ITLMready_file?}
       fi
    fi
    if [ ! -f  ${ITLMready_file?} -a -d ${DB2DIR?}/tivready ]; then
        echo "ITLM.install.instance.scope=${DB2DIR?}/tivready" > ${ITLMready_file?}
        mkpermission "ugo=r" ${ITLMready_file?}
    fi

    trax nr_copy_licsupp
}

# Find the value of the bldlevel
get_bldlevel ()
{
    trac get_bldlevel $@
    set ${setopts?}
    bldlvldir=$1
    bldlvlvalue=n00

    if [ -f ${bldlvldir?}/bldlevel ]; then
        bldlvlvalue=`cat ${bldlvldir?}/bldlevel`
    fi

    bldlvlvalue=`echo ${bldlvlvalue?} | sed 's/[a-zA-Z]\(.*\)$/\1/' | \
                sed 's/^0\(.*\)$/\1/'`

    trax get_bldlevel
}

# Check if the instance to be updated has the level higher than the level
# of the current installation.
chk_vrmfis ()
{
  trac chk_vrmfis $@
  set ${setopts?}
  instname=$1
  bydas="$2"
  query_instuse ${instname?} "V" ${CurVERSION?} "${bydas?}"
  INST_V="${INSTUSE_VALUE?}"
  query_instuse ${instname?} "R" ${CurRELEASE?} "${bydas?}"
  INST_R="${INSTUSE_VALUE?}"
  query_instuse ${instname?} "M" ${CurMODIFICATION?} "${bydas?}"
  INST_M="${INSTUSE_VALUE?}"
  query_instuse ${instname?} "F" ${CurFIXLEVEL?} "${bydas?}"
  INST_F="${INSTUSE_VALUE?}"
  query_instuse ${instname?} "I" ${CurINTERIM?} "${bydas?}"
  INST_I="${INSTUSE_VALUE?}"
  query_instuse ${instname?} "S" ${CurINSTALLP?} "${bydas?}"
  INST_S="${INSTUSE_VALUE?}"

  if [ "${INST_V?}" = "ZZ" -o ${INST_V?} -ne ${CurVERSION?} ]; then
     display_msg ${DB2CAT?} 122 \
         'DBI1122E Instance %s cannot be updated.\n' ${instname?}
     stop_prog 1
  elif [ ${INST_R?} -gt ${CurRELEASE?} ]; then
     return ${TRUE?}
  elif [ ${INST_R?} -lt ${CurRELEASE?} ]; then 
     return ${FALSE?}
  elif [ ${INST_M?} -gt ${CurMODIFICATION?} ]; then
     return ${TRUE?}
  elif [ ${INST_M?} -lt ${CurMODIFICATION?} ]; then
     return ${FALSE?}
  elif [ ${INST_F?} -gt ${CurFIXLEVEL?} ]; then
     return ${TRUE?}
  elif [ ${INST_F?} -lt ${CurFIXLEVEL?} ]; then
     return ${FALSE?}
  elif [ ${INST_I?} -gt ${CurINTERIM?} ]; then
     return ${TRUE?}
  elif [ ${INST_I?} -lt ${CurINTERIM?} ]; then
     return ${FALSE?}
  elif [ ${INST_S?} -gt ${CurINSTALLP?} ]; then
     return ${TRUE?}
  elif [ ${INST_S?} -le ${CurINSTALLP?} ]; then
     return ${FALSE?}
  else
     return ${TRUE?}
  fi
  trax chk_vrmfis
}

## check if we can downgrade from the current level.
chk_downgrade ()
{
  trac chk_downgrade $@
  set ${setopts?}
  instname=$1

  if [ -x ${INSTHOME?}/sqllib/bin/db2ickdown ]
  then
    ${INSTHOME?}/sqllib/bin/db2ickdown \
            -v ${CurVERSION?}      \
            -r ${CurRELEASE?}      \
            -m ${CurMODIFICATION?} \
            -f ${CurFIXLEVEL?}     \
            -i ${CurINTERIM?}      \
            -s ${CurINSTALLP?}

     if [ $? -ne ${TRUE?} ]
     then
       display_msg ${DB2ISTR?} 7097 \
          "Downgrade to \"%1\" from the current level \"%2\" is not supported." | \
          sed -e "s/%1/${Cur_VRMFIS}/" -e "s/%2/${INST_V?}.${INST_R?}.${INST_M?}.${INST_F?}.${INST_I?}.${INST_S?}/"
       stop_prog 1
    fi
  fi

  trax chk_downgrade

}

## this function checks the db2nodes.cfg
chk_dpf ()
{
    trac chk_dpf $@
    set ${setopts?}
    file_db2node="$1/sqllib/db2nodes.cfg"
    cur_host=`hostname`
    if [ -f ${file_db2node?} ]; then
        if [ `awk '{print $2}' < ${file_db2node?} | sort -u |wc -l` -gt 1 ]; then
            owning_host=`head -n 1 ${file_db2node?} | awk '{print $2}'`
            if [ ${cur_host?} != ${owning_host?} ]; then

                ${DB2DIR?}/instance/db2iexec -n -o "/tmp/db2io.log.$$:/tmp/db2io.err.$$" -v "RAHOSTLIST=${owning_host?}" ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2_all hostname"
                remote_host=`awk "NF==1" < /tmp/db2io.log.$$`                

                if [ "${cur_host?}" != "${remote_host?}" ]; then
                  display_msg ${DB2CAT?} 458 \
                      'DBI1458E DPF instance cannot be updated from non instance owning nodes.\n'
                  stop_prog 1
                fi
            fi
        fi
    fi
    trax chk_dpf
}

# Arguments:
#   $1 - instance name (Optional)
has_multiple_nodes ()
{
    trac has_multiple_nodes $@
    set ${setopts?}
    
    inst_home=$1
    file_db2node="${inst_home?}/sqllib/db2nodes.cfg"
    has_multiple_nodes_rc=${FALSE?}
    if [ -f ${file_db2node?} ]; then
        if [ `awk '{print $2}' < ${file_db2node?}|wc -l` -gt 1 ]; then
            has_multiple_nodes_rc=${TRUE}
        fi
    fi
    trax has_multiple_nodes
    return ${has_multiple_nodes_rc?}
}

# Arguments:
#   $1 - instance name (Optional)
#   $2 - instance version (Optional)
#   $3 - instance home dir (Optional)
is_dpf ()
{
    trac is_dpf $@
    set ${setopts?}
    inst_name=${1:-${INSTNAME?}}
    inst_ver=${2:-${DB2INSTVER?}}
    inst_home=${3:-${INSTHOME?}}

    #remember the orginal value before possibly change it
    orig_value=${INSTTYPE?}
    get_insttype ${inst_name?} ${inst_ver?}
    cur_insttype=${INSTTYPE?}
    is_dpf_rc=${FALSE?}
    has_multiple_nodes ${inst_home?}
    if [ $? -eq ${TRUE?} -a "X${cur_insttype?}" = "X${ITYPE_EEE?}" ]; then
       #Differentiate between DPF and SD, Make sure SDInstance=0 doesn't exist in .instuse, if there then it's SD not DPF
       SDInstance=`${DB2DIR?}/bin/db2fupdt -f ${USERHOME?}/.instuse -p SDInstance`
       if [ "X${SDInstance?}" = "X" ]
       then
          is_dpf_rc=${TRUE?}
       fi
    fi
    INSTTYPE=${orig_value?}
    trax is_dpf
    return ${is_dpf_rc?}
}

_clean_dpf ()
{
    trac _clean_dpf $@
    set ${setopts?}
    file_db2node="${INSTHOME?}/sqllib/db2nodes.cfg"
    dpf_log_dir="${INSTHOME?}/sqllib/ctrl/.cleandpf"
    DATABASES=""

    #this section can be removed once upgrade from before cobra is not supported anymore
    #since db2iclean is new in cobra
    if [ ! -f ${INSTHOME?}/sqllib/adm/db2iclean ]; then
        return ${TRUE?}
    fi

    if [ -d ${dpf_log_dir?} ]; then
        rm -rf ${dpf_log_dir?}
    fi
    mkdirectory ${dpf_log_dir?}
    chmod ugo+w ${dpf_log_dir?}

    ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/bin/rah \"${INSTHOME?}/sqllib/adm/db2iclean 2>&1 1>/dev/null \" 2>&1 1>/dev/null"

    rm -f ${TMPFILE2?}
    touch ${TMPFILE2?}
    awk '{print $2}' < ${file_db2node?} | sort -u | while read host
    do
        if [ ! -f ${dpf_log_dir?}/${host?} ]; then
            DATABASES="${DATABASES?} ${host?},"
            echo "${DATABASES?}" > ${TMPFILE2?}
        fi
    done

    if [ -s ${TMPFILE2?} ]; then
        DATABASES=`cat ${TMPFILE2?} | sed 's/.$//'`
        display_msg ${DB2CAT?} 165 \
                'DBI1165E Instance %s is not accessible on the following partitions: %s\n' ${INSTNAME?} "${DATABASES?}"
        display_msg ${DB2CAT?} 383 \
                'DBI1383E Manual clean-up of the DB2 registry is required.\nFor example: /opt/ibm/db2/V9.7/instance/db2iset -d %s\n' ${INSTNAME?}
    fi

    rm -rf ${dpf_log_dir?}
    trax _clean_dpf
}

chk_partitioned_ese_to_no_ese ()
{
    trac chk_partitioned_ese_to_no_ese $@
    set ${setopts?}
    #remember the orginal value before possibly change it
    old_value=${INSTTYPE?}
    prepare_itype
    new_insttype=${INSTTYPE?}
    is_dpf
    if [ $? -eq ${TRUE?} -a ${new_insttype?} -ne ${ITYPE_EEE?} ]; then
        display_msg ${DB2CAT?} 236 \
            'DBI1236E The instance type is ese and the db2nodes.cfg defines multiple partitions, it can be \
             upgraded or updated only to ese instance type.\n'  ${INSTNAME?}
        stop_prog 1
    fi
    INSTTYPE=${old_value?}
    trax chk_partitioned_ese_to_no_ese
}

_stop_iupdate_D ()
{
  set ${setopts?}
  bydas="$1"
  if [ "X${bydas?}" = "Xdas" ]; then
     display_msg ${DB2CAT?} 178 \
            'DBI1178W Updating to code at a lower level - Force this update with -D flag.\n'
  else
     display_msg ${DB2CAT?} 177 \
            'DBI1177W Updating to code at a lower level - Force this update with -D flag.\n'
  fi
  stop_prog 1
}

# Copy all the setuid programs from product dir to 
# instance's sqllib dir
copy_setuid ()
{
    trac copy_setuid $@
    set ${setopts?}

    source_security=""
    target_security="${INSTHOME?}/sqllib/security"
    if [ -d ${DB2DIR?}/security64 ]; then
         source_security="${DB2DIR?}/security64"
    else
         source_security="${DB2DIR?}/security32"
    fi

    if [ -f ${source_security?}/db2aud ]; then
        cp ${source_security?}/db2aud ${target_security?}
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${target_security?}/db2aud
        mkpermission "u=rxs,go=x"  ${target_security?}/db2aud
    fi
    if [ ! -f ${target_security?}/db2audit.cfg ]
    then
         cp ${source_security?}/db2audit.cfg ${target_security?}
         chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${target_security?}/db2audit.cfg
         mkpermission "u=rw,go=r" ${target_security?}/db2audit.cfg
    fi

    if [ -f ${source_security?}/db2ckpw ]; then
        cp ${source_security?}/db2ckpw ${target_security?}
        chg_owngrp root ${INSTPGRP?} ${target_security?}/db2ckpw
        mkpermission "u=rxs,go=x" ${target_security?}/db2ckpw
    fi

    if [ -f ${source_security?}/db2flacc ]; then
        cp ${source_security?}/db2flacc ${target_security?}
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${target_security?}/db2flacc
        mkpermission "u=rx,g=xs,o=x" ${target_security?}/db2flacc
    fi

    if [ -f ${source_security?}/db2chpw ]; then
        cp ${source_security?}/db2chpw ${target_security?}
        chg_owngrp root ${INSTPGRP?} ${target_security?}/db2chpw
        mkpermission "u=rxs,go=x" ${target_security?}/db2chpw
    fi

    if [ -f ${source_security?}/db2chkau ]; then
        rm -f ${target_security?}/db2chkau
        ln -s ${source_security?}/db2chkau ${target_security?}
    fi

    if [ -d ${DB2DIR?}/security32 -a -d ${DB2DIR?}/security64 ]; then
       mk_server32_plugin=${FALSE?}
    else
       mk_server32_plugin=${TRUE?}
    fi

    AUDITDATA_DIR=${INSTHOME?}/sqllib/security/auditdata
    if [ ! -d ${AUDITDATA_DIR?} ]; then
       mkdirectory ${AUDITDATA_DIR?}
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${AUDITDATA_DIR?}
       mkpermission "u=rwx,go=rx" ${AUDITDATA_DIR?}
    fi 

    if [ -d ${INSTHOME?}/sqllib/security64 ]; then
        create_sec_plugin ${INSTHOME?}/sqllib/security64 security64 \
              ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?} 0
    fi

    if [ -d ${INSTHOME?}/sqllib/security32 ]; then
       create_sec_plugin ${INSTHOME?}/sqllib/security32 security32 \
              ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?} ${mk_server32_plugin?}

    fi

    trax copy_setuid
}

# Copy all the setuid programs from product dir to 
# instance's sqllib dir
copy_setuid_online ()
{
    trac copy_setuid $@
    set ${setopts?}

    source_security=""
    target_security="${INSTHOME?}/${SQLLIB_DIR_NAME?}/security"
    if [ -d ${DB2DIR?}/security64 ]; then
         source_security="${DB2DIR?}/security64"
    else
         source_security="${DB2DIR?}/security32"
    fi

    if [ -f ${source_security?}/db2aud ]; then
        cp ${source_security?}/db2aud ${target_security?}
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${target_security?}/db2aud
        mkpermission "u=rxs,go=x"  ${target_security?}/db2aud
    fi
    if [ ! -f ${target_security?}/db2audit.cfg ]
    then
         cp ${source_security?}/db2audit.cfg ${target_security?}
         chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${target_security?}/db2audit.cfg
         mkpermission "u=rw,go=r" ${target_security?}/db2audit.cfg
    fi

    if [ -f ${source_security?}/db2ckpw ]; then
        cp ${source_security?}/db2ckpw ${target_security?}
        chg_owngrp root ${INSTPGRP?} ${target_security?}/db2ckpw
        mkpermission "u=rxs,go=x" ${target_security?}/db2ckpw
    fi

    if [ -f ${source_security?}/db2flacc ]; then
        cp ${source_security?}/db2flacc ${target_security?}
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${target_security?}/db2flacc
        mkpermission "u=rx,g=xs,o=x" ${target_security?}/db2flacc
    fi

    if [ -f ${source_security?}/db2chpw ]; then
        cp ${source_security?}/db2chpw ${target_security?}
        chg_owngrp root ${INSTPGRP?} ${target_security?}/db2chpw
        mkpermission "u=rxs,go=x" ${target_security?}/db2chpw
    fi

    if [ -f ${source_security?}/db2chkau ]; then
        rm -f ${target_security?}/db2chkau
        ln -s ${source_security?}/db2chkau ${target_security?}
    fi

    if [ -d ${DB2DIR?}/security32 -a -d ${DB2DIR?}/security64 ]; then
       mk_server32_plugin=${FALSE?}
    else
       mk_server32_plugin=${TRUE?}
    fi

    AUDITDATA_DIR=${INSTHOME?}/${SQLLIB_DIR_NAME?}/security/auditdata
    if [ ! -d ${AUDITDATA_DIR?} ]; then
       mkdirectory ${AUDITDATA_DIR?}
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${AUDITDATA_DIR?}
       mkpermission "u=rwx,go=rx" ${AUDITDATA_DIR?}
    fi 

    if [ -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security64 ]; then
        create_sec_plugin ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security64 security64 \
              ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?} 0
    fi

    if [ -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security32 ]; then
       create_sec_plugin ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security32 security32 \
              ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?} ${mk_server32_plugin?}

    fi

    trax copy_setuid
}

nr_copy_setuid ()
{
    trac nr_copy_setuid $@
    set ${setopts?}

    source_security=""
    target_security="${INSTHOME?}/sqllib/security"
    if [ -d ${DB2DIR?}/security64 ]; then
         source_security="${DB2DIR?}/security64"
    else
         source_security="${DB2DIR?}/security32"
    fi

    if [ -f ${source_security?}/db2aud ]; then
        cp -f ${source_security?}/db2aud ${target_security?}
        mkpermission "u=rx,go=rx"  ${target_security?}/db2aud
    fi
    if [ ! -f ${target_security?}/db2audit.cfg ]
    then
         cp -f ${source_security?}/db2audit.cfg ${target_security?}
         mkpermission "u=rw,go=rw" ${target_security?}/db2audit.cfg
    fi

    if [ -f ${source_security?}/db2ckpw ]; then
        cp -f ${source_security?}/db2ckpw ${target_security?}
        mkpermission "u=rx,go=rx" ${target_security?}/db2ckpw
    fi

    if [ -f ${source_security?}/db2flacc ]; then
        cp -f ${source_security?}/db2flacc ${target_security?}
        mkpermission "u=rx,g=rx,o=rx" ${target_security?}/db2flacc
    fi

    if [ -f ${source_security?}/db2chpw ]; then
        cp -f ${source_security?}/db2chpw ${target_security?}
        mkpermission "u=rx,go=rx" ${target_security?}/db2chpw
    fi

    if [ -f ${source_security?}/db2chkau ]; then
        rm -f ${target_security?}/db2chkau
        ln -s ${source_security?}/db2chkau ${target_security?}
    fi

    if [ -d ${DB2DIR?}/security32 -a -d ${DB2DIR?}/security64 ]; then
       mk_server32_plugin=${FALSE?}
    else
       mk_server32_plugin=${TRUE?}
    fi

    AUDITDATA_DIR=${INSTHOME?}/sqllib/security/auditdata
    if [ ! -d ${AUDITDATA_DIR?} ]; then
       mkdirectory ${AUDITDATA_DIR?}
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${AUDITDATA_DIR?}
       mkpermission "u=rwx,go=rwx" ${AUDITDATA_DIR?}
    fi

    if [ -d ${INSTHOME?}/sqllib/security64 ]; then
        nr_create_sec_plugin ${INSTHOME?}/sqllib/security64 security64 \
              ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?} 0
    fi

    if [ -d ${INSTHOME?}/sqllib/security32 ]; then
       nr_create_sec_plugin ${INSTHOME?}/sqllib/security32 security32 \
              ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?} ${mk_server32_plugin?}

    fi

    trax nr_copy_setuid
}

# Set up the security plugin directory
create_sec_plugin ()
{
    trac create_sec_plugin $@
    set ${setopts?}
    PLUGIN_DIR="$1"     # The security plugin top dir to make
    LINK_IBM="$2"       # Where should the Link for "IBM" go under $PLUGIN_DIR/plugin
    INSTNAME="$3"       # Instance ID name
    INSTPGRP="$4"       # Instance group name
    INSTHOME="$5"       # Instance home directory
    MK_SERVER="$6"      # If the server directory under security32/plugin is needed

    if [ ! -d ${PLUGIN_DIR?} ]; then 
       mkdirectory ${PLUGIN_DIR?}  
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${PLUGIN_DIR?}
       mkpermission "u=rwx,go=rx" ${PLUGIN_DIR?}
    fi
    if [ ! -d ${PLUGIN_DIR?}/plugin ]; then
       mkdirectory ${PLUGIN_DIR?}/plugin 
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${PLUGIN_DIR?}/plugin
       mkpermission "u=rwx,go=rx" ${PLUGIN_DIR?}/plugin
    fi
    
    if [ ${MK_SERVER?} != ${TRUE?} ]; then
       plugin_dirs="client group"
    else
       plugin_dirs="client server group"
    fi

    for dir in ${plugin_dirs?}
    do
        if [ ! -d ${PLUGIN_DIR?}/plugin/${dir?} ]; then
            mkdirectory ${PLUGIN_DIR?}/plugin/${dir?}
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${PLUGIN_DIR?}/plugin/${dir?}
            mkpermission "u=rwx,go=rx" ${PLUGIN_DIR?}/plugin/${dir?}
        fi
    done
    
    if [ -d  ${DB2DIR?}/${LINK_IBM?}/plugin/IBM ]; then
       rm  -f ${PLUGIN_DIR?}/plugin/IBM
       ln  -s ${DB2DIR?}/${LINK_IBM?}/plugin/IBM \
                      ${PLUGIN_DIR?}/plugin/.
    fi

    trax create_sec_plugin
}

nr_create_sec_plugin ()
{
    trac nr_create_sec_plugin $@
    set ${setopts?}
    PLUGIN_DIR="$1"     # The security plugin top dir to make
    LINK_IBM="$2"       # Where should the Link for "IBM" go under $PLUGIN_DIR/plugin
    INSTNAME="$3"       # Instance ID name
    INSTPGRP="$4"       # Instance group name
    INSTHOME="$5"       # Instance home directory
    MK_SERVER="$6"      # If the server directory under security32/plugin is needed

    if [ ! -d ${PLUGIN_DIR?} ]; then 
       mkdirectory ${PLUGIN_DIR?}  
       mkpermission "u=rwx,go=rx" ${PLUGIN_DIR?}
    fi
    if [ ! -d ${PLUGIN_DIR?}/plugin ]; then
       mkdirectory ${PLUGIN_DIR?}/plugin 
       mkpermission "u=rwx,go=rx" ${PLUGIN_DIR?}/plugin
    fi
    
    if [ ${MK_SERVER?} != ${TRUE?} ]; then
       plugin_dirs="client group"
    else
       plugin_dirs="client server group"
    fi

    for dir in ${plugin_dirs?}
    do
        if [ ! -d ${PLUGIN_DIR?}/plugin/${dir?} ]; then
            mkdirectory ${PLUGIN_DIR?}/plugin/${dir?}
            mkpermission "u=rwx,go=rx" ${PLUGIN_DIR?}/plugin/${dir?}
        fi
    done
    
    trax nr_create_sec_plugin
}

# Updates the files in sqllib/acs directory and
# sets the file ownerships and permissions
update_acs ()
{
    trac update_acs $@
    set ${setopts?}
    for license_file in ${INSTHOME?}/sqllib/acs/${ACS_LIC?} ; do break; done
    if [ -f ${license_file?} ]; then
       return 0
    fi

    db2dir_acs_org=$1
    instance_action=$2
    acs_exist=$3
    acs_caller="${DB2DIR?}/instance/db2icrt"

    if [ $# -ne 3 ]; then
       echo "ERROR: Usage update_acs <OriginalDB2DIR> <InstanceAction> <ACS_EXIST>"
       exit 67
    fi

    if [ "X${instance_action?}" = "Xnew" -a \
         "${db2dir_acs_org?}" != "${DB2DIR?}" ]; then
       acs_caller="${DB2DIR?}/instance/db2iupgrade"
    elif  [ "X${instance_action?}" = "Xupdate" ]; then
       acs_caller="${DB2DIR?}/instance/db2iupdt"
    fi

    acs_tmp_log=/tmp/db2_update_acs.$$
    acs_tmp_log_instance=/tmp/db2_update_acs_${INSTNAME?}.$$
    acs_rc1=${TRUE?}
    acs_rc2=${TRUE?}

    if [ -f ${acs_tmp_log?} ]; then
       rm -f ${acs_tmp_log?} 
       touch ${acs_tmp_log?}
    fi
    if [ -f ${acs_tmp_log_instance?} ]; then
       rm -f ${acs_tmp_log_instance?}
    fi

    #Clean up DB2 ACS files 
    if [ "${instance_action?}" = "new" \
         -o "${instance_action?}" = "update" ]; then
       if [ -d ${DB2DIR?}/acs -a ${INSTHOME?}/sqllib/acs \
            -a "${db2dir_acs_org?}" != "${DB2DIR?}" ]; then
          cd ${INSTHOME?}/sqllib/acs
          find . -type f | while read file
          do
             if [ -f ${db2dir_acs_org?}/acs/${file?} -a ! -f ${DB2DIR?}/acs/${file?} ]; then
                rm -f  ${INSTHOME?}/sqllib/acs/${file?}
             fi 
          done
       fi
    fi
    if [ "${instance_action?}" != "upgrade" \
         -a -d ${DB2DIR?}/acs -a ${INSTTYPE?} -ne ${ITYPE_CLN?} ]; then
       cp -pr ${DB2DIR?}/acs ${INSTHOME?}/sqllib/
       chg_owngrp -R ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/acs
       if [ -f ${DB2DIR?}/acs/setup_db2.sh -a -d ${INSTHOME?}/sqllib/acs ]; then
          ${DB2DIR?}/acs/setup_db2.sh -a enable -d ${INSTHOME?}/sqllib \
                  -u ${INSTNAME?} -g ${INSTPGRP?} 2>&1 > ${acs_tmp_log?}
          acs_rc1=$?
          if [ ${acs_rc1?} -eq ${TRUE?} ]; then
             ${DB2DIR?}/acs/setup_db2.sh -a start -d ${INSTHOME?}/sqllib \
                  -u ${INSTNAME?} -g ${INSTPGRP?} 2>&1 > ${acs_tmp_log_instance?}
             acs_rc2=$?
          fi
         
       fi
       if [ -f ${acs_tmp_log?} -a -f ${acs_tmp_log_instance?} ]; then
          cat ${acs_tmp_log_instance?} >> ${acs_tmp_log?}
          rm -f ${acs_tmp_log_instance?}
       fi
       if [ ${acs_rc1?} -eq ${TRUE?} -a ${acs_rc2?} -eq ${TRUE?} ]; then
          if [ -f ${acs_tmp_log?} ]; then
             rm -f ${acs_tmp_log?}
          fi 
          if [ -f ${acs_tmp_log_instance?} ]; then
             rm -f ${acs_tmp_log_instance?}
          fi
       fi
    fi

    ${DB2DIR?}/install/db2ls -q -f ACS > /dev/null 2>&1
    if [ $? -ne 0 ]; then
       rm -rf ${INSTHOME?}/sqllib/acs
    fi

    trax update_acs
}
# Updates the files in sqllib/acs directory and
# sets the file ownerships and permissions
update_acs_online ()
{
    trac update_acs_online $@
    set ${setopts?}
    for license_file in ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs/${ACS_LIC?} ; do break; done
    if [ -f ${license_file?} ]; then
       return 0
    fi

    db2dir_acs_org=$1
    instance_action=$2
    acs_exist=$3
    acs_caller="${DB2DIR?}/instance/db2icrt"

    if [ $# -ne 3 ]; then
       echo "ERROR: Usage update_acs <OriginalDB2DIR> <InstanceAction> <ACS_EXIST>"
       exit 67
    fi

    if [ "X${instance_action?}" = "Xnew" -a \
         "${db2dir_acs_org?}" != "${DB2DIR?}" ]; then
       acs_caller="${DB2DIR?}/instance/db2iupgrade"
    elif  [ "X${instance_action?}" = "Xupdate" ]; then
       acs_caller="${DB2DIR?}/instance/db2iupdt"
    fi

    acs_tmp_log=/tmp/db2_update_acs.$$
    acs_tmp_log_instance=/tmp/db2_update_acs_${INSTNAME?}.$$
    acs_rc1=${TRUE?}
    acs_rc2=${TRUE?}

    if [ -f ${acs_tmp_log?} ]; then
       rm -f ${acs_tmp_log?} 
       touch ${acs_tmp_log?}
    fi
    if [ -f ${acs_tmp_log_instance?} ]; then
       rm -f ${acs_tmp_log_instance?}
    fi

    #Clean up DB2 ACS files 
    if [ "${instance_action?}" = "new" \
         -o "${instance_action?}" = "update" ]; then
       if [ -d ${DB2DIR?}/acs -a ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs \
            -a "${db2dir_acs_org?}" != "${DB2DIR?}" ]; then
          cd ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs
          find . -type f | while read file
          do
             if [ -f ${db2dir_acs_org?}/acs/${file?} -a ! -f ${DB2DIR?}/acs/${file?} ]; then
                rm -f  ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs/${file?}
             fi 
          done
       fi
    fi

    if [ "${instance_action?}" != "upgrade" \
         -a -d ${DB2DIR?}/acs ]; then
       cp -pr ${DB2DIR?}/acs ${INSTHOME?}/${SQLLIB_DIR_NAME?}/
       chg_owngrp -R ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs
       if [ -f ${DB2DIR?}/acs/setup_db2.sh -a -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs ]; then
          ${DB2DIR?}/acs/setup_db2.sh -a enable -d ${INSTHOME?}/${SQLLIB_DIR_NAME?} \
                  -u ${INSTNAME?} -g ${INSTPGRP?} 2>&1 > ${acs_tmp_log?}
          acs_rc1=$?
          if [ ${acs_rc1?} -eq ${TRUE?} ]; then
             ${DB2DIR?}/acs/setup_db2.sh -a start -d ${INSTHOME?}/${SQLLIB_DIR_NAME?} \
                  -u ${INSTNAME?} -g ${INSTPGRP?} 2>&1 > ${acs_tmp_log_instance?}
             acs_rc2=$?
          fi
         
       fi
       if [ -f ${acs_tmp_log?} -a -f ${acs_tmp_log_instance?} ]; then
          cat ${acs_tmp_log_instance?} >> ${acs_tmp_log?}
          rm -f ${acs_tmp_log_instance?}
       fi
       if [ ${acs_rc1?} -eq ${TRUE?} -a ${acs_rc2?} -eq ${TRUE?} ]; then
          if [ -f ${acs_tmp_log?} ]; then
             rm -f ${acs_tmp_log?}
          fi 
          if [ -f ${acs_tmp_log_instance?} ]; then
             rm -f ${acs_tmp_log_instance?}
          fi
       fi
    fi

    ${DB2DIR?}/install/db2ls -q -f ACS > /dev/null 2>&1
    if [ $? -ne 0 ]; then
       rm -rf ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs
    fi

    trax update_acs_online
}

# Updates the files in sqllib/adm directory and
# sets the file ownerships and permissions
update_adm ()
{
    trac update_adm $@
    set ${setopts?}

    # if we are not changing bit width, some files in adm may be user-owned
    # files.  We will save them.
    ls -1 ${INSTHOME?}/sqllib/adm | while read fname; do
        if [ ! -f ${DB2DIR?}/adm/${fname?} ]; then
            if [ ! -d ${INSTHOME?}/sqllib/adm.bck ]; then
                mkdirectory ${INSTHOME?}/sqllib/adm.bck
            fi
            mv ${INSTHOME?}/sqllib/adm/${fname?} ${INSTHOME?}/sqllib/adm.bck
        fi
    done

    # Copy the adm files from the $DB2DIR/adm directory.
    rm -f ${INSTHOME?}/sqllib/adm/* 2> /dev/null
    cp ${DB2DIR?}/adm/* ${INSTHOME?}/sqllib/adm
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 86 \
            'DBI1086E An attempt to copy the file or directory %s to %s failed.\n' \
            ${DB2DIR?}/adm ${INSTHOME?}/sqllib/adm
        stop_prog 1
    fi

    # Remove extra files from "adm" dir
    rm -f ${INSTHOME?}/sqllib/adm/db2sysc_s
    rm -f ${INSTHOME?}/sqllib/adm/db2sysc_r
    rm -f ${INSTHOME?}/sqllib/adm/db2cccor
    rm -f ${INSTHOME?}/sqllib/adm/db2dasit
    rm -f ${INSTHOME?}/sqllib/adm/db2job

    # Set bit type currently in use.
    query_instuse ${INSTNAME?} "BitWidth" 32
    INSTBITWIDTH="${INSTUSE_VALUE?}"

    # Call db2iuadm function that sets permissions to all files in the
    # adm directory
    ${DB2DIR?}/instance/db2iuadm ${INSTHOME?}/sqllib ${INSTNAME?} ${INSTPGRP?} \
             ${FENCEDID:=fencedid} ${FENCPGRP:=fencpgrp} ${INSTTYPE?} "set" ${setopts?}

    # Remove the adm.bck dir if we created it
    if [ -d ${INSTHOME?}/sqllib/adm.bck ]
    then
        # there may not be any files, so mv will fail - but that's normal
        # and ok, so just ignore the error message.
        mv ${INSTHOME?}/sqllib/adm.bck/* ${INSTHOME?}/sqllib/adm 2> /dev/null
        rm -rf ${INSTHOME?}/sqllib/adm.bck
    fi

    ## for non-SD instance, we need to clean up the following files only for non-SD instance
    if [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]
    then
        ca_files="db2castart db2castop db2rocm db2rocme db2rocmc"
        for ca_file in ${ca_files?}; do   
           if [ -f  ${INSTHOME?}/sqllib/adm/${ca_file?} ]
           then
               rm -f ${INSTHOME?}/sqllib/adm/${ca_file?}
           fi
        done
    fi 

    trax update_adm
}

# Updates the files in sqllib/adm directory and
# sets the file ownerships and permissions
update_adm_online ()
{
    trac update_adm_online $@
    set ${setopts?}

    # if we are not changing bit width, some files in adm may be user-owned
    # files.  We will save them.
    ls -1 ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm | while read fname; do
        if [ ! -f ${DB2DIR?}/adm/${fname?} ]; then
            if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm.bck ]; then
                mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm.bck
            fi
            mv ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/${fname?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm.bck
        fi
    done

    # Copy the adm files from the $DB2DIR/adm directory.
    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/* 2> /dev/null
    cp ${DB2DIR?}/adm/* ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 86 \
            'DBI1086E An attempt to copy the file or directory %s to %s failed.\n' \
            ${DB2DIR?}/adm ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm
        stop_prog 1
    fi

    # Remove extra files from "adm" dir
    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/db2sysc_s
    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/db2sysc_r
    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/db2cccor
    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/db2dasit
    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/db2job

    # Set bit type currently in use.
    query_instuse ${INSTNAME?} "BitWidth" 32
    INSTBITWIDTH="${INSTUSE_VALUE?}"

    # Call db2iuadm function that sets permissions to all files in the
    # adm directory
    ${DB2DIR?}/instance/db2iuadm ${INSTHOME?}/${SQLLIB_DIR_NAME?} ${INSTNAME?} ${INSTPGRP?} \
             ${FENCEDID:=fencedid} ${FENCPGRP:=fencpgrp} ${INSTTYPE?} "set" ${setopts?}

    # Remove the adm.bck dir if we created it
    if [ -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm.bck ]
    then
        # there may not be any files, so mv will fail - but that's normal
        # and ok, so just ignore the error message.
        mv ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm.bck/* ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm 2> /dev/null
        rm -rf ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm.bck
    fi

    ## for non-SD instance, we need to clean up the following files only for non-SD instance
    if [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]
    then
        ca_files="db2castart db2castop db2rocm db2rocme db2rocmc"
        for ca_file in ${ca_files?}; do   
           if [ -f  ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/${ca_file?} ]
           then
               rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/${ca_file?}
           fi
        done
    fi 

    trax update_adm_online
}

update_db2tss()
{
   trac update_db2tss $@
   set ${setopts?}

   query_instuse ${INSTNAME?} InstallerID 99999
   InstallerID="${INSTUSE_VALUE?}"
   if [ ${InstallerID?} -eq 0 ]; then
      # make all files in db2tss/bin dir links back to the install dir
      if [ ! -h ${INSTHOME?}/sqllib/db2tss/bin -a -d ${INSTHOME?}/sqllib/db2tss/bin ]; then
         cd ${INSTHOME?}/sqllib/db2tss/bin
         rm -rf ${INSTHOME?}/sqllib/db2tss/bin/* 1> /dev/null 2> /dev/null  
         ln -s ${DB2DIR?}/db2tss/bin/*    ${INSTHOME?}/sqllib/db2tss/bin/. 1> /dev/null 2> /dev/null
      fi
   fi

   DB2TSSDIR="ddl lib resource plugins"
   for name in ${DB2TSSDIR?}
   do
   if [ ${InstallerID?} -eq 0 ]; then
      rm -f ${INSTHOME?}/sqllib/db2tss/${name?} 1> /dev/null 2> /dev/null
      ln -s ${DB2DIR?}/db2tss/${name?}    ${INSTHOME?}/sqllib/db2tss/${name?} 1> /dev/null 2> /dev/null
   else
      if [ -d ${INSTHOME}/sqllib/db2tss/${name?} ]; then
         find ${INSTHOME}/sqllib/db2tss/${name?}/* -type f -print 2>/dev/null | \
         while read file; do
            mkpermission "u=r,go=r" ${file?}
         done
      fi
   fi
   done
 
   # create convenience links for the text search tools
   link_db2tss_tools

   trax update_db2tss
}

# This function updates the .instuse file to mark it as configured for a 
# particular DB2 functions.
update_instuse()
{
    trac update_instuse $@
    set ${setopts?}
 
    INST2UPDT=$1
    DB2FTN=$2
    FTNVALUE=$3
    BYDAS="$4"
    instuse="sqllib/.instuse"
    if [ "X${BYDAS?}" = "Xdas" ]; then
       instuse="das/ctrl/.instuse"
    fi

    if [ "${DB2FTN?}" = "BitWidth" ]; then
          DB2FTN_REAL="RealBitWidth"

          FTNVALUE_REAL=${FTNVALUE?}
    
    fi

    CMD_DB2FUPDT=${DB2DIR?}/bin/db2fupdt
    find_homedir ${INST2UPDT?}
    INSTUSE=${USERHOME?}/${instuse?}
    if [ ! -f ${INSTUSE?} ] && [ -f ${USERHOME?}/sqllib/ctrl/.instuse ]
    then
        db2_inst_ver=`${DB2DIR?}/bin/db2fupdt -f ${USERHOME?}/sqllib/ctrl/.instuse -p INSTVER`
        if [ ${db2_inst_ver?} -le ${DB2VER_V97?} ]
        then
            INSTUSE="${USERHOME?}/sqllib/ctrl/.instuse"
        fi
    fi
    
    ${CMD_DB2FUPDT?} -f ${INSTUSE?} -p ${DB2FTN?} -v ${FTNVALUE?} 1>/dev/null 2>/dev/null
    if [ "${DB2FTN?}" = "BitWidth" ]; then
         ${CMD_DB2FUPDT?} -f ${INSTUSE?} -p ${DB2FTN_REAL?} -v ${FTNVALUE_REAL?}
    fi    

    trax update_instuse
}
# This function updates the .instuse file to mark it as configured for a 
# particular DB2 functions.
update_instuse_online()
{
    trac update_instuse_online $@
    set ${setopts?}
 
    INST2UPDT=$1
    DB2FTN=$2
    FTNVALUE=$3
    BYDAS="$4"
    instuse="${SQLLIB_DIR_NAME?}/.instuse"
    if [ "X${BYDAS?}" = "Xdas" ]; then
       instuse="das/ctrl/.instuse"
    fi

    if [ "${DB2FTN?}" = "BitWidth" ]; then
          DB2FTN_REAL="RealBitWidth"

          FTNVALUE_REAL=${FTNVALUE?}
    
    fi

    CMD_DB2FUPDT=${DB2DIR?}/bin/db2fupdt
    find_homedir ${INST2UPDT?}
    INSTUSE=${USERHOME?}/${instuse?}
    if [ ! -f ${INSTUSE?} ] && [ -f ${USERHOME?}/${SQLLIB_DIR_NAME?}/ctrl/.instuse ]
    then
        db2_inst_ver=`${DB2DIR?}/bin/db2fupdt -f ${USERHOME?}/${SQLLIB_DIR_NAME?}/ctrl/.instuse -p INSTVER`
        if [ ${db2_inst_ver?} -le ${DB2VER_V97?} ]
        then
            INSTUSE="${USERHOME?}/${SQLLIB_DIR_NAME?}/ctrl/.instuse"
        fi
    fi
    
    ${CMD_DB2FUPDT?} -f ${INSTUSE?} -p ${DB2FTN?} -v ${FTNVALUE?} 1>/dev/null 2>/dev/null
    if [ "${DB2FTN?}" = "BitWidth" ]; then
         ${CMD_DB2FUPDT?} -f ${INSTUSE?} -p ${DB2FTN_REAL?} -v ${FTNVALUE_REAL?}
    fi    

    trax update_instuse_online
}

# This function does real update for the .instuse file
# for the common values of the current installation.
_update_instuse()
{
    trac _update_instuse $@
    set ${setopts?}
    bydas="$1"
    runner=`${DB2DIR?}/bin/db2usrinf -E`
    if [ "X${bydas}" != "Xdas" ]; then
       update_instuse ${INSTNAME?} DB2DIR  ${DB2DIR?} "${bydas?}"
       update_instuse ${INSTNAME?} InstanceType ${INSTTYPE?} "${bydas?}"
       update_instuse ${INSTNAME?} InstallerID ${runner?} "${bydas?}"
    fi
    update_instuse ${INSTNAME?} INSTVER ${DB2VER_CURRENT?} "${bydas?}"
    update_instuse ${INSTNAME?} V ${CurVERSION?} "${bydas?}"
    update_instuse ${INSTNAME?} R ${CurRELEASE?} "${bydas?}"
    update_instuse ${INSTNAME?} M ${CurMODIFICATION?} "${bydas?}"
    update_instuse ${INSTNAME?} F ${CurFIXLEVEL?} "${bydas?}"
    update_instuse ${INSTNAME?} I ${CurINTERIM?} "${bydas?}"
    update_instuse ${INSTNAME?} S ${CurINSTALLP?} "${bydas?}"
    update_instuse ${INSTNAME?} SpecialBuild ${CurSpecialBuild?} "${bydas?}"
    if [ "X${bydas}" != "Xdas" ]; then
        #For SD add SDInstance=0 to .instuse
        if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]
        then
            update_instuse ${INSTNAME?} SDInstance 0
        fi
    fi
    trax _update_instuse
}
# This function does real update for the .instuse file
# for the common values of the current installation.
_update_instuse_online()
{
    trac _update_instuse_online $@
    set ${setopts?}
    bydas="$1"
    runner=`${DB2DIR?}/bin/db2usrinf -E`
    if [ "X${bydas}" != "Xdas" ]; then
       update_instuse_online ${INSTNAME?} DB2DIR  ${DB2DIR?} "${bydas?}"
       update_instuse_online ${INSTNAME?} InstanceType ${INSTTYPE?} "${bydas?}"
       update_instuse_online ${INSTNAME?} InstallerID ${runner?} "${bydas?}"
    fi
    update_instuse_online ${INSTNAME?} INSTVER ${DB2VER_CURRENT?} "${bydas?}"
    update_instuse_online ${INSTNAME?} V ${CurVERSION?} "${bydas?}"
    update_instuse_online ${INSTNAME?} R ${CurRELEASE?} "${bydas?}"
    update_instuse_online ${INSTNAME?} M ${CurMODIFICATION?} "${bydas?}"
    update_instuse_online ${INSTNAME?} F ${CurFIXLEVEL?} "${bydas?}"
    update_instuse_online ${INSTNAME?} I ${CurINTERIM?} "${bydas?}"
    update_instuse_online ${INSTNAME?} S ${CurINSTALLP?} "${bydas?}"
    update_instuse_online ${INSTNAME?} SpecialBuild ${CurSpecialBuild?} "${bydas?}"
    if [ "X${bydas}" != "Xdas" ]; then
        #For SD add SDInstance=0 to .instuse
        if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]
        then
            update_instuse_online ${INSTNAME?} SDInstance 0
        fi
    fi
    trax _update_instuse_online
}

# This function queries the current .instuse to find a string
query_instuse_string()
{
    trac query_instuse_string $@
    set ${setopts?}

    INST2QUERY="$1"
    DB2FTN="$2"
    DEFAULT="$3"
    BYDAS="$4"

    CMD_DB2FUPDT=${DB2DIR?}/bin/db2fupdt
    find_homedir ${INST2QUERY?}
    INSTUSE=${USERHOME?}/sqllib/.instuse
    if [ "X${BYDAS?}" = "Xdas" ]; then
        INSTUSE=${USERHOME?}/das/ctrl/.instuse
    fi

    if [ ! -f ${INSTUSE?} ] && [ -f ${USERHOME?}/sqllib/ctrl/.instuse ]
    then
        db2_inst_ver=`${DB2DIR?}/bin/db2fupdt -f ${USERHOME?}/sqllib/ctrl/.instuse -p INSTVER`
        if [ ${db2_inst_ver?} -le ${DB2VER_V97?} ]
        then
            INSTUSE="${USERHOME?}/sqllib/ctrl/.instuse"
        fi
    fi

    INSTUSE_VALUE=`${CMD_DB2FUPDT?} -f ${INSTUSE?} -p ${DB2FTN?}`
    rc=$?

    # if no output (error), assume default.
    if [ ${rc?} -ne 0 ]
    then
        INSTUSE_VALUE="${DEFAULT?}"
    fi
    trax query_instuse_string
    return ${rc?}
}

# This function queries the current .instuse to find a string for nonroot install
query_instuse_string_nr()
{
    trac query_instuse_string_nr $@
    set ${setopts?}

    INST2QUERY="$1"
    DB2FTN="$2"
    DEFAULT="$3"
    OLDSQLLIBDIR="$4"

    CMD_DB2FUPDT=${DB2DIR?}/bin/db2fupdt
    find_homedir ${INST2QUERY?}

    if [ -f ${OLDSQLLIBDIR?}/ctrl/.instuse ];
    then
       INSTUSE=${OLDSQLLIBDIR?}/ctrl/.instuse
    else
       INSTUSE=${OLDSQLLIBDIR?}/.instuse
    fi

    INSTUSE_VALUE=`${CMD_DB2FUPDT?} -f ${INSTUSE?} -p ${DB2FTN?}`
    rc=$?

    # if no output (error), assume default.
    if [ ${rc?} -ne 0 ]
    then
        INSTUSE_VALUE="${DEFAULT?}"
    fi
    trax query_instuse_string
    return ${rc?}
}

# This function queries the current .instuse to find out if it has been
# configured for a particular DB2 function.
query_instuse()
{
    trac query_instuse $@
    set ${setopts?}

    query_instuse_string "$1" "$2" "$3" "$4"

    trax query_instuse
    return ${INSTUSE_VALUE?}
}

# Function to update the instance with functionalities that has been
# set up already.
update_instftn()
{
    trac update_instftn $@
    set ${setopts?}

    # "InstanceType" not 'updatable'
    for db2ftn in OLAPSK DLFM
    do
        query_instuse ${INSTNAME?} ${db2ftn?} ${FALSE?}
        if [ $? -eq ${TRUE?} ]
        then
            case ${db2ftn?} in
                "OLAPSK")
                    ${DB2DIR?}/instance/db2olset ${INSTNAME?}
                    ;;
                "DLFM")
                    : # nothing yet
                    ;;
            esac
        fi
    done

    trax update_instftn
}

# function retuns TRUE if iType is Client, FALSE otherwise
itype_client()
{
    trac itype_client $@
    set ${setopts?}

    if [ ${INSTTYPE?} -eq ${ITYPE_CLN?} ]; then
        return ${TRUE?}
    else
        return ${FALSE?}
    fi

    trax itype_client
}

# This function figures out what itype to use.  It will get saved during
# copy_dbmcfg
prepare_itype ()
{
    trac prepare_itype $@
    set ${setopts?}

    # if the config file is given on the command line, use that
    if [ ${DB2DLNK?} -eq 0 ]; then
        CFGFILE=db2syssv
        INSTTYPE=${ITYPE_DLN?}
    elif [ ${KEEPITYPE?} -eq ${TRUE?} ]; then
        chk_itype
        case ${INSTTYPE?} in
            "${ITYPE_EEE?}")
                 CFGFILE="db2sysmp" ;;
            "${ITYPE_SD?}")
                 CFGFILE="db2sysmp" ;;
            "${ITYPE_SRV?}")
                 CFGFILE="db2syssv" ;;
            "${ITYPE_PER?}")
                 CFGFILE="db2syssr" ;;
            "${ITYPE_CLN?}")
                 CFGFILE="db2sysrq" ;;
         esac
    elif [ "X${CFGFILE?}" != "X" ]
    then
        case "${CFGFILE?}" in
            "db2sysmp")
                if [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]
                then
                    INSTTYPE=${ITYPE_EEE?}
                fi
            ;;
            "db2syssv")
                INSTTYPE=${ITYPE_SRV?} ;;
            "db2syssr")
                INSTTYPE=${ITYPE_PER?} ;;
            "db2sysrq")
                INSTTYPE=${ITYPE_CLN?} ;;
            *)
                display_msg ${DB2CAT?} 69 \
                    'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                    copy_dbmcfg 21
                stop_prog 1 ;;
        esac
    elif [ -f ${DB2DIR?}/cfg/db2sysmp ]; then
        CFGFILE=db2sysmp
        is_sd_copy
        if [ $? -eq ${TRUE?} ]
        then
            INSTTYPE=${ITYPE_SD?}
        else
            INSTTYPE=${ITYPE_EEE?}
        fi
    elif [ -f ${DB2DIR?}/cfg/db2syssv ]; then
        CFGFILE=db2syssv
        INSTTYPE=${ITYPE_SRV?}
    elif [ -f ${DB2DIR?}/cfg/db2syssr ]; then
        CFGFILE=db2syssr
        INSTTYPE=${ITYPE_PER?}
    elif [ -f ${DB2DIR?}/cfg/db2sysrq ]; then
        CFGFILE=db2sysrq
        INSTTYPE=${ITYPE_CLN?}
    else
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' \
            ${DB2DIR?}/cfg/db2sysrq
        stopprog 1
    fi

    # Connect PE is treated like a client
    if [   -f ${DB2DIR?}/cfg/db2conpe.lvl -a \
         ! -f ${DB2DIR?}/cfg/db2wse.lvl -a   \
         ! -f ${DB2DIR?}/cfg/db2exp.lvl -a   \
         ! -f ${DB2DIR?}/cfg/db2ese.lvl -a   \
         ! -f ${DB2DIR?}/cfg/db2consv.lvl -a   \
         ! -f ${DB2DIR?}/cfg/db2sd.lvl \
       ]; then
        INSTTYPE=${ITYPE_CLN?}
    fi

    trax prepare_itype
}

# This function copies the default database manager 
# configuration file into the sqllib directory 
copy_dbmcfg ()
{
    trac copy_dbmcfg $@
    set ${setopts?}

    rc=${FALSE?}          # Return code

    #---------------------------------------------------------------------
    # Copy the default system configuration file into the sqllib directory.
    #---------------------------------------------------------------------
    # If config file is given on the command line, use that
    if [ ${DB2DLNK?} -eq 0 ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2syssv db2systm
        rc=$?
        make_itype ${ITYPE_DLN?}
    elif [ "X${CFGFILE?}" != "X" ]; then
        is_sd_copy
        if [ $? -eq ${TRUE?} ] && [ ! -z "$SD_INSTPROF" ] && [ -f  ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/db2systm ]
        then
          copyfile -n ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/  ${INSTHOME?}/sqllib/ db2systm db2systm
       else
          copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib ${CFGFILE?} db2systm
        fi
        rc=$?

        # Depending upon the name of the dbm cfg file, create
        # an appropriate instance-type file 
        case "${CFGFILE?}" in
            "db2sysmp")
                if [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]
                then
                   make_itype ${ITYPE_EEE?}
                else
                   make_itype ${ITYPE_SD?}
                fi ;;
            "db2syssv")
                make_itype ${ITYPE_SRV?} ;;
            "db2syssr")
                make_itype ${ITYPE_PER?} ;;
            "db2sysrq")
                make_itype ${ITYPE_CLN?} ;;
            *)
                display_msg ${DB2CAT?} 69 \
                    'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                    copy_dbmcfg 21
                stop_prog 1 ;;
        esac
    elif [ ${KEEPITYPE?} -eq ${TRUE?} ]; then
        insttype=`cat ${ITYPEFILE?}`
        case ${insttype?} in
            "${ITYPE_EEE?}")
                 cfgfile="db2sysmp" ;;
            "${ITYPE_SD?}")
                 cfgfile="db2sysmp" ;;
            "${ITYPE_SRV?}")
                 cfgfile="db2syssv" ;;
            "${ITYPE_PER?}")
                 cfgfile="db2syssr" ;;
            "${ITYPE_CLN?}")
                 cfgfile="db2sysrq" ;;
         esac
         copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib ${cfgfile?} db2systm 
         rc=$?

    elif [ -f ${DB2DIR?}/cfg/db2sysmp ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2sysmp db2systm
        rc=$?
        if [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]
        then
           make_itype ${ITYPE_EEE?}
        else
           make_itype ${ITYPE_SD?}
        fi
    elif [ -f ${DB2DIR?}/cfg/db2syssv ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2syssv db2systm
        rc=$?
        make_itype ${ITYPE_SRV?}
    elif [ -f ${DB2DIR?}/cfg/db2syssr ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2syssr db2systm
        rc=$?
        make_itype ${ITYPE_PER?}
    elif [ -f ${DB2DIR?}/cfg/db2sysrq ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2sysrq db2systm
        rc=$?
        make_itype ${ITYPE_CLN?}
    else
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' \
            ${DB2DIR?}/cfg/db2sysrq
        rc=${FALSE?}
    fi

        # Connect PE is trated like a client
        # Connect PE is treated like a client
        if [   -f ${DB2DIR?}/cfg/db2conpe.lvl -a \
             ! -f ${DB2DIR?}/cfg/db2wse.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2exp.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2ese.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2consv.lvl    \
           ]; then
            make_itype ${ITYPE_CLN?}
        fi

    # -rw-rw-r-- (664)
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2systm
    mkpermission "ug=rw,o=r" ${INSTHOME?}/sqllib/db2systm

    trax copy_dbmcfg
    return ${rc?}
}

# This function copies the default database manager 
# configuration file into the sqllib directory 
copy_dbmcfg_online ()
{
    trac copy_dbmcfg_online $@
    set ${setopts?}

    rc=${FALSE?}          # Return code

    #---------------------------------------------------------------------
    # Copy the default system configuration file into the sqllib_v10NN directory.
    #---------------------------------------------------------------------
    # If config file is given on the command line, use that
    if [ ${DB2DLNK?} -eq 0 ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?} db2syssv db2systm
        rc=$?
        make_itype_online ${ITYPE_DLN?}
    elif [ "X${CFGFILE?}" != "X" ]; then
        is_sd_copy
        if [ $? -eq ${TRUE?} ] && [ ! -z "$SD_INSTPROF" ] && [ -f  ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/db2systm ]
        then
          copyfile -n ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/  ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ db2systm db2systm
       else
          copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?} ${CFGFILE?} db2systm
        fi
        rc=$?

        # Depending upon the name of the dbm cfg file, create
        # an appropriate instance-type file 
        case "${CFGFILE?}" in
            "db2sysmp")
                if [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]
                then
                   make_itype_online ${ITYPE_EEE?}
                else
                   make_itype_online ${ITYPE_SD?}
                fi ;;
            "db2syssv")
                make_itype_online ${ITYPE_SRV?} ;;
            "db2syssr")
                make_itype_online ${ITYPE_PER?} ;;
            "db2sysrq")
                make_itype_online ${ITYPE_CLN?} ;;
            *)
                display_msg ${DB2CAT?} 69 \
                    'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                    copy_dbmcfg 21
                stop_prog 1 ;;
        esac
    elif [ ${KEEPITYPE?} -eq ${TRUE?} ]; then
        insttype=`cat ${ITYPEFILE?}`
        case ${insttype?} in
            "${ITYPE_EEE?}")
                 cfgfile="db2sysmp" ;;
            "${ITYPE_SD?}")
                 cfgfile="db2sysmp" ;;
            "${ITYPE_SRV?}")
                 cfgfile="db2syssv" ;;
            "${ITYPE_PER?}")
                 cfgfile="db2syssr" ;;
            "${ITYPE_CLN?}")
                 cfgfile="db2sysrq" ;;
         esac
         copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?} ${cfgfile?} db2systm 
         rc=$?

    elif [ -f ${DB2DIR?}/cfg/db2sysmp ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?} db2sysmp db2systm
        rc=$?
        if [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]
        then
           make_itype_online ${ITYPE_EEE?}
        else
           make_itype_online ${ITYPE_SD?}
        fi
    elif [ -f ${DB2DIR?}/cfg/db2syssv ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?} db2syssv db2systm
        rc=$?
        make_itype_online ${ITYPE_SRV?}
    elif [ -f ${DB2DIR?}/cfg/db2syssr ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?} db2syssr db2systm
        rc=$?
        make_itype_online ${ITYPE_PER?}
    elif [ -f ${DB2DIR?}/cfg/db2sysrq ]; then
        copyfile -n ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?} db2sysrq db2systm
        rc=$?
        make_itype_online ${ITYPE_CLN?}
    else
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' \
            ${DB2DIR?}/cfg/db2sysrq
        rc=${FALSE?}
    fi

        # Connect PE is trated like a client
        # Connect PE is treated like a client
        if [   -f ${DB2DIR?}/cfg/db2conpe.lvl -a \
             ! -f ${DB2DIR?}/cfg/db2wse.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2exp.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2ese.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2consv.lvl    \
           ]; then
            make_itype_online ${ITYPE_CLN?}
        fi

    # -rw-rw-r-- (664)
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2systm
    mkpermission "ug=rw,o=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2systm

    trax copy_dbmcfg_online
    return ${rc?}
}

nr_copy_dbmcfg ()
{
    trac nr_copy_dbmcfg $@
    set ${setopts?}

    rc=${FALSE?}          # Return code

    #---------------------------------------------------------------------
    # Copy the default system configuration file into the sqllib directory.
    #---------------------------------------------------------------------
    # If config file is given on the command line, use that
    if [ ${DB2DLNK?} -eq 0 ]; then
        copyfile -f -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2syssv db2systm
        rc=$?
        make_itype ${ITYPE_DLN?}
    elif [ "X${CFGFILE?}" != "X" ]; then
        copyfile -f -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib ${CFGFILE?} db2systm
        rc=$?

        # Depending upon the name of the dbm cfg file, create
        # an appropriate instance-type file 
        case "${CFGFILE?}" in
            "db2sysmp")
                make_itype ${ITYPE_EEE?} ;;
            "db2syssv")
                make_itype ${ITYPE_SRV?} ;;
            "db2syssr")
                make_itype ${ITYPE_PER?} ;;
            "db2sysrq")
                make_itype ${ITYPE_CLN?} ;;
            *)
                display_msg ${DB2CAT?} 69 \
                    'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                    copy_dbmcfg 21
                stop_prog 1 ;;
        esac
    elif [ ${KEEPITYPE?} -eq ${TRUE?} ]; then
        insttype=`cat ${ITYPEFILE?}`
        case ${insttype?} in
            "${ITYPE_EEE?}")
                 cfgfile="db2sysmp" ;;
            "${ITYPE_SRV?}")
                 cfgfile="db2syssv" ;;
            "${ITYPE_PER?}")
                 cfgfile="db2syssr" ;;
            "${ITYPE_CLN?}")
                 cfgfile="db2sysrq" ;;
         esac
         copyfile -f -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib ${cfgfile?} db2systm 
         rc=$?

    elif [ -f ${DB2DIR?}/cfg/db2sysmp ]; then
        copyfile -f -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2sysmp db2systm
        rc=$?
        make_itype ${ITYPE_EEE?}
    elif [ -f ${DB2DIR?}/cfg/db2syssv ]; then
        copyfile -f -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2syssv db2systm
        rc=$?
        make_itype ${ITYPE_SRV?}
    elif [ -f ${DB2DIR?}/cfg/db2syssr ]; then
        copyfile -f -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2syssr db2systm
        rc=$?
        make_itype ${ITYPE_PER?}
    elif [ -f ${DB2DIR?}/cfg/db2sysrq ]; then
        copyfile -f -n ${DB2DIR?}/cfg ${INSTHOME?}/sqllib db2sysrq db2systm
        rc=$?
        make_itype ${ITYPE_CLN?}
    else
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' \
            ${DB2DIR?}/cfg/db2sysrq
        rc=${FALSE?}
    fi

        # Connect PE is trated like a client
        # Connect PE is treated like a client
        if [   -f ${DB2DIR?}/cfg/db2conpe.lvl -a \
             ! -f ${DB2DIR?}/cfg/db2wse.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2exp.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2ese.lvl -a   \
             ! -f ${DB2DIR?}/cfg/db2consv.lvl    \
           ]; then
            make_itype ${ITYPE_CLN?}
        fi

    # -rw-rw-r-- (664)
    mkpermission "ug=rw,o=r" ${INSTHOME?}/sqllib/db2systm

    trax nr_copy_dbmcfg
    return ${rc?}
}

# Update the DBM config file for the instance
updt_dbmcfg ()
{
    trac updt_dbmcfg $@
    set ${setopts?}

    rc=1

    rm -f ${TMPFILE1?}

    # Make updates to the database manager configuration file.
    ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${PROGDIR?}/db2idbm ${INSTNAME?} ${INSTHOME?} ${INSTPGRP?} ${INSTTYPE?} ${AUTHTYPE?} ${TMPFILE1?}"

    rc=$?
    if [ ${DEBUG?} -eq ${TRUE?} ]; then
        tee -a ${DB2INSTLOG?} < ${TMPFILE1?}
    else
        cat ${TMPFILE1?} >> ${DB2INSTLOG?}  # Append the logfile
    fi
    
    rm -f ${TMPFILE1?}

    if [ ${rc?} -eq 2 ]; then
        display_msg ${DB2CAT?} 703 \
            'DBI1703E No valid service name or port number found.\n'
        stop_prog 1
    elif [ ${rc?} -ne 0 ]; then
        display_msg ${DB2CAT?} 281 \
            'DBI1281E The database manager configuration file could not be initialized.\n'
        stop_prog 1
    fi

    trax updt_dbmcfg
}

nr_updt_dbmcfg ()
{
    trac nr_updt_dbmcfg $@
    set ${setopts?}

    rc=1

    rm -f ${TMPFILE1?}

    # Make updates to the database manager configuration file.
    ${PROGDIR?}/db2idbm ${INSTNAME?} ${INSTHOME?} ${INSTPGRP?} ${INSTTYPE?} ${AUTHTYPE?} ${TMPFILE1?}

    rc=$?
    if [ ${DEBUG?} -eq ${TRUE?} ]; then
        tee -a ${DB2INSTLOG?} < ${TMPFILE1?}
    else
        cat ${TMPFILE1?} >> ${DB2INSTLOG?}  # Append the logfile
    fi
    
    rm -f ${TMPFILE1?}

    if [ ${rc?} -eq 2 ]; then
        display_msg ${DB2CAT?} 703 \
            'DBI1703E No valid service name or port number found.\n'
        stop_prog 1
    elif [ ${rc?} -ne 0 ]; then
        display_msg ${DB2CAT?} 281 \
            'DBI1281E The database manager configuration file could not be initialized.\n'
        stop_prog 1
    fi

    trax nr_updt_dbmcfg
}

# Create the default "db2nodes.cfg" file (for EEE)
make_db2nodes ()
{
    trac make_db2nodes $@
    set ${setopts?}
   
  if [ ${ONLINE_PREPARE_SQLLIB_VER?} -ne ${TRUE?} ]; then
     DB2NODES="${INSTHOME?}/sqllib/db2nodes.cfg"
  else
     DB2NODES="${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2nodes.cfg"
  fi
     # If is not a EEE/SD instance then return
     if [ ${INSTTYPE?} -ne ${ITYPE_EEE?} ] &&  [ ${INSTTYPE?} -ne ${ITYPE_SD?} ]; then
         return ${TRUE?}
     fi

     # Get the hostname
     wkstnname=`hostname`

     rm -f ${DB2NODES?}
     echo "0 ${wkstnname?} 0" > ${DB2NODES?}
     if [ $? -ne 0 ]; then
         display_msg ${DB2CAT?} 84 \
             'DBI1084E An attempt to create %s failed.\n' db2nodes.cfg
         stop_prog 1
     fi
     chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${DB2NODES?}
     mkpermission "ug=rw,o=r" ${DB2NODES?}

    trax make_db2nodes
}

nr_make_db2nodes ()
{
    trac nr_make_db2nodes $@
    set ${setopts?}

    DB2NODES="${INSTHOME?}/sqllib/db2nodes.cfg"

    # If is not a EEE instance then return
    if [ ${INSTTYPE?} -ne ${ITYPE_EEE?} ]; then
        return ${TRUE?}
    fi

    # Get the hostname
    wkstnname=`hostname`

    rm -f ${DB2NODES?}
    echo "0 ${wkstnname?} 0" > ${DB2NODES?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create %s failed.\n' db2nodes.cfg
        stop_prog 1
    fi
    mkpermission "ug=rw,o=r" ${DB2NODES?}

    trax nr_make_db2nodes
}

# Create the default "profile" files
make_profiles ()
{
    trac make_profiles $@
    set ${setopts?}

    # Create the files ${INSTHOME?}/sqllib/db2profile and
    # ${INSTHOME?}/sqllib/db2cshrc by performing some substitutions
    # in common files db2profile and db2cshrc (in dir DB2DIR/cfg)
    INSTPROF="${INSTHOME?}/sqllib/db2profile"     # db2profile for the instance
    INSTCSHRC="${INSTHOME?}/sqllib/db2cshrc"      # db2cshrc for the instance

    rm -f ${TMPFILE1?} ${INSTPROF?} ${INSTCSHRC?}

    # Replace "db2dir" with "$DB2DIR"
    echo "s!db2dir!${DB2DIR?}!g" >> ${TMPFILE1?}
    # Replace "instancename" with "$INSTNAME"
    echo "s!instancename!${INSTNAME?}!g" >> ${TMPFILE1?}
    # Replace "instancehomedir" with "$INSTHOME"
    echo "s!instancehomedir!${INSTHOME?}!g" >> ${TMPFILE1?}

    # Create the db2profile file for the instance
    sed -f ${TMPFILE1?} ${DB2DIR?}/cfg/db2profile > ${INSTPROF?}

    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create %s failed.\n' ${INSTPROF?}
        stop_prog 1
    fi

    # Create the db2cshrc file for the instance
    sed -f ${TMPFILE1?} ${DB2DIR?}/cfg/db2cshrc > ${INSTCSHRC?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create %s failed.\n' ${INSTCSHRC?}
        stop_prog 1
    fi

    rm ${TMPFILE1?}

    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTPROF?}
    mkpermission "u=rwx,go=rx" ${INSTPROF?}
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTCSHRC?}
    mkpermission "u=rwx,go=rx" ${INSTCSHRC?}

    touch ${INSTHOME?}/sqllib/.instuse

    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/.instuse
    mkpermission "u=rw,go=r" ${INSTHOME?}/sqllib/.instuse

    # if these don't exist, create them.
    for userfile in userprofile usercshrc
    do
        if [ ! -f ${INSTHOME?}/sqllib/${userfile?} ]
        then
            touch ${INSTHOME?}/sqllib/${userfile?}
            # The following are done for security reasons.
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/${userfile?}
            mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/${userfile?}
        fi
    done

    trax make_profiles
}
# Create the default "profile" files
make_profiles_online ()
{
    trac make_profiles_online $@
    set ${setopts?}

    # Create the files ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2profile and
    # ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2cshrc by performing some substitutions
    # in common files db2profile and db2cshrc (in dir DB2DIR/cfg)
    INSTPROF="${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2profile"     # db2profile for the instance
    INSTCSHRC="${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2cshrc"      # db2cshrc for the instance

    rm -f ${TMPFILE1?} ${INSTPROF?} ${INSTCSHRC?}

    # Replace "db2dir" with "$DB2DIR"
    echo "s!db2dir!${DB2DIR?}!g" >> ${TMPFILE1?}
    # Replace "instancename" with "$INSTNAME"
    echo "s!instancename!${INSTNAME?}!g" >> ${TMPFILE1?}
    # Replace "instancehomedir" with "$INSTHOME"
    echo "s!instancehomedir!${INSTHOME?}!g" >> ${TMPFILE1?}

    # Create the db2profile file for the instance
    sed -f ${TMPFILE1?} ${DB2DIR?}/cfg/db2profile > ${INSTPROF?}

    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create %s failed.\n' ${INSTPROF?}
        stop_prog 1
    fi

    # Create the db2cshrc file for the instance
    sed -f ${TMPFILE1?} ${DB2DIR?}/cfg/db2cshrc > ${INSTCSHRC?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create %s failed.\n' ${INSTCSHRC?}
        stop_prog 1
    fi

    rm ${TMPFILE1?}

    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTPROF?}
    mkpermission "u=rwx,go=rx" ${INSTPROF?}
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTCSHRC?}
    mkpermission "u=rwx,go=rx" ${INSTCSHRC?}

    touch ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.instuse

    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.instuse
    mkpermission "u=rw,go=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.instuse

    # if these don't exist, create them.
    for userfile in userprofile usercshrc
    do
        if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${userfile?} ]
        then
            touch ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${userfile?}
            # The following are done for security reasons.
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${userfile?}
            mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${userfile?}
        fi
    done

    trax make_profiles_online
}

# Create the default "db2rfe.cfg" file in sqllib/instance directory if it does not exist
make_db2rfe_cfg ()
{
    trac make_db2rfe_cfg $@
    set ${setopts?}
    
    # Create the files ${INSTHOME?}/sqllib/instance/db2rfe.cfg
    # by performing some substitutions in the installed db2rfe.cfg (in dir DB2DIR/cfg)
    
    DB2RFECFG="${INSTHOME?}/sqllib/instance/db2rfe.cfg"    
    DB2RFECFG_ORIG="${DB2DIR?}/cfg/db2rfe.cfg.sample"
    
    rm -f ${TMPFILE1?} ${TMPFILE2?}
    if [ -f ${DB2RFECFG?} -o -h ${DB2RFECFG?} ]; then
       return ${TRUE?}
    fi

    # Replace "<instance_name>" with "$INSTNAME"
    echo "s!<instance_name>!${INSTNAME?}!g" > ${TMPFILE1?}

    sed "s!\*\* .*\<instance_name\>.*!!" ${DB2RFECFG_ORIG?} >${TMPFILE2?}
    # Create the db2rfe.cfg file for the nonroot install
    sed -f ${TMPFILE1?} ${TMPFILE2?} > ${DB2RFECFG?}

    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 84 \
            'DBI1084E An attempt to create %s failed.\n' ${DB2RFECFG?}
        stop_prog 1
    fi

    rm ${TMPFILE1?} ${TMPFILE2?}

    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${DB2RFECFG?}
    mkpermission "u=rw,go=r" ${DB2RFECFG?}

    trax make_db2rfe_cfg
}

# Set the dbm cfg file to be used during instance creation
set_portnum()
{
    trac set_portnum $@
    set ${setopts?}

    if [ ${UPDATE_SVCENAME?} -eq ${TRUE?} ]; then

        # Update the SVCENAME parameter of the DBM cfg file
        ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "db2 update dbm cfg using SVCENAME ${PORTNUM?}" 1>/dev/null 2>/dev/null
        rc1=$?

        # Set the DB2COMM to tcpip for this instance
        ${DB2DIR?}/instance/db2iset -i ${INSTNAME?} DB2COMM=tcpip 1>/dev/null 2>/dev/null
        rc2=$?
        if [ ${rc1?} -ne 0 -o ${rc2?} -ne 0 ]; then
            display_msg ${DB2CAT?} 283 \
                'DBI1283E Unable to update communication information for %s\n.' \
                ${INSTNAME?} ${PORTNUM?} ${PORTNUM?}
        fi
    fi

    trax set_portnum
}

# Set the dbm cfg file to be used during instance creation
nr_set_portnum()
{
    trac nr_set_portnum $@
    set ${setopts?}

    if [ ${UPDATE_SVCENAME?} -eq ${TRUE?} ]; then

        # Update the SVCENAME parameter of the DBM cfg file
        db2 update dbm cfg using SVCENAME ${PORTNUM?} 1>/dev/null 2>/dev/null
        rc1=$?

        # Set the DB2COMM to tcpip for this instance
        ${DB2DIR?}/adm/db2set DB2COMM=tcpip 1>/dev/null 2>/dev/null
        rc2=$?
        if [ ${rc1?} -ne 0 -o ${rc2?} -ne 0 ]; then
            display_msg ${DB2CAT?} 283 \
                'DBI1283E Unable to update communication information for %s\n.' \
                ${INSTNAME?} ${PORTNUM?} ${PORTNUM?}
        fi
    fi

    trax nr_set_portnum
}

# Add the primary group name of the first user to the secondary group of
# the second given user.
append_secondary_group ()
{
    trac append_secondary_group $@
    set ${setopts?}

    instName1=$1
    instName2=$2

    # This just checks to see if one instance ALREDY has its primary group as the
    # other's.  If it does, then it already has access to it and we dont need to
    # add its group to the other's secondary group
    priGrp1=`${DB2DIR?}/bin/db2usrinf -g ${instName1?}`
    priGrp2=`${DB2DIR?}/bin/db2usrinf -g ${instName2?}`
    if [ "${priGrp1?}" = "${priGrp2?}" ]; then
        return ${TRUE?}
    fi

    #get_userinfo ${instName1?}
    ${DB2DIR?}/bin/db2usrinf -q ${instName1?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 765 \
            'DBI1765W A non-existing user ID, %s, has been detected from the registry\n' \
            ${instName1?} ${instName1?}
        return ${FALSE?}
    fi
    #get_userinfo ${instName2?}
    ${DB2DIR?}/bin/db2usrinf -q ${instName2?}
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 765 \
            'DBI1765W A non-existing user ID, %s, has been detected from the registry\n' \
            ${instName2?} ${instName2?}
        return ${FALSE?}
    fi

    find_primgrp ${instName1?} 1> /dev/null 2> /dev/null
    instGroup1="${USERPGRP?}"
    find_primgrp ${instName2?} 1> /dev/null 2> /dev/null
    instGroup2="${USERPGRP?}"

    instGroupList2=""
    userGroupList=`${DB2DIR?}/bin/db2usrinf -G ${instName2?}`
    for grpname in ${userGroupList?}; do
        if [ "${grpname?}" != "${instGroup2?}" ]; then
            instGroupList2="${instGroupList2?} ${grpname?}"
        fi
    done

    findwordinstr ${instGroup1?} "${instGroupList2?}"
    if [ $? -ne 0 ]; then

        # if the group isn't already there, but NIS is running, we
        # won't be able to continue.  The user will have to ensure that
        # the groups are modified as we require before creating their 
        # instance.
        nis_running
        if [ $? -eq 0 ]; then
            display_msg ${DB2CAT?} 766 \
                'DBI1766W Cannot change the secondary group list of %s.\n' \
                ${instName2?} 88 ${instGroup1?} ${instName2?}
            return ${FALSE?}
        fi

        grouplist=""
        for grpname in ${instGroupList2?}; do
            if [ "${grpname?}" != "${instGroup1?}" ]; then
                if [ "X${grouplist?}" != "X" ]; then
                    grouplist="${grouplist?}${grpname?},"
                else
                    grouplist="${grpname?},"
                fi
            fi
        done

        usermod -G "${grouplist?}${instGroup1?}" ${instName2?} 1>/dev/null 2>/dev/null
        rc=$?

        if [ ${rc?} -ne 0 ]; then 
            display_msg ${DB2CAT?} 766 \
                'DBI1766W Cannot change the secondary group list of %s.\n' \
                ${instName2?} ${rc?} ${instGroup1?} ${instName2?}
        fi
    fi

    trax append_secondary_group
}

# This function used to backup existing versions of certain
# files before instance update or instance upgrade
backup_instinfo ()
{
    trac backup_instinfo $@
    set ${setopts?}

    backupdir="$1"      # Backup dir

    # Error codes used in this function only
    EXIT_DIR_ERR=2
    EXIT_WRITE_ERR=3

    # List of files to backup
    backuplist=""
    case ${PROGNAME?} in
        db2iupdt|db2iupdt_local)
            backuplist=${backuplist?}"${OLDDB2SYSTM?}   ${LSTDBMCFG?}" ;;
        db2iupgrade|db2iupgrade_local|db2imigr)
            backuplist=${backuplist?}"${OLDDB2SYSTM?}   ${LOGDIRMIGR?}  "
            backuplist=${backuplist?}"${OLDDB2PROFILE?} ${OLDDB2CSHRC?} "
            backuplist=${backuplist?}"${LSTDBDIR?}      ${LSTNODEDIR?}  "
            backuplist=${backuplist?}"${LSTDCSDIR?}     ${LSTDBMCFG?}   " ;;
        * )
            return ${TRUE?} ;;
    esac

    # If old instance-related files exist, archive it.
    if [ -d ${backupdir?} ]; then
        for fname in ${backuplist?}; do
            oldfile="${backupdir?}/${fname?}" 
            if [ -f ${oldfile?} ]; then
                gen_archfile ${oldfile?}   # Sets $archfullname
                mv ${oldfile?} ${archfullname?}
            fi
        done
    fi

    # Set upgrade flag
    case ${PROGNAME?} in
        db2iupdt|db2iupdt_local) migrflag="" ;;
        db2iupgrade|db2iupgrade_local|db2imigr) migrflag="-m" ;;
    esac

    # Save current instance related information (before update/upgrade)
    ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${PROGDIR?}/db2iinfo ${migrflag?} ${INSTNAME?} ${INSTHOME?} ${backupdir?}"

    status=$?

    case ${status?} in
        ${TRUE?})  :    # db2iinfo completed successfully
            ;;
        ${EXIT_DIR_ERR?}|${EXIT_WRITE_ERR?})
            display_msg ${DB2CAT?} 89 \
                'DBI1089E Error in saving current instance related information in the %s directory.\n' ${backupdir?}
            stop_prog 1
            ;;
        *)
            display_msg ${DB2CAT?} 69 \
                'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                backup_instinfo ${status?}
            ;;
    esac

    trax backup_instinfo
    return ${status?}
}

nr_backup_instinfo ()
{
    trac nr_backup_instinfo $@
    set ${setopts?}

    backupdir="$1"      # Backup dir

    # Error codes used in this function only
    EXIT_DIR_ERR=2
    EXIT_WRITE_ERR=3

    # List of files to backup
    backuplist=""
    case ${PROGNAME?} in
        db2nrupdt | db2iupdt | db2nrupdt_local)
            backuplist=${backuplist?}"${OLDDB2SYSTM?}   ${LSTDBMCFG?}" ;;
        * )
            return ${TRUE?} ;;
    esac

    # If old instance-related files exist, archive it.
    if [ -d ${backupdir?} ]; then
        for fname in ${backuplist?}; do
            oldfile="${backupdir?}/${fname?}" 
            if [ -f ${oldfile?} ]; then
                gen_archfile ${oldfile?}   # Sets $archfullname
                mv ${oldfile?} ${archfullname?}
            fi
        done
    fi

    # Set upgrade flag
    case ${PROGNAME?} in
        db2nrupdt | db2iupdt | db2nrupdt_local) migrflag="" ;;
        db2nrupgrade) migrflag="-m" ;;
    esac

    # Save current instance related information (before update/upgrade)
    ${PROGDIR?}/db2iinfo ${migrflag?} ${INSTNAME?} ${INSTHOME?} ${backupdir?}

    status=$?

    case ${status?} in
        ${TRUE?})  :    # db2iinfo completed successfully
            ;;
        ${EXIT_DIR_ERR?}|${EXIT_WRITE_ERR?})
            display_msg ${DB2CAT?} 89 \
                'DBI1089E Error in saving current instance related information in the %s directory.\n' ${backupdir?}
            stop_prog 1
            ;;
        *)
            display_msg ${DB2CAT?} 69 \
                'DBI1069E Unexpected error. Function = %s, Return code = %s.\n'  \
                backup_instinfo ${status?}
            ;;
    esac

    trax nr_backup_instinfo
    return ${status?}
}

# Setup all the primary and secondary group relationship for DAS
setup_das_groups ()
{
    trac setup_das_groups $@
    set ${setopts?}

    # Append only if DAS can, and is, already there.
    if [ -x ${DB2DIR?}/instance/daslist ]
    then
        dasName="`${DB2DIR?}/instance/daslist`"
        if [ $? -eq 0 ]; then
            for instName in `${DB2DIR?}/instance/db2ilist | egrep -v ${dasName?}`; do
                #append_secondary_group ${instName?} ${dasName?}
                append_secondary_group ${dasName?}  ${instName?}
            done
        fi
    fi

    trax setup_das_groups
}

#-----------------------------------------------------------------------
# Name       - drop_instance
# Function   - Drops a db2 instance.
# Returns    - Exits if an error is detected.
#-----------------------------------------------------------------------
drop_instance ()
{
    trac drop_instance $@
    set ${setopts?}
    rc=0
    DB2LOCAL=`echo $DB2LOCAL`

    # If the instance is not on the instance list, do not drop it
    ${DB2DIR?}/instance/db2iset -q ${INSTNAME?} 1>/dev/null 2>/dev/null
    if [ $? -ne ${TRUE?} ]; then
        display_msg ${DB2CAT?} 291 \
            'DBI1291E The instance %s was not found in the instance list.\n' \
            ${INSTNAME?}
        stop_prog 1
    fi

    # Get the instance and the instance's home directory, INSTHOME.
    get_instance ${INSTNAME?}
    chk_itype
    
    #SD Instance need SD_INSTPROF
    if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]
    then
       set_sd_instprof ${INSTNAME?}
       if [ $? -ne ${TRUE?} ]
       then
          dmsg "Unable to find SD_INSTPROF value from global reg"
          stop_prog ${FALSE?}
       fi
    fi
    
    # Define special variables
    def_specials

    # Get which version of DB2 in use by this instance
    chk_version ${INSTNAME?}
    DB2INSTVER=$?                 # DB2 version for the instance INSTNAME
    DB2IPRDDIR=${db2proddir?}     # Product dir of DB2 used by this instance

    if [ ${DB2INSTVER?} -eq ${DB2VER_UNKNOWN?} ]; then
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' \
            ${USERHOME?}/sqllib/bin
        stop_prog 1
    fi

    # Check that the specified user is a valid instance name and
    # has an sqllib/bin directory in its home directory.
    if [ ${DB2INSTVER?} != ${DB2VER_UNKNOWN?} ]; then
        if [ -d ${INSTHOME?}/sqllib/bin ]; then

            # try to stop text search
            if [ ${DEBUG?} -eq ${TRUE?} ]; then
               ${DB2DIR?}/instance/db2ickts -d -s ${INSTNAME?}
            else
               ${DB2DIR?}/instance/db2ickts -s ${INSTNAME?}
            fi
            rc=$?

            if [ ${rc?} -ne 0 ]; then
               rc=1
            fi

            db2_acs_stop_disable  ${INSTNAME?} "disable" "${DB2DIR?}" "${DB2DIR?}/instance/db2idrop"

            # Check to see if itma is installed.  If it is, stop the itma agent for the instance 
            if [ -x ${INSTHOME?}/sqllib/itma/bin/itmcmd ]; then
              
               if [ ! -f ${DB2LOCAL?}/.mount ]; then
                  
                  if [ -d ${INSTHOME?}/sqllib/log ]; then
                     db2itmalog="${INSTHOME?}/sqllib/log/${DB2ITMALOG?}" 
                     ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "date >> ${db2itmalog?}" 1>/dev/null 2>/dev/null
                     if [ ${DEBUG?} -eq ${TRUE?} ]; then
                         ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${DB2DIR?}/itma/bin/itmcmd \
                         agent -o ${INSTNAME?} stop ud 2>&1 | tee -a ${db2itmalog?}"
                     else
                     ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${DB2DIR?}/itma/bin/itmcmd \
                         agent -o ${INSTNAME?} stop ud 2>&1 | tee -a ${db2itmalog?}" 1>/dev/null 2>/dev/null
                     fi
                  else
                     ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${DB2DIR?}/itma/bin/itmcmd \
                         agent -o ${INSTNAME?} stop ud"
                  fi

               else

                 if [ -d ${INSTHOME?}/sqllib/log ]; then
                    db2itmalog="${INSTHOME?}/sqllib/log/${DB2ITMALOG?}"
                    date >> ${db2itmalog?} 1>/dev/null 2>/dev/null
                    if [ ${DEBUG?} -eq ${TRUE?} ]; then
                       ${DB2DIR?}/itma/bin/itmcmd agent -o ${INSTNAME?} stop ud 2>&1 | tee -a ${db2itmalog?}
                    else
                      ${DB2DIR?}/itma/bin/itmcmd agent -o ${INSTNAME?} stop ud 2>&1 | tee -a ${db2itmalog?} 1>/dev/null 2>/dev/null
                     fi
                 else
                     ${DB2DIR?}/itma/bin/itmcmd agent -o ${INSTNAME?} stop ud 2>&1 | tee -a ${db2itmalog?} 1>/dev/null 2>/dev/null
                 fi
               
               fi

            fi

            # Update itma cfg file for the instance
            itma_updatecfg r ${INSTNAME?} ${DB2DIR?}

            #run db2 terminate before removing instance
            if [ ! -f ${DB2LOCAL?}/.mount ]; then
               ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2 terminate" 1>/dev/null 2>/dev/null
            else
               ${INSTHOME?}/sqllib/bin/db2 terminate 1>/dev/null 2>/dev/null
            fi

            # Clean up HA resources
            if [ -f  ${INSTHOME?}/sqllib/bin/db2haicu ]; then
                if [ -f  ${INSTHOME?}/sqllib/cfg/db2ha.sys ]; then
                   if [ ! -f ${DB2LOCAL?}/.mount ]; then
                      ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2haicu -delete" 1>/dev/null 2>/dev/null
                   else
                      ${INSTHOME?}/sqllib/bin/db2haicu -delete 1>/dev/null 2>/dev/null
                   fi
                fi
            fi 
            
            # run db2licd -xxx if it exists
            if [ -f ${INSTHOME?}/sqllib/adm/db2licd ]; then
                if [ ! -f ${DB2LOCAL?}/.mount ]; then
                   ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/adm/db2licd -xxx"
                else
                  ${INSTHOME?}/sqllib/adm/db2licd -xxx
                fi
            fi

            # If exists, remove the instance name from the instance list
            ${DB2DIR?}/instance/db2iset -q ${INSTNAME?} 1>/dev/null 2>/dev/null
            if [ $? -eq 0 ]; then
                rm_instlist ${INSTNAME?} ${DB2VER?}
                if [ $? -ne ${TRUE?} ]; then
                    stop_prog 1
                fi
            else
                display_msg ${DB2CAT?} 291 \
                    'DBI1291E The instance %s was not found in the instance list.\n' \
                    ${INSTNAME?}
            fi

            # call db2rmicons to remove existing DB2 desktop entries for the instance
            if [ -f ${INSTHOME?}/sqllib/bin/db2rmicons ]; then
                   if [ ! -f ${DB2LOCAL?}/.mount ]; then
                      ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2rmicons" 1>/dev/null 2>/dev/null
                   else
                     ${INSTHOME?}/sqllib/bin/db2rmicons 1>/dev/null 2>/dev/null
                   fi
            fi
            
            # Remove the sqllib directory.
            rm -rf ${INSTHOME?}/sqllib
            if [ $? -ne 0 ]; then
                display_msg ${DB2CAT?} 83 \
                    'DBI1083E An attempt to remove %s failed.\n' \
                    ${INSTHOME?}/sqllib
                stop_prog 1
            fi
        else
            display_msg ${DB2CAT?} 95 \
                'DBI1095W File or directory %s not found.\n' \
                ${INSTHOME?}/sqllib/bin
        fi
    fi

    setup_dsf    

    # End of function instance_drop
    trax drop_instance
    return ${rc?}
}
#unlink the linked file and re-link back them to the new mounted path.

updt_local_install()
{
   trac updt_local_install $@
   set ${setopts?}

   find_homedir $1
   INSTHOME=${USERHOME?}

   MOUNTPATH=$2
   
   file_list=""

   file_list=${file_list?}" db2cli.ini.sample db2dsdriver.cfg.sample db2dsdriver.xsd db2ese.lvl "
   file_list=${file_list?}" db2ln db2rfe.cfg.sample db2rmln db2sysmp db2sysrq db2syssr  "
   file_list=${file_list?}" db2syssv db2trc_themes DJUpdateIniInput.dtd DJUpdateIniOutput.dtd "
   file_list=${file_list?}" drda.xml IBMLDAPSecurity.ini.sample installcopy.cfg "
   file_list=${file_list?}" ITLMready.properties mq wrapper_discovery.dtd wrapper.dtd "
   file_list=${file_list?}" WSWrapperKeystore.kdb ws.xml "

   for file_name in ${file_list?}; do
       unlink ${INSTHOME?}/sqllib/cfg/${file_name?}
   done 

   # unlink the linked files from the mounted path.
   unlink ${INSTHOME?}/sqllib/adm 
   unlink ${INSTHOME?}/sqllib/adsm 
   unlink ${INSTHOME?}/sqllib/instance 
   unlink ${INSTHOME?}/sqllib/msg
   unlink ${INSTHOME?}/sqllib/Readme 
   unlink ${INSTHOME?}/sqllib/desktop 
   unlink ${INSTHOME?}/sqllib/dsdriver 
   unlink ${INSTHOME?}/sqllib/json 
   unlink ${INSTHOME?}/sqllib/lib32 
   unlink ${INSTHOME?}/sqllib/lib64
   unlink ${INSTHOME?}/sqllib/license 
   unlink ${INSTHOME?}/sqllib/rdf 
   unlink ${INSTHOME?}/sqllib/java 
   unlink ${INSTHOME?}/sqllib/doc 
   unlink ${INSTHOME?}/sqllib/infopop 
   unlink ${INSTHOME?}/sqllib/tools 
   unlink ${INSTHOME?}/sqllib/gskit 
   unlink ${INSTHOME?}/sqllib/bin 
   unlink ${INSTHOME?}/sqllib/ha 
   unlink ${INSTHOME?}/sqllib/install 
   unlink ${INSTHOME?}/sqllib/include 
   unlink ${INSTHOME?}/sqllib/misc 
   unlink ${INSTHOME?}/sqllib/pd 
   unlink ${INSTHOME?}/sqllib/samples
   unlink ${INSTHOME?}/sqllib/map 
   unlink ${INSTHOME?}/sqllib/gse 
   unlink ${INSTHOME?}/sqllib/acs 
   unlink ${INSTHOME?}/sqllib/properties  
   unlink ${INSTHOME?}/sqllib/tivready    
   unlink ${INSTHOME?}/sqllib/db2tss/lib
   unlink ${INSTHOME?}/sqllib/db2tss/ddl
   unlink ${INSTHOME?}/sqllib/db2tss/resource
   unlink ${INSTHOME?}/sqllib/lua

   # re-create the links with new mounted path
  
   for file_name in ${file_list?}; do
       mklink ${INSTHOME?}/sqllib/cfg/${file_name?} ${MOUNTPATH?}/cfg/${file_name?}
   done
   
   cp -rf ${MOUNTPATH?}/db2tss/bin ${INSTHOME?}/sqllib/db2tss/bin
   mkpermission -R "u=rwx,g=r,o=r" ${INSTHOME?}/sqllib/db2tss/bin
   
   unlink ${INSTHOME?}/sqllib/db2tss/bin/configTool
   unlink ${INSTHOME?}/sqllib/db2tss/bin/adminTool
   unlink ${INSTHOME?}/sqllib/db2tss/bin/logformatter
   unlink ${INSTHOME?}/sqllib/db2tss/bin/richtextTool
   unlink ${INSTHOME?}/sqllib/db2tss/bin/synonymTool

   mklink ${INSTHOME?}/sqllib/db2tss/bin/configTool ${INSTHOME?}/sqllib/db2tss/bin/configTool.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/adminTool  ${INSTHOME?}/sqllib/db2tss/bin/adminTool.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/logformatter ${INSTHOME?}/sqllib/db2tss/bin/logformatter.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/richtextTool ${INSTHOME?}/sqllib/db2tss/bin/richtextTool.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/synonymTool ${INSTHOME?}/sqllib/db2tss/bin/synonymTool.sh
   
   mklink ${INSTHOME?}/sqllib/db2tss/bin ${MOUNTPATH?}/db2tss/bin
   mklink ${INSTHOME?}/sqllib/db2tss/lib ${MOUNTPATH?}/db2tss/lib
   mklink ${INSTHOME?}/sqllib/db2tss/ddl ${MOUNTPATH?}/db2tss/ddl
   mklink ${INSTHOME?}/sqllib/db2tss/resource ${MOUNTPATH?}/db2tss/resource
   mklink ${INSTHOME?}/sqllib/adm ${MOUNTPATH?}/adm
   mklink ${INSTHOME?}/sqllib/adsm ${MOUNTPATH?}/adsm
   mklink ${INSTHOME?}/sqllib/instance ${MOUNTPATH?}/instance
   mklink ${INSTHOME?}/sqllib/msg ${MOUNTPATH?}/msg
   mklink ${INSTHOME?}/sqllib/Readme ${MOUNTPATH?}/Readme
   mklink ${INSTHOME?}/sqllib/desktop ${MOUNTPATH?}/desktop
   mklink ${INSTHOME?}/sqllib/dsdriver ${MOUNTPATH?}/dsdriver
   mklink ${INSTHOME?}/sqllib/json ${MOUNTPATH?}/json
   mklink ${INSTHOME?}/sqllib/lib32 ${MOUNTPATH?}/lib32
   mklink ${INSTHOME?}/sqllib/lib64 ${MOUNTPATH?}/lib64
   mklink ${INSTHOME?}/sqllib/license ${MOUNTPATH?}/license
   mklink ${INSTHOME?}/sqllib/rdf ${MOUNTPATH?}/rdf
   mklink ${INSTHOME?}/sqllib/java ${MOUNTPATH?}/java
   mklink ${INSTHOME?}/sqllib/doc ${MOUNTPATH?}/doc
   mklink ${INSTHOME?}/sqllib/infopop ${MOUNTPATH?}/infopop
   mklink ${INSTHOME?}/sqllib/tools ${MOUNTPATH?}/tools
   mklink ${INSTHOME?}/sqllib/gskit ${MOUNTPATH?}/gskit
   mklink ${INSTHOME?}/sqllib/bin ${MOUNTPATH?}/bin
   mklink ${INSTHOME?}/sqllib/ha ${MOUNTPATH?}/ha
   mklink ${INSTHOME?}/sqllib/install ${MOUNTPATH?}/install
   mklink ${INSTHOME?}/sqllib/include ${MOUNTPATH?}/include
   mklink ${INSTHOME?}/sqllib/misc ${MOUNTPATH?}/misc
   mklink ${INSTHOME?}/sqllib/pd ${MOUNTPATH?}/pd
   mklink ${INSTHOME?}/sqllib/samples ${MOUNTPATH?}/samples
   mklink ${INSTHOME?}/sqllib/map ${MOUNTPATH?}/map
   mklink ${INSTHOME?}/sqllib/gse ${MOUNTPATH?}/gse
   mklink ${INSTHOME?}/sqllib/acs ${MOUNTPATH?}/acs
   mklink ${INSTHOME?}/sqllib/properties  ${MOUNTPATH?}/properties
   mklink ${INSTHOME?}/sqllib/tivready    ${MOUNTPATH?}/tivready
   mklink ${INSTHOME?}/sqllib/lua ${MOUNTPATH?}/lua

   if [ -f ${INSTHOME?}/sqllib/.mount ]; then
      rm -rf ${INSTHOME?}/sqllib/.mount
   fi

   touch ${INSTHOME?}/sqllib/.mount
   mkpermission "u=rwx,g=rx,o=rx" ${INSTHOME?}/sqllib/.mount
   echo "${MOUNTPOINT?}" >> ${INSTHOME?}/sqllib/.mount
   
   trax updt_local_install

}

crt_local_install ()
{
   trac crt_local_install $@
   set ${setopts?}
  
   find_homedir $1
   INSTHOME=${USERHOME?}
   
   MOUNTPATH=$2

   if [ ! -d ${INSTHOME?}/sqllib ]
   then 
      mkdirectory ${INSTHOME?}/sqllib
      mkpermission -R "u=rwx,g=rx,o=rx" ${INSTHOME?}/sqllib
   #else
   #   display_msg ${DB2CAT?} 82 \
   #   'DBI1082E The file or directory %s already exists.' ${INSTHOME?}/sqllib
   #   return ${FALSE?}
   fi

   mkpermission -R "u=rwx,g=rx,o=rx" ${INSTHOME?}/sqllib

   mkdirectory ${INSTHOME?}/sqllib/cfg
   mkpermission -R "u=rwx,g=rx,o=rx" ${INSTHOME?}/sqllib/cfg

   mkdirectory ${INSTHOME?}/sqllib/db2tss
   mkpermission -R "u=rwx,g=rx,o=rx" ${INSTHOME?}/sqllib/db2tss
   file_list=""

   file_list=${file_list?}" db2cli.ini.sample db2dsdriver.cfg.sample db2dsdriver.xsd db2ese.lvl "
   file_list=${file_list?}" db2ln db2rfe.cfg.sample db2rmln db2sysmp db2sysrq db2syssr  "
   file_list=${file_list?}" db2syssv db2trc_themes DJUpdateIniInput.dtd DJUpdateIniOutput.dtd "
   file_list=${file_list?}" drda.xml IBMLDAPSecurity.ini.sample installcopy.cfg "
   file_list=${file_list?}" ITLMready.properties mq wrapper_discovery.dtd wrapper.dtd "
   file_list=${file_list?}" WSWrapperKeystore.kdb ws.xml "

   for file_name in ${file_list?}; do
       mklink ${INSTHOME?}/sqllib/cfg/${file_name?} ${MOUNTPATH?}/cfg/${file_name?}
   done  
 
   cp -rf ${MOUNTPATH?}/cfg/bldlevel ${INSTHOME?}/sqllib/cfg/
   cp -rf ${MOUNTPATH?}/cfg/db2cshrc ${INSTHOME?}/sqllib/cfg/
   cp -rf ${MOUNTPATH?}/cfg/db2fodc.profile ${INSTHOME?}/sqllib/cfg/
   cp -rf ${MOUNTPATH?}/cfg/db2profile ${INSTHOME?}/sqllib/cfg/
   cp -rf ${MOUNTPATH?}/cfg/DefHealthRules.reg ${INSTHOME?}/sqllib/cfg/
   cp -rf ${MOUNTPATH?}/cfg/HealthRulesV82.reg ${INSTHOME?}/sqllib/cfg/
   cp -rf ${MOUNTPATH?}/cfg/DigiCertGlobalRootCA.arm ${INSTHOME?}/sqllib/cfg/

   cp -rf ${MOUNTPATH?}/conv ${INSTHOME?}/sqllib/
   cp -rf ${MOUNTPATH?}/function ${INSTHOME?}/sqllib/ 
   cp -rf ${MOUNTPATH?}/bnd ${INSTHOME?}/sqllib/
   #cp -rf ${MOUNTPATH?}/db2tss ${INSTHOME?}/sqllib/
   cp -rf ${MOUNTPATH?}/security32 ${INSTHOME?}/sqllib/
   cp -rf ${MOUNTPATH?}/security64 ${INSTHOME?}/sqllib/

   cp -rf ${MOUNTPATH?}/cfg/db2tss/config ${INSTHOME?}/sqllib/db2tss/config
   mkpermission -R "u=rwx,g=r,o=r" ${INSTHOME?}/sqllib/db2tss/config

   cp -rf ${MOUNTPATH?}/db2tss/bin ${INSTHOME?}/sqllib/db2tss/bin
   mkpermission -R "u=rwx,g=r,o=r" ${INSTHOME?}/sqllib/db2tss/bin
   unlink ${INSTHOME?}/sqllib/db2tss/bin/configTool
   unlink ${INSTHOME?}/sqllib/db2tss/bin/adminTool
   unlink ${INSTHOME?}/sqllib/db2tss/bin/logformatter 
   unlink ${INSTHOME?}/sqllib/db2tss/bin/richtextTool
   unlink ${INSTHOME?}/sqllib/db2tss/bin/synonymTool

   mklink ${INSTHOME?}/sqllib/db2tss/lib ${MOUNTPATH?}/db2tss/lib
   mklink ${INSTHOME?}/sqllib/db2tss/ddl ${MOUNTPATH?}/db2tss/ddl
   mklink ${INSTHOME?}/sqllib/db2tss/resource ${MOUNTPATH?}/db2tss/resource
   
   mklink ${INSTHOME?}/sqllib/db2tss/bin/configTool ${INSTHOME?}/sqllib/db2tss/bin/configTool.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/adminTool  ${INSTHOME?}/sqllib/db2tss/bin/adminTool.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/logformatter ${INSTHOME?}/sqllib/db2tss/bin/logformatter.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/richtextTool ${INSTHOME?}/sqllib/db2tss/bin/richtextTool.sh
   mklink ${INSTHOME?}/sqllib/db2tss/bin/synonymTool ${INSTHOME?}/sqllib/db2tss/bin/synonymTool.sh

   mklink ${INSTHOME?}/sqllib/adm ${MOUNTPATH?}/adm
   mklink ${INSTHOME?}/sqllib/adsm ${MOUNTPATH?}/adsm
   mklink ${INSTHOME?}/sqllib/instance ${MOUNTPATH?}/instance
   mklink ${INSTHOME?}/sqllib/msg ${MOUNTPATH?}/msg
   mklink ${INSTHOME?}/sqllib/Readme ${MOUNTPATH?}/Readme
   mklink ${INSTHOME?}/sqllib/desktop ${MOUNTPATH?}/desktop
   mklink ${INSTHOME?}/sqllib/dsdriver ${MOUNTPATH?}/dsdriver
   mklink ${INSTHOME?}/sqllib/json ${MOUNTPATH?}/json
   mklink ${INSTHOME?}/sqllib/lib32 ${MOUNTPATH?}/lib32
   mklink ${INSTHOME?}/sqllib/lib64 ${MOUNTPATH?}/lib64
   mklink ${INSTHOME?}/sqllib/license ${MOUNTPATH?}/license
   mklink ${INSTHOME?}/sqllib/rdf ${MOUNTPATH?}/rdf
   mklink ${INSTHOME?}/sqllib/java ${MOUNTPATH?}/java
   mklink ${INSTHOME?}/sqllib/doc ${MOUNTPATH?}/doc
   mklink ${INSTHOME?}/sqllib/infopop ${MOUNTPATH?}/infopop
   mklink ${INSTHOME?}/sqllib/tools ${MOUNTPATH?}/tools
   mklink ${INSTHOME?}/sqllib/gskit ${MOUNTPATH?}/gskit
   mklink ${INSTHOME?}/sqllib/bin ${MOUNTPATH?}/bin
   mklink ${INSTHOME?}/sqllib/ha ${MOUNTPATH?}/ha
   mklink ${INSTHOME?}/sqllib/install ${MOUNTPATH?}/install
   mklink ${INSTHOME?}/sqllib/include ${MOUNTPATH?}/include
   mklink ${INSTHOME?}/sqllib/misc ${MOUNTPATH?}/misc
   mklink ${INSTHOME?}/sqllib/pd ${MOUNTPATH?}/pd
   mklink ${INSTHOME?}/sqllib/samples ${MOUNTPATH?}/samples
   mklink ${INSTHOME?}/sqllib/map ${MOUNTPATH?}/map
   mklink ${INSTHOME?}/sqllib/gse ${MOUNTPATH?}/gse
   mklink ${INSTHOME?}/sqllib/acs ${MOUNTPATH?}/acs
   mklink ${INSTHOME?}/sqllib/properties  ${MOUNTPATH?}/properties
   mklink ${INSTHOME?}/sqllib/tivready    ${MOUNTPATH?}/tivready
   mklink ${INSTHOME?}/sqllib/lua ${MOUNTPATH?}/lua

  trax crt_local_install

}

# Create the sqllib dir for the instance
create_sqllib ()
{
    trac create_sqllib $@
    set ${setopts?}

    # Make the sqllib directory for instance, set perms, ownership
    if [ ! -d ${INSTHOME?}/sqllib ]
    then
        mkdirectory ${INSTHOME?}/sqllib
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib

    if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]
    then
        if [ ! -d ${SD_INSTPROF?}/${INSTNAME?} ]
        then
            mkdirectory ${SD_INSTPROF?}/${INSTNAME?}
        fi
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${SD_INSTPROF?}/${INSTNAME?}
        mkpermission "u=rwx,g=rwxs,o=rx" ${SD_INSTPROF?}/${INSTNAME?}

        if [ ! -d ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared ]
        then
            mkdirectory ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared
        fi
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared
        mkpermission "u=rwx,g=rwxs,o=rx,+t" ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared
        
        if [ ! -d ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/ctrl ]
        then
            mkdirectory ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/ctrl
        fi
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/ctrl
        mkpermission "u=rwx,g=rwxs,o=rx,+t" ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/ctrl
    fi
    # Create a function directory for stored proceedures and user defined
    # functions, a tmp directory for inport/export, a db2dump directory
    # for error logging and a cfg directory for configuration files.
    # For SD instances only, create a directory db2altdump which will be
    # the default ALT_DIAGPATH (DBM cfg parameter) for the instance.
    # Create links from the ${DB2DIR?}/function/libdb2u.a library to the
    # $INSTHOME/sqllib/function directory.
    # These links and directories are created regardless of the nodetype
    # to minimize the need to update instances when products options are
    # installed or deinstalled after an instance is created.
    # The permissions on the function, tmp and db2dump directories are set
    # so that members of the sysadm group can write to these directories.

    if [ ! -d ${INSTHOME?}/sqllib/db2dump ]
    then
        mkdirectory ${INSTHOME?}/sqllib/db2dump
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2dump
    mkpermission "u=rwx,g=rwxs,o=rwx,+t" ${INSTHOME?}/sqllib/db2dump

    if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]; then                           #d880954swp
       if [ ! -d ${INSTHOME?}/sqllib/db2altdump ]; then     
          mkdirectory ${INSTHOME?}/sqllib/db2altdump
       fi
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2altdump
       mkpermission "u=rwx,g=rwxs,o=rwx,+t" ${INSTHOME?}/sqllib/db2altdump
    fi

    if [ ! -d ${INSTHOME?}/sqllib/tmp ]
    then
        mkdirectory ${INSTHOME?}/sqllib/tmp
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/tmp
    mkpermission "u=rwx,g=rwxs,o=rwx" ${INSTHOME?}/sqllib/tmp

    if [ ! -d ${INSTHOME?}/sqllib/ctrlha ]
    then
        mkdirectory ${INSTHOME?}/sqllib/ctrlha
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/ctrlha
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/ctrlha
    
    if [ ! -d ${INSTHOME?}/sqllib/ctrl ]
    then
        mkdirectory ${INSTHOME?}/sqllib/ctrl
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/ctrl
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/ctrl
    
    if [ ! -d ${INSTHOME?}/sqllib/log ]
    then
        mkdirectory ${INSTHOME?}/sqllib/log
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/log
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/log

    if [ ! -d ${INSTHOME?}/sqllib/cfg ]
    then
        mkdirectory ${INSTHOME?}/sqllib/cfg
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg
    mkpermission "u=rwx,g=rwxs,o=rx,+t"    ${INSTHOME?}/sqllib/cfg

    if [ ! -d ${INSTHOME?}/sqllib/cfgcache ]
    then
        mkdirectory ${INSTHOME?}/sqllib/cfgcache
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfgcache
    mkpermission "u=rwx,g=rwxs,o=rx,+t"    ${INSTHOME?}/sqllib/cfgcache

    # Create conlic.bin
    if [ ! -f ${INSTHOME?}/sqllib/cfgcache/conlic.bin ]
    then
        touch ${INSTHOME?}/sqllib/cfgcache/conlic.bin
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfgcache/conlic.bin
    mkpermission "ugo=rw" ${INSTHOME?}/sqllib/cfgcache/conlic.bin

    if [ ! -f ${INSTHOME?}/sqllib/cfg/db2fodc.profile ]
    then
        copyfile ${DB2DIR?}/cfg ${INSTHOME?}/sqllib/cfg db2fodc.profile
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/db2fodc.profile
    mkpermission "ug=rw,o=r" ${INSTHOME?}/sqllib/cfg/db2fodc.profile

    # Setup IBMLDAPSecurity.ini.sample
    if [ ! -f ${INSTHOME?}/sqllib/cfg/IBMLDAPSecurity.ini.sample -a -f ${DB2DIR?}/cfg/IBMLDAPSecurity.ini.sample ]
    then
        copyfile ${DB2DIR?}/cfg ${INSTHOME?}/sqllib/cfg IBMLDAPSecurity.ini.sample
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/IBMLDAPSecurity.ini.sample
        mkpermission "ug=rw,o=r" ${INSTHOME?}/sqllib/cfg/IBMLDAPSecurity.ini.sample
    fi

    if [ ! -d ${INSTHOME?}/sqllib/.netls ]
    then
        mkdirectory ${INSTHOME?}/sqllib/.netls
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/.netls
    mkpermission "ug=rwx,o=rx" ${INSTHOME?}/sqllib/.netls
    
    # Create the $INSTHOME/sqllib/adm directory
    if [ ! -d ${INSTHOME?}/sqllib/adm ]
    then
        mkdirectory ${INSTHOME?}/sqllib/adm
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/adm
    mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/adm

    # Create the $INSTHOME/sqllib/acs directory
    if [ -d ${DB2DIR}/acs -a ! -d ${INSTHOME?}/sqllib/acs ]
    then
        mkdirectory ${INSTHOME?}/sqllib/acs
    fi
    if [ -d ${INSTHOME?}/sqllib/acs ]
    then
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/acs
       mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/acs
    fi

    # Create the $INSTHOME/sqllib/backup directory
    if [ ! -d ${SQLLIBBACKUP?} ]
    then
        mkdirectory ${SQLLIBBACKUP?}
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${SQLLIBBACKUP?}
    mkpermission "u=rwx,g=rx,o=" ${SQLLIBBACKUP?}

    # Create the $INSTHOME/sqllib/security, and/or security32, security64
    if [ ! -d ${INSTHOME?}/sqllib/security ]
    then
        mkdirectory ${INSTHOME?}/sqllib/security
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/security
    mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/security

    for name in security32 security64
    do
       if [ -d ${DB2DIR?}/${name?} ]; then
           if [ ! -d ${INSTHOME?}/sqllib/${name?} ]
           then
               mkdirectory ${INSTHOME?}/sqllib/${name?}
           fi
           chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/${name?}
           mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/${name?}
       fi
    done

    if [ ! -d ${INSTHOME?}/sqllib/uif ]
    then
        mkdirectory ${INSTHOME?}/sqllib/uif
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/uif
    mkpermission "ugo=rwx" ${INSTHOME?}/sqllib/uif

    # Create symbolic links to all the rest of the subdirectories of ${DB2DIR?}
    create_sqllib_link

    trax create_sqllib
}

# Create the sqllib_v10NN dir for the instance
create_sqllib_online ()
{
    trac create_sqllib_online $@
    set ${setopts?}
     
    SQLLIB_DIR_NAME=sqllib_v${DB2VER?}
    # Make the sqllib directory for instance, set perms, ownership
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?} ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}

    # Create a function directory for stored proceedures and user defined
    # functions, a tmp directory for inport/export, a db2dump directory
    # for error logging and a cfg directory for configuration files.
    # For SD instances only, create a directory db2altdump which will be
    # the default ALT_DIAGPATH (DBM cfg parameter) for the instance.
    # Create links from the ${DB2DIR?}/function/libdb2u.a library to the
    # $INSTHOME/sqllib/function directory.
    # These links and directories are created regardless of the nodetype
    # to minimize the need to update instances when products options are
    # installed or deinstalled after an instance is created.
    # The permissions on the function, tmp and db2dump directories are set
    # so that members of the sysadm group can write to these directories.

    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2dump ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2dump
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2dump
    mkpermission "u=rwx,g=rwxs,o=rwx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2dump

    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/tmp ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/tmp
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/tmp
    mkpermission "u=rwx,g=rwxs,o=rwx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/tmp

    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrlha ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrlha
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrlha
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrlha
    
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrl ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrl
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrl
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/ctrl
    
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/log ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/log
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/log
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/log

    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg
    mkpermission "u=rwx,g=rwxs,o=rx,+t"    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg

    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache
    mkpermission "u=rwx,g=rwxs,o=rx,+t"    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache

    # Create conlic.bin
    if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache/conlic.bin ]
    then
        touch ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache/conlic.bin
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache/conlic.bin
    mkpermission "ugo=rw" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfgcache/conlic.bin

    if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/db2fodc.profile ]
    then
        copyfile ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg db2fodc.profile
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/db2fodc.profile
    mkpermission "ug=rw,o=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/db2fodc.profile

    # Setup IBMLDAPSecurity.ini.sample
    if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/IBMLDAPSecurity.ini.sample -a -f ${DB2DIR?}/cfg/IBMLDAPSecurity.ini.sample ]
    then
        copyfile ${DB2DIR?}/cfg ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg IBMLDAPSecurity.ini.sample
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/IBMLDAPSecurity.ini.sample
        mkpermission "ug=rw,o=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/cfg/IBMLDAPSecurity.ini.sample
    fi

    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.netls ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.netls
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.netls
    mkpermission "ug=rwx,o=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.netls
    
    # Create the $INSTHOME/sqllib_v10NN/adm directory
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm
    mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm

    # Create the $INSTHOME/sqllib_vNN/acs directory
    if [ -d ${DB2DIR}/acs -a ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs
    fi
    if [ -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs ]
    then
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs
       mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/acs
    fi

    # Create the $INSTHOME/sqllib/backup directory
    # Dir sqllib/backup
    SQLLIBBACKUP_ONLINE="${INSTHOME?}/${SQLLIB_DIR_NAME?}/${BAKDIRNAME?}"
    if [ ! -d ${SQLLIBBACKUP_ONLINE?} ]
    then
        mkdirectory ${SQLLIBBACKUP_ONLINE?}
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${SQLLIBBACKUP_ONLINE?}
    mkpermission "u=rwx,g=rx,o=" ${SQLLIBBACKUP_ONLINE?}

    # Create the $INSTHOME/sqllib/security, and/or security32, security64
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security
    mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/security

    for name in security32 security64
    do
       if [ -d ${DB2DIR?}/${name?} ]; then
           if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${name?} ]
           then
               mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${name?}
           fi
           chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${name?}
           mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${name?}
       fi
    done

    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/uif ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/uif
    fi
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/uif
    mkpermission "ugo=rwx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/uif

    # Create symbolic links to all the rest of the subdirectories of ${DB2DIR?}
    create_sqllib_link_online

    trax create_sqllib_online
}
# Create the sqllib dir for the instance
nr_create_sqllib ()
{
    trac nr_create_sqllib $@
    set ${setopts?}

    # Create a function directory for stored proceedures and user defined
    # functions, a tmp directory for inport/export, a db2dump directory
    # for error logging and a cfg directory for configuration files.
    # For SD instances only, create a directory db2altdump which will be 
    # the default ALT_DIAGPATH (DBM cfg parameter) for the instance.
    # Create links from the ${DB2DIR?}/function/libdb2u.a library to the
    # $INSTHOME/sqllib/function directory.
    # These links and directories are created regardless of the nodetype
    # to minimize the need to update instances when products options are
    # installed or deinstalled after an instance is created.
    # The permissions on the function, tmp and db2dump directories are set
    # so that members of the sysadm group can write to these directories.
    
    DB2LOCAL=`echo $DB2LOCAL`
    if [ ! -f ${DB2LOCAL?}/.mount ]; then
       if [ -f ${INSTHOME?}/sqllib/instance/db2icrt ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2icrt
       fi
       if [ -f ${INSTHOME?}/sqllib/instance/db2iexec ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2iexec
       fi
       if [ -f ${INSTHOME?}/sqllib/instance/db2idrop ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2idrop
       fi
       if [ -f ${INSTHOME?}/sqllib/instance/db2idrop_local ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2idrop_local
       fi
       if [ -f ${INSTHOME?}/sqllib/instance/db2iupdt ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2iupdt
       fi
       if [ -f ${INSTHOME?}/sqllib/instance/db2iupgrade ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2iupgrade
       fi
       if [ -f ${INSTHOME?}/sqllib/instance/db2iset ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2iset
       fi
       if [ -f ${INSTHOME?}/sqllib/instance/db2ipcld ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/instance/db2ipcld
       fi
       if [ -f ${INSTHOME?}/sqllib/install/db2_deinstall ]; then
          mkpermission "u=rx,g=rx,o=rx" ${INSTHOME?}/sqllib/install/db2_deinstall
       fi

    fi

    if [ ! -d ${INSTHOME?}/sqllib/db2dump ]
    then
        mkdirectory ${INSTHOME?}/sqllib/db2dump
    fi
    mkpermission "u=rwx,g=rwxs,o=rwx,+t" ${INSTHOME?}/sqllib/db2dump

    if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]; then                           #d880954swp
       if [ ! -d ${INSTHOME?}/sqllib/db2altdump ]; then
          mkdirectory ${INSTHOME?}/sqllib/db2altdump
       fi
       chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2altdump
       mkpermission "u=rwx,g=rwxs,o=rwx,+t" ${INSTHOME?}/sqllib/db2altdump
    fi

    if [ ! -d ${INSTHOME?}/sqllib/tmp ]
    then
        mkdirectory ${INSTHOME?}/sqllib/tmp
    fi
    mkpermission "u=rwx,g=rwxs,o=rwx" ${INSTHOME?}/sqllib/tmp

    if [ ! -d ${INSTHOME?}/sqllib/ctrl ]
    then
        mkdirectory ${INSTHOME?}/sqllib/ctrl
    fi
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/ctrl

    if [ ! -d ${INSTHOME?}/sqllib/log ]
    then
        mkdirectory ${INSTHOME?}/sqllib/log
    fi
    mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/log

    if [ ! -d ${INSTHOME?}/sqllib/cfg ]
    then
        mkdirectory ${INSTHOME?}/sqllib/cfg
    fi
    mkpermission "u=rwx,g=rwxs,o=rx,+t"    ${INSTHOME?}/sqllib/cfg

    if [ ! -d ${INSTHOME?}/sqllib/cfgcache ]
    then
        mkdirectory ${INSTHOME?}/sqllib/cfgcache
    fi
    mkpermission "u=rwx,g=rwxs,o=rx,+t"    ${INSTHOME?}/sqllib/cfgcache
 
    # Create conlic.bin
    if [ ! -f ${INSTHOME?}/sqllib/cfgcache/conlic.bin ]
    then
        touch ${INSTHOME?}/sqllib/cfgcache/conlic.bin
    fi
    mkpermission "ugo=rw" ${INSTHOME?}/sqllib/cfgcache/conlic.bin

    if [ ! -d ${INSTHOME?}/sqllib/.netls ]
    then
        mkdirectory ${INSTHOME?}/sqllib/.netls
    fi
    mkpermission "ug=rwx,o=rx" ${INSTHOME?}/sqllib/.netls
    
    # Create the $INSTHOME/sqllib/adm directory
    if [ ! -d ${INSTHOME?}/sqllib/adm ]
    then
        mkdirectory ${INSTHOME?}/sqllib/adm
    fi

    DB2LOCAL=`echo $DB2LOCAL`
    if [ ! -f ${DB2LOCAL?}/.mount ]; then
       mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/adm
    fi

    # Create the $INSTHOME/sqllib/backup directory
    if [ ! -d ${SQLLIBBACKUP?} ]
    then
        mkdirectory ${SQLLIBBACKUP?}
    fi
    mkpermission "u=rwx,g=rx,o=" ${SQLLIBBACKUP?}

    # Create the $INSTHOME/sqllib/security, and/or security32, security64
    if [ ! -d ${INSTHOME?}/sqllib/security ]
    then
        mkdirectory ${INSTHOME?}/sqllib/security
    fi
    mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/security

    for name in security32 security64
    do
       if [ -d ${DB2DIR?}/${name?} ]; then
           if [ ! -d ${INSTHOME?}/sqllib/${name?} ]
           then
               mkdirectory ${INSTHOME?}/sqllib/${name?}
           fi
           mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/${name?}
       fi
    done

    if [ ! -d ${INSTHOME?}/sqllib/uif ]
    then
        mkdirectory ${INSTHOME?}/sqllib/uif
    fi
    mkpermission "ugo=rwx" ${INSTHOME?}/sqllib/uif

    nr_create_sqllib_link

    trax nr_create_sqllib
}

# Cleanup function dir after update from 32 to 64 bit
cleanup_function_dir ()
{

    trac cleanup_function_dir $@
    set ${setopts?}

    if [ -d ${DB2DIR?}/function ]; then
        for dir in dasfcn function
        do
            fileList=`ls -1 ${INSTHOME?}/sqllib/${dir?} 2> /dev/null`
            for file in ${fileList?}; do
                ls -1 -l ${INSTHOME?}/sqllib/${dir?}/${file?} | grep ${DB2DIR?} 1> /dev/null 2> /dev/null
                if [ $? -eq 0 -a ${file?} != "unfenced" -a ${file?} != "db2rdf" ]; then
                    rm -rf ${INSTHOME?}/sqllib/${dir?}/${file?}
                fi
            done
        done
    fi

    trax cleanup_function_dir
}

#Clean up links in dir $1 pointing to dir $2
cleanup_old_links ()
{
    trac cleanup_old_links $@
    set ${setopts?}

    dir_to_clean=$1
    dir_pointed=$2

    if [ -d ${dir_to_clean?} -a "X${dir_pointed?}" != "X" ]; then
        fileList=`ls -1 ${dir_to_clean?} 2> /dev/null`
        for file in ${fileList?}; do
            if [ -f ${dir_to_clean?}/${file?} ]; then
                echo ${dir_pointed?} | grep '\/$' 1> /dev/null 2> /dev/null
                if [ $? -ne 0 ]; then
                   tmp_dir_pointed="${dir_pointed?}/"
                else
                   tmp_dir_pointed="${dir_pointed?}"
                fi
                ls -1 -l ${dir_to_clean?}/${file?} | grep ${tmp_dir_pointed?} 1> /dev/null 2> /dev/null
                if [ $? -eq 0 ]; then
                   rm -f ${dir_to_clean?}/${file?}
                fi
                unset tmp_dir_pointed
            elif [ -d ${dir_to_clean?}/${file?} -a \
                   ${dir_to_clean?}/${file?} != "${dir_to_clean?}/." -a \
                   ${dir_to_clean?}/${file?} != "${dir_to_clean?}/.." ]; then
                cleanup_old_links ${dir_to_clean?}/${file?} ${dir_pointed?}
            fi
        done
    fi

    trax cleanup_old_links
}

# create links, etc., for spb directory
create_spb_dir ()
{
    trac create_spb_dir
    set ${setopts?}

    # create real directory.
    if [ ! -d ${INSTHOME?}/sqllib/spb ]
    then
        mkdirectory ${INSTHOME?}/sqllib/spb
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/spb
        mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/spb
    fi

    # create projects directory.
    if [ ! -d ${INSTHOME?}/sqllib/spb/projects ]
    then
        mkdirectory ${INSTHOME?}/sqllib/spb/projects
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/spb/projects
        mkpermission "ugo=rwx" ${INSTHOME?}/sqllib/spb/projects
    fi

    # link everything else.
    for f in ${DB2DIR?}/spb/*
    do
        base=`basename ${f?}`
        rm -f ${INSTHOME?}/sqllib/spb/${base?} 1> /dev/null 2> /dev/null
        ln -s ${f?} ${INSTHOME?}/sqllib/spb 1> /dev/null 2> /dev/null
    done

    # create db2spb.ini
    if [ ! -f ${INSTHOME?}/sqllib/spb/db2spb.ini ]
    then
        touch ${INSTHOME?}/sqllib/spb/db2spb.ini
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/spb/db2spb.ini
    fi

    trax create_spb_dir
}
# create links, etc., for spb directory under sqllib_vNNN
create_spb_dir_online()
{
    trac create_spb_dir_online
    set ${setopts?}

    # create real directory.
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb
        mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb
    fi

    # create projects directory.
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/projects ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/projects
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/projects
        mkpermission "ugo=rwx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/projects
    fi

    # link everything else.
    for f in ${DB2DIR?}/spb/*
    do
        base=`basename ${f?}`
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/${base?} 1> /dev/null 2> /dev/null
        ln -s ${f?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb 1> /dev/null 2> /dev/null
    done

    # create db2spb.ini
    if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/db2spb.ini ]
    then
        touch ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/db2spb.ini
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/spb/db2spb.ini
    fi

    trax create_spb_dir
}

# create exchange directory
create_exchange_dir ()
{
    trac create_exchange_dir
    set ${setopts?}

    # create real directory.
    if [ ! -d ${INSTHOME?}/sqllib/exchange ]
    then
        mkdirectory ${INSTHOME?}/sqllib/exchange
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/exchange
        mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/exchange
    fi

    # link everything
    for f in ${DB2DIR?}/exchange/*
    do
        base=`basename ${f?}`
        rm -f ${INSTHOME?}/sqllib/exchange/${base?} 1> /dev/null 2> /dev/null
        ln -s ${f?} ${INSTHOME?}/sqllib/exchange 1> /dev/null 2> /dev/null
    done

    trax create_exchange_dir
}

# create exchange directory
create_exchange_dir_online ()
{
    trac create_exchange_dir_online
    set ${setopts?}

    # create real directory.
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/exchange ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/exchange
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/exchange
        mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/exchange
    fi

    # link everything
    for f in ${DB2DIR?}/exchange/*
    do
        base=`basename ${f?}`
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/exchange/${base?} 1> /dev/null 2> /dev/null
        ln -s ${f?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/exchange 1> /dev/null 2> /dev/null
    done

    trax create_exchange_dir_online
} 

# Support for Content Extender Text Component
create_db2ext ()
{
    trac create_db2ext
    set ${setopts?}

    # update adm directory related files
    if [ -f ${INSTHOME?}/sqllib/adm/ctedem ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/adm/ctedem
        mkpermission "ug=rxs,o="    ${INSTHOME?}/sqllib/adm/ctedem
    fi
    if [ -f ${INSTHOME?}/sqllib/adm/ctelock ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/adm/ctelock
        mkpermission "ug=rxs,o="    ${INSTHOME?}/sqllib/adm/ctelock
    fi
    if [ -f ${INSTHOME?}/sqllib/adm/ciedem ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/adm/ciedem
        mkpermission "ug=rxs,o="    ${INSTHOME?}/sqllib/adm/ciedem
    fi

    # create real directories.
    if [ ! -d ${INSTHOME?}/sqllib/db2ext ]
    then
        mkdirectory ${INSTHOME?}/sqllib/db2ext
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2ext
        mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/db2ext
    fi

    DB2EXTDIRS="thes indexes memory"
    for dir in ${DB2EXTDIRS?}
    do
        if [ ! -d ${INSTHOME?}/sqllib/db2ext/${dir?} ]
        then
            mkdirectory ${INSTHOME?}/sqllib/db2ext/${dir?}
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2ext/${dir?}
            mkpermission "u=rwx,go=rx" ${INSTHOME?}/sqllib/db2ext/${dir?}
        fi
    done

    DB2EXTLNS="ddl resources"
    for link in ${DB2EXTLNS?}
    do
            rm -rf ${INSTHOME?}/sqllib/db2ext/${link?} 2> /dev/null 1> /dev/null
            ln -s ${DB2DIR?}/db2ext/${link?} ${INSTHOME?}/sqllib/db2ext/${link?}
    done

    DB2EXTFILES="db2extlm.cfg cteixcfg.ini"
    for f in ${DB2EXTFILES?}
    do
        if [ ! -f ${INSTHOME?}/sqllib/db2ext/${f?} ]
        then
            cp ${DB2DIR?}/db2ext/${f?} ${INSTHOME?}/sqllib/db2ext
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2ext/${f?}
            mkpermission "u=rw,go=r" ${INSTHOME?}/sqllib/db2ext/${f?}
        fi
    done

    DB2EXTFILESOF="cienodes.cfg ciedem.dat"
    for f in ${DB2EXTFILESOF?}
    do
        if [ -f ${DB2DIR?}/db2ext/${f?} ]
        then
            if [ ! -f ${INSTHOME?}/sqllib/db2ext/${f?} ]; then
            cp ${DB2DIR?}/db2ext/${f?} ${INSTHOME?}/sqllib/db2ext
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2ext/${f?}
            mkpermission "u=rw,go=r" ${INSTHOME?}/sqllib/db2ext/${f?}
            fi
        fi
    done

    trax create_db2ext
}
# Support for Content Extender Text Component
create_db2ext_online ()
{
    trac create_db2ext_online
    set ${setopts?}

    # update adm directory related files
    if [ -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ctedem ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ctedem
        mkpermission "ug=rxs,o="    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ctedem
    fi
    if [ -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ctelock ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ctelock
        mkpermission "ug=rxs,o="    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ctelock
    fi
    if [ -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ciedem ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ciedem
        mkpermission "ug=rxs,o="    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/adm/ciedem
    fi

    # create real directories.
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext ]
    then
        mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext
        mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext
    fi

    DB2EXTDIRS="thes indexes memory"
    for dir in ${DB2EXTDIRS?}
    do
        if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${dir?} ]
        then
            mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${dir?}
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${dir?}
            mkpermission "u=rwx,go=rx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${dir?}
        fi
    done

    DB2EXTLNS="ddl resources"
    for link in ${DB2EXTLNS?}
    do
            rm -rf ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${link?} 2> /dev/null 1> /dev/null
            ln -s ${DB2DIR?}/db2ext/${link?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${link?}
    done

    DB2EXTFILES="db2extlm.cfg cteixcfg.ini"
    for f in ${DB2EXTFILES?}
    do
        if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${f?} ]
        then
            cp ${DB2DIR?}/db2ext/${f?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${f?}
            mkpermission "u=rw,go=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${f?}
        fi
    done

    DB2EXTFILESOF="cienodes.cfg ciedem.dat"
    for f in ${DB2EXTFILESOF?}
    do
        if [ -f ${DB2DIR?}/db2ext/${f?} ]
        then
            if [ ! -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${f?} ]; then
            cp ${DB2DIR?}/db2ext/${f?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext
            chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${f?}
            mkpermission "u=rw,go=r" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2ext/${f?}
            fi
        fi
    done

    trax create_db2ext_online
}

# Support for the DB2 Text Search component
create_db2tss ()
{
    trac create_db2tss
    set ${setopts?}
    rc=1
# this method is used by db2icrt, db2nrcfg and db2iupdt
# it can also be used by db2iupgrade and installfixpack with some minor changes
#    isMpp=${TRUE?}
#    if [ -f ${INSTHOME?}/sqllib/db2nodes.cfg ]; then
#       lines=`wc -l ${INSTHOME?}/sqllib/db2nodes.cfg | awk '{print $1}'`
#       if [ ${lines?} -le 1 ]; then
#          isMpp=${FALSE?}
#       else
#          if [ ${DEBUG?} -eq ${TRUE?} ]; then
#             dmsg "DB2 Text Search was not created because ${INSTNAME?} is a multi-partition instance."
#          fi
#       fi
#    else
#      isMpp=${FALSE?}
#    fi

# if not, then copy template files from the installpath    
    if [ ! -d ${INSTHOME?}/sqllib/db2tss/config ]
    then
        if [ ! -d ${INSTHOME}/sqllib/db2tss ]
        then    
            mkdirectory ${INSTHOME?}/sqllib/db2tss
            mkdirectory ${INSTHOME?}/sqllib/db2tss/bin
        fi

        cp -Rf ${DB2DIR?}/cfg/db2tss/config ${INSTHOME}/sqllib/db2tss
        mkpermission "u=rwx,g=rx,o=x" ${INSTHOME?}/sqllib/db2tss/config
        find ${INSTHOME}/sqllib/db2tss/config/* -type f -print 2>/dev/null | \
            while read file; do
               mkpermission "u=rw,g=r,o=" ${file?}
            done

        chg_owngrp -R ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/db2tss
       
        update_db2tss
        rc=0
    else
        rc=1
    fi

    trax create_db2tss
    return ${rc?}
}
# Support for the DB2 Text Search component
create_db2tss_online ()
{
    trac create_db2tss_online
    set ${setopts?}
    rc=1

   query_instuse ${INSTNAME?} InstallerID 99999
   InstallerID="${INSTUSE_VALUE?}"

# if not, then copy template files from the installpath    
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/config ]
    then
        if [ ! -d ${INSTHOME}/${SQLLIB_DIR_NAME?}/db2tss ]
        then    
            mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss
            mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin
        fi

        cp -Rf ${DB2DIR?}/cfg/db2tss/config ${INSTHOME}/${SQLLIB_DIR_NAME?}/db2tss
        mkpermission "u=rwx,g=rx,o=x" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/config
        find ${INSTHOME}/${SQLLIB_DIR_NAME?}/db2tss/config/* -type f -print 2>/dev/null | \
            while read file; do
               mkpermission "u=rw,g=r,o=" ${file?}
            done

        chg_owngrp -R ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss
       
        #This should done as part of commit
        #update_db2tss
        ln -s ${DB2DIR?}/db2tss/bin/*    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/. 1> /dev/null 2> /dev/null
        DB2TSSDIR="ddl lib resource plugins"
        for name in ${DB2TSSDIR?}
        do
          if [ ${InstallerID?} -eq 0 ]; then
             rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/${name?} 1> /dev/null 2> /dev/null
             ln -s ${DB2DIR?}/db2tss/${name?}    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/${name?} 1> /dev/null 2> /dev/null
          else
             if [ -d ${INSTHOME}/${SQLLIB_DIR_NAME?}/db2tss/${name?} ]; then
                find ${INSTHOME}/${SQLLIB_DIR_NAME?}/db2tss/${name?}/* -type f -print 2>/dev/null | \
                while read file; do
                   mkpermission "u=r,go=r" ${file?}
                done
             fi
          fi
        done
        # create convenience links for the text search tools
        link_db2tss_tools_online
        rc=0
    else
        rc=1
    fi

    trax create_db2tss_online
    return ${rc?}
}

# Support for the DB2 Text Search component
link_db2tss_tools ()
{
    trac link_db2tss_tools
    set ${setopts?}

    if [ -d ${INSTHOME?}/sqllib/db2tss/config ]
    then

        # create convenience links for the text search tools
        rm -f ${INSTHOME?}/sqllib/db2tss/bin/configTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/sqllib/db2tss/bin/configTool.sh    ${INSTHOME?}/sqllib/db2tss/bin/configTool 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/sqllib/db2tss/bin/adminTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/sqllib/db2tss/bin/adminTool.sh    ${INSTHOME?}/sqllib/db2tss/bin/adminTool 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/sqllib/db2tss/bin/synonymTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/sqllib/db2tss/bin/synonymTool.sh    ${INSTHOME?}/sqllib/db2tss/bin/synonymTool 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/sqllib/db2tss/bin/logformatter 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/sqllib/db2tss/bin/logformatter.sh    ${INSTHOME?}/sqllib/db2tss/bin/logformatter 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/sqllib/db2tss/bin/richtextTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/sqllib/db2tss/bin/richtextTool.sh    ${INSTHOME?}/sqllib/db2tss/bin/richtextTool 1> /dev/null 2> /dev/null
 
    fi
             
    trax link_db2tss_tools
}

# Support for the DB2 Text Search component for online upgrade
link_db2tss_tools_online ()
{
    trac link_db2tss_tools_online
    set ${setopts?}

    if [ -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/config ]
    then

        # create convenience links for the text search tools
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/configTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/configTool.sh    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/configTool 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/adminTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/adminTool.sh    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/adminTool 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/synonymTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/synonymTool.sh    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/synonymTool 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/logformatter 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/logformatter.sh    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/logformatter 1> /dev/null 2> /dev/null
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/richtextTool 1> /dev/null 2> /dev/null  
        ln -s ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/richtextTool.sh    ${INSTHOME?}/${SQLLIB_DIR_NAME?}/db2tss/bin/richtextTool 1> /dev/null 2> /dev/null
 
    fi
             
    trax link_db2tss_tools_online
}

# create links for sqllib directory
create_sqllib_link ()
{
    trac create_sqllib_link $@
    set ${setopts?}

    # so many things can go wrong when the instance home dir is not
    # readable by its users.  While we don't recommend group or other to
    # have write access to the home directory, that is up to the users'
    # corporate security standards.  Make sure all needed bits are set.
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}
    mkpermission "u+rwx,go+rx" ${INSTHOME?}   

    for name in ${SQLLNKDIR?}
    do
        if [ -h ${INSTHOME?}/sqllib/${name?} ]; then
           rm -f ${INSTHOME?}/sqllib/${name?}
        fi

        if [ -d ${DB2DIR?}/${name?} ]; then
           dmsg "Linking sqllib directory ${name?}"
           ln -s ${DB2DIR?}/${name?} ${INSTHOME?}/sqllib/${name?}
        fi
    done

    for name in 32 64
    do
        if [ -h ${INSTHOME?}/sqllib/lib${name?} ]; then
           rm -f ${INSTHOME?}/sqllib/.${name?}
           ln -s lib${name?} ${INSTHOME?}/sqllib/.${name?}
        fi
    done
    
    # Create dsdriver links if they exist
    for dslink in ${DSLNKDIR?}
    do
        if [ -h ${INSTHOME?}/sqllib/${dslink?} ]; then
           rm -f ${INSTHOME?}/sqllib/${dslink?}
        fi

        if [ -d ${DB2DIR?}/dsdriver/${dslink?} ]; then
              ln -s ${DB2DIR?}/dsdriver/${dslink?} \
                 ${INSTHOME?}/sqllib/${dslink?}
        fi
    done

    # Create sqllib/itma link if itma exists in DB2DIR
    if [ -h ${INSTHOME?}/sqllib/itma ]; then
       rm -f ${INSTHOME?}/sqllib/itma
    fi
    if [ -d ${DB2DIR?}/itma ]; then
       ln -s ${DB2DIR?}/itma ${INSTHOME?}/sqllib/itma
    fi

    # Link from lib<highestbit> to lib under sqllib if lib does not exists
    # Remove the sqllib/lib link if its target dir does not exist
    if [ -h ${INSTHOME?}/sqllib/lib -a ! -d ${INSTHOME?}/sqllib/lib ]; then
        rm ${INSTHOME?}/sqllib/lib
    fi
    if [ ! -h ${INSTHOME?}/sqllib/lib ]; then
        ln -s lib${HIGHEST_BIT?} ${INSTHOME?}/sqllib/lib
    fi 

    # The function dir may need to be cleaned up
    cleanup_function_dir

    for dir in dasfcn function
    do
        if [ -d ${DB2DIR?}/${dir?} ]
        then
            if [ ! -d ${INSTHOME?}/sqllib/${dir?} ]
            then
                if [ ! -d ${INSTHOME?}/sqllib/${dir?} ]
                then
                    mkdirectory ${INSTHOME?}/sqllib/${dir?}
                fi
                chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/${dir?}
                mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/${dir?}
            fi
    
            for ftn in ${DB2DIR?}/${dir?}/*
            do
                filename=`basename ${ftn?}`
                if [ -d ${ftn?} ]
                then
                    rm -f ${INSTHOME?}/sqllib/${dir?}/${filename?} 2> /dev/null
                    if [ ! -d ${INSTHOME?}/sqllib/${dir?}/${filename?} ]
                    then
                        if [ ! -d ${INSTHOME?}/sqllib/${dir?}/${filename?} ]
                        then
                            mkdirectory ${INSTHOME?}/sqllib/${dir?}/${filename?}
                        fi
                        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/${dir?}/${filename?}
                        mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/${dir?}/${filename?}
                    fi
                    if [ "${filename?}" != "src" -a "${filename?}" != "unfenced" ]
                    then
                        for fn in ${DB2DIR?}/${dir?}/${filename?}/*
                        do
                            bfn=`basename ${fn?}`
                            ls ${INSTHOME?}/sqllib/${dir?}/${filename?}/${bfn?} > /dev/null 2> /dev/null
                            if [ $? -eq 0 ]
                            then
                                rm -rf ${INSTHOME?}/sqllib/${dir?}/${filename?}/${bfn?}
                            fi
                            ln -s ${fn?} ${INSTHOME?}/sqllib/${dir?}/${filename?}
                        done
                    fi
                else
                    if [ ! -d  ${INSTHOME?}/sqllib/${dir?}/${filename?} ]; then
                        dmsg "Linking file ${filename?} in sqllib/${dir?}"
                        rm -f ${INSTHOME?}/sqllib/${dir?}/${filename?}
                        ln -s ${DB2DIR?}/${dir?}/${filename?} \
                                  ${INSTHOME?}/sqllib/${dir?}/${filename?}
                    fi
                fi
            done
            # GA could leave a link called * so clean it up...
            rm ${INSTHOME?}/sqllib/${dir?}/'*' 1>/dev/null 2>/dev/null
            # ...and remove the directory if it is empty
            rmdir ${INSTHOME?}/sqllib/${dir?} 1>/dev/null 2>/dev/null
        fi
    done

    if [ -d ${DB2DIR?}/function/unfenced ]
    then
        for ftn in ${DB2DIR?}/function/unfenced/*
        do
            filename=`basename ${ftn?}`
            #if [ "${filename?}" != "src" -a "${filename?}" != "unfenced" ]
            #then
                if [ ! -d  ${INSTHOME?}/sqllib/function/unfenced/${filename?} ]; then
                    dmsg "Linking file ${filename?} in sqllib/function/unfenced"
                    rm -f ${INSTHOME?}/sqllib/function/unfenced/${filename?}
                    ln -s ${DB2DIR?}/function/unfenced/${filename?} \
                              ${INSTHOME?}/sqllib/function/unfenced/${filename?}
                fi
            #fi
        done
        # GA could leave a link called * so clean it up...
        rm ${INSTHOME?}/sqllib/function/unfenced/'*' 1>/dev/null 2>/dev/null
        # ...and remove the directory if it is empty
        rmdir ${INSTHOME?}/sqllib/function/unfenced 1>/dev/null 2>/dev/null

    fi

    # create doc.cmn link
    if [ -d ${INSTHOME?}/sqllib/doc/doc.cmn ]; then
        rm -f ${INSTHOME?}/sqllib/doc.cmn
        ln -s ${INSTHOME?}/sqllib/doc/doc.cmn ${INSTHOME?}/sqllib/doc.cmn
    fi

    # Create the spb subdirectory
    if [ -d ${DB2DIR?}/spb ]
    then
        create_spb_dir
    fi

    # Create the echange subdirectory
    if [ -d ${DB2DIR?}/exchange ]
    then
        create_exchange_dir
    fi

    # Create the sqllib/function/routine subdirectory
    if [ ! -d ${INSTHOME?}/sqllib/function/routine -a -d ${INSTHOME?}/sqllib/function ]; then
        if [ ! -d ${INSTHOME?}/sqllib/function/routine ]
        then
            mkdirectory ${INSTHOME?}/sqllib/function/routine
        fi
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/function/routine
        mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/function/routine
    fi

    # Create the DW logging directory.
    if [ ! -d ${INSTHOME?}/sqllib/logging ]; then
        # any DW installed?
        if [ -f ${INSTHOME?}/bin/db2dwc -o -f ${INSTHOME?}/sqllib/bin/IWH.environment ]; then
            if [ ! -d ${INSTHOME?}/sqllib/logging ]
            then
                mkdirectory ${INSTHOME?}/sqllib/logging
            fi
        fi
    fi
    # ensure the permissions are always right.
    if [ -d ${INSTHOME?}/sqllib/logging ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/logging
        mkpermission "ugo=rwx" ${INSTHOME?}/sqllib/logging
    fi
    # copy blu libs for power 
    # Now as part xxx def, this is taken care duing instalaton time  itself 
    #copy_blu_libs

    trax create_sqllib_link
}
# create links for sqllib directory
create_sqllib_link_online ()
{
    trac create_sqllib_link_online $@
    set ${setopts?}

    SQLLIB_DIR_NAME=sqllib_v${DB2VER?}
    # so many things can go wrong when the instance home dir is not
    # readable by its users.  While we don't recommend group or other to
    # have write access to the home directory, that is up to the users'
    # corporate security standards.  Make sure all needed bits are set.
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}
    mkpermission "u+rwx,go+rx" ${INSTHOME?}   

    for name in ${SQLLNKDIR?}
    do
        if [ -h ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${name?} ]; then
           rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${name?}
        fi

        if [ -d ${DB2DIR?}/${name?} ]; then
           dmsg "Linking sqllib directory ${name?}"
           ln -s ${DB2DIR?}/${name?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${name?}
        fi
    done

    for name in 32 64
    do
        if [ -h ${INSTHOME?}/${SQLLIB_DIR_NAME?}/lib${name?} ]; then
           rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.${name?}
           ln -s lib${name?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/.${name?}
        fi
    done
    
    # Create dsdriver links if they exist
    for dslink in ${DSLNKDIR?}
    do
        if [ -h ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dslink?} ]; then
           rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dslink?}
        fi

        if [ -d ${DB2DIR?}/dsdriver/${dslink?} ]; then
              ln -s ${DB2DIR?}/dsdriver/${dslink?} \
                 ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dslink?}
        fi
    done

    # Create sqllib/itma link if itma exists in DB2DIR
    if [ -h ${INSTHOME?}/${SQLLIB_DIR_NAME?}/itma ]; then
       rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/itma
    fi
    if [ -d ${DB2DIR?}/itma ]; then
       ln -s ${DB2DIR?}/itma ${INSTHOME?}/${SQLLIB_DIR_NAME?}/itma
    fi

    # Link from lib<highestbit> to lib under sqllib if lib does not exists
    # Remove the sqllib/lib link if its target dir does not exist
    if [ -h ${INSTHOME?}/${SQLLIB_DIR_NAME?}/lib -a ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/lib ]; then
        rm ${INSTHOME?}/${SQLLIB_DIR_NAME?}/lib
    fi
    if [ ! -h ${INSTHOME?}/${SQLLIB_DIR_NAME?}/lib ]; then
        ln -s lib${HIGHEST_BIT?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/lib
    fi 

    # The function dir may need to be cleaned up
    #cleanup_function_dir
    if [ -d ${DB2DIR?}/function ]; then
        for dir in dasfcn function
        do
            fileList=`ls -1 ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?} 2> /dev/null`
            for file in ${fileList?}; do
                ls -1 -l ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${file?} | grep ${DB2DIR?} 1> /dev/null 2> /dev/null
                if [ $? -eq 0 -a ${file?} != "unfenced" -a ${file?} != "db2rdf" ]; then
                    rm -rf ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${file?}
                fi
            done
        done
    fi

    for dir in dasfcn function
    do
        if [ -d ${DB2DIR?}/${dir?} ]
        then
            if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?} ]
            then
                if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?} ]
                then
                    mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}
                fi
                chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}
                mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}
            fi
    
            for ftn in ${DB2DIR?}/${dir?}/*
            do
                filename=`basename ${ftn?}`
                if [ -d ${ftn?} ]
                then
                    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?} 2> /dev/null
                    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?} ]
                    then
                        if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?} ]
                        then
                            mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}
                        fi
                        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}
                        mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}
                    fi
                    if [ "${filename?}" != "src" -a "${filename?}" != "unfenced" ]
                    then
                        for fn in ${DB2DIR?}/${dir?}/${filename?}/*
                        do
                            bfn=`basename ${fn?}`
                            ls ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}/${bfn?} > /dev/null 2> /dev/null
                            if [ $? -eq 0 ]
                            then
                                rm -rf ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}/${bfn?}
                            fi
                            ln -s ${fn?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}
                        done
                    fi
                else
                    if [ ! -d  ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?} ]; then
                        dmsg "Linking file ${filename?} in ${SQLLIB_DIR_NAME?}/${dir?}"
                        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}
                        ln -s ${DB2DIR?}/${dir?}/${filename?} \
                                  ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/${filename?}
                    fi
                fi
            done
            # GA could leave a link called * so clean it up...
            rm ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?}/'*' 1>/dev/null 2>/dev/null
            # ...and remove the directory if it is empty
            rmdir ${INSTHOME?}/${SQLLIB_DIR_NAME?}/${dir?} 1>/dev/null 2>/dev/null
        fi
    done

    if [ -d ${DB2DIR?}/function/unfenced ]
    then
        for ftn in ${DB2DIR?}/function/unfenced/*
        do
            filename=`basename ${ftn?}`
            #if [ "${filename?}" != "src" -a "${filename?}" != "unfenced" ]
            #then
                if [ ! -d  ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/unfenced/${filename?} ]; then
                    dmsg "Linking file ${filename?} in ${SQLLIB_DIR_NAME?}/function/unfenced"
                    rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/unfenced/${filename?}
                    ln -s ${DB2DIR?}/function/unfenced/${filename?} \
                              ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/unfenced/${filename?}
                fi
            #fi
        done
        # GA could leave a link called * so clean it up...
        rm ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/unfenced/'*' 1>/dev/null 2>/dev/null
        # ...and remove the directory if it is empty
        rmdir ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/unfenced 1>/dev/null 2>/dev/null

    fi

    # create doc.cmn link
    if [ -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/doc/doc.cmn ]; then
        rm -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/doc.cmn
        ln -s ${INSTHOME?}/${SQLLIB_DIR_NAME?}/doc/doc.cmn ${INSTHOME?}/${SQLLIB_DIR_NAME?}/doc.cmn
    fi

    # Create the spb subdirectory
    if [ -d ${DB2DIR?}/spb ]
    then
        create_spb_dir_online
    fi

    # Create the echange subdirectory
    if [ -d ${DB2DIR?}/exchange ]
    then
        create_exchange_dir_online
    fi

    # Create the sqllib/function/routine subdirectory
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/routine -a -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function ]; then
        if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/routine ]
        then
            mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/routine
        fi
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/routine
        mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/function/routine
    fi

    # Create the DW logging directory.
    if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/logging ]; then
        # any DW installed?
        if [ -f ${INSTHOME?}/bin/db2dwc -o -f ${INSTHOME?}/${SQLLIB_DIR_NAME?}/bin/IWH.environment ]; then
            if [ ! -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/logging ]
            then
                mkdirectory ${INSTHOME?}/${SQLLIB_DIR_NAME?}/logging
            fi
        fi
    fi
    # ensure the permissions are always right.
    if [ -d ${INSTHOME?}/${SQLLIB_DIR_NAME?}/logging ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/${SQLLIB_DIR_NAME?}/logging
        mkpermission "ugo=rwx" ${INSTHOME?}/${SQLLIB_DIR_NAME?}/logging
    fi
    # copy blu libs for power 
    # Now as part xxx def, this is taken care duing instalaton time  itself 
    #copy_blu_libs

    trax create_sqllib_link_online
}

nr_create_sqllib_link()
{
    trac nr_create_sqllib_link $@
    set ${setopts?}

    # so many things can go wrong when the instance home dir is not
    # readable by its users.  While we don't recommend group or other to
    # have write access to the home directory, that is up to the users'
    # corporate security standards.  Make sure all needed bits are set.
    mkpermission "u+rwx,go+rx" ${INSTHOME?}   

    for name in 32 64
    do
        if [ -d ${INSTHOME?}/sqllib/lib${name?} ]; then
           rm -f ${INSTHOME?}/sqllib/.${name?}
           ln -s lib${name?} ${INSTHOME?}/sqllib/.${name?}
        fi
    done

    # Link from lib<highestbit> to lib under sqllib if lib does not exists
    # Remove the sqllib/lib link if its target dir does not exist
    if [ -h ${INSTHOME?}/sqllib/lib -a ! -d ${INSTHOME?}/sqllib/lib ]; then
        rm ${INSTHOME?}/sqllib/lib
    fi
    if [ ! -h ${INSTHOME?}/sqllib/lib ]; then
        ln -s lib${HIGHEST_BIT?} ${INSTHOME?}/sqllib/lib
    fi 
    
    # Create dsdriver links if they exist
    for dslink in ${DSLNKDIR?}
    do
        if [ -h ${INSTHOME?}/sqllib/${dslink?} ]; then
           rm -f ${INSTHOME?}/sqllib/${dslink?}
        fi

        if [ -d ${DB2DIR?}/dsdriver/${dslink?} ]; then
              ln -s ${DB2DIR?}/dsdriver/${dslink?} \
                 ${INSTHOME?}/sqllib/${dslink?}
        fi
    done

    if [ -d ${DB2DIR?}/function/unfenced ]
    then
        # GA could leave a link called * so clean it up...
        rm ${INSTHOME?}/sqllib/function/unfenced/'*' 1>/dev/null 2>/dev/null
        # ...and remove the directory if it is empty
        rmdir ${INSTHOME?}/sqllib/function/unfenced 1>/dev/null 2>/dev/null

    fi

    # create doc.cmn link
    if [ -d ${INSTHOME?}/sqllib/doc/doc.cmn ]; then
        rm -f ${INSTHOME?}/sqllib/doc.cmn
        ln -s ${INSTHOME?}/sqllib/doc/doc.cmn ${INSTHOME?}/sqllib/doc.cmn
    fi

    # Create the spb subdirectory
    if [ -d ${DB2DIR?}/spb ]
    then
        # create projects directory.
        if [ ! -d ${INSTHOME?}/sqllib/spb/projects ]
        then
            mkdirectory ${INSTHOME?}/sqllib/spb/projects
            mkpermission "ugo=rwx" ${INSTHOME?}/sqllib/spb/projects
        fi
        
        # create db2spb.ini
        if [ ! -f ${INSTHOME?}/sqllib/spb/db2spb.ini ]
        then
            touch ${INSTHOME?}/sqllib/spb/db2spb.ini
        fi
    fi

    # Create the sqllib/function/routine subdirectory
    if [ ! -d ${INSTHOME?}/sqllib/function/routine -a -d ${INSTHOME?}/sqllib/function ]; then
        if [ ! -d ${INSTHOME?}/sqllib/function/routine ]
        then
            mkdirectory ${INSTHOME?}/sqllib/function/routine
        fi
        mkpermission "u=rwx,g=rwxs,o=rx,+t" ${INSTHOME?}/sqllib/function/routine
    fi

    # Create the DW logging directory.
    if [ ! -d ${INSTHOME?}/sqllib/logging ]; then
        # any DW installed?
        if [ -f ${INSTHOME?}/bin/db2dwc -o -f ${INSTHOME?}/sqllib/bin/IWH.environment ]; then
            if [ ! -d ${INSTHOME?}/sqllib/logging ]
            then
                mkdirectory ${INSTHOME?}/sqllib/logging
            fi
        fi
    fi
    # ensure the permissions are always right.
    if [ -d ${INSTHOME?}/sqllib/logging ]; then
        mkpermission "ugo=rwx" ${INSTHOME?}/sqllib/logging
    fi
    
    # copy blu libs for power

    trax nr_create_sqllib_link
}

# Initialize the instance creation process
# Ensure that everthing is OK to create the instance
init_icreate ()
{
    trac init_icreate $@
    set ${setopts?}

    find_homedir ${INSTNAME?}
    INSTHOME=${USERHOME?}

    # Issue an error message if the sqllib directory already exists.
  if [ ${ONLINE_PREPARE_SQLLIB_VER?} -ne ${TRUE?} ]; then
    if [ -d ${INSTHOME?}/sqllib ]; then
        line_count=`ls -la ${INSTHOME?}/sqllib | wc -l`
        if [ ${line_count?} -gt 3 ]; then
            display_msg ${DB2CAT?} 82 \
                'DBI1082E The file or directory %s already exists.\n' \
                ${INSTHOME?}/sqllib
            stop_prog 1
        fi
        #sqllib is empty, remove it for now
        rmdir ${INSTHOME?}/sqllib 1>/dev/null 2>/dev/null
    fi

    # Issue an error message if the das directory exists.
    if [ -d ${INSTHOME?}/das ]; then
        display_msg ${DB2CAT?} 77 \
             'DBI1077E The user %s is being used by the DB2 \
Administration Server and thus can not be used to create the DB2  instance. \n' ${INSTNAME?}
        stop_prog 1
    fi

     ## Issue and error message if the instance owner's home directory is under DB2DIR
    echo ${INSTHOME?} | egrep "^${DB2DIR?}/" 2> /dev/null 1> /dev/null
     if [ $? -eq 0 ]; then
        display_msg ${DB2CAT?} 327 \
              'DBI1327E The db2icrt command failed because the home directory of the instance owner \
 is a subdirectory under the directory in which the DB2 product is installed.\n'
        stop_prog 1
     fi

    # Load all IPC config params
    if [ -f ${PROGDIR?}/db2ipcld ]; then
        ${PROGDIR?}/db2ipcld
    fi

fi 
# end of skip for online upgrade code

    # Set the value of vars INSTHOME and INSTPGRP
    # and check their validity
    get_instance

    # if we want to create of correct bit width, reset after get_instance
    INSTBITWIDTH=${BITWIDTH:-${INSTBITWIDTH?}}

  if [ ${ONLINE_PREPARE_SQLLIB_VER?} -ne ${TRUE?} ]; then
    # Issue an error message if instance already exists
    ${DB2DIR?}/instance/db2iset -q ${INSTNAME?} 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        display_msg ${DB2CAT?} 292 \
            'DBI1292E The instance %s is already in the instance list.\n' \
            ${INSTNAME?}
        stop_prog 1
    fi
fi
# end of non online upgrade code 

    # Define special variables
    def_specials

    # Ensure that the AUTHTYPE value is valid
    chk_authtype

    # Verify FencedID info if a DB2 server is installed
    prepare_itype
    if [ ${INSTTYPE?} -ne ${ITYPE_CLN?} ]; then
        verify_fencinfo
    else
       if [ "X${PORTNUM?}" != "X" ]; then
           display_msg ${DB2CAT?} 179 \
             'DBI1179E Client instances can not be created with the [-p PortName] option.\n'
           stop_prog 1
       fi
    fi

    # Issue an error message if any of the directory does not have access
    # permission in the sqllib path.
    curdir=`/bin/pwd`
    cd ${INSTHOME?}
    su ${INSTNAME?} -c "/bin/pwd" 1> /dev/null 2> /dev/null
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 88 \
            'DBI1088E An invalid access permission detected for directory %s.\n' \
            ${INSTHOME?}
        stop_prog 1
    fi
    cd ${curdir?}

    # Check that home dir is on a valid filesystem
    chk_fsystype ${INSTHOME?}

    # Check that home dir filesystem has enough space
    chk_fsysspace ${INSTHOME?} ${SPACEREQ?}

  if [ ${ONLINE_PREPARE_SQLLIB_VER?} -ne ${TRUE?} ]; then
    # If there is UNIX socket directory for the instance, remove it
    if [ -d ${SOCKETDIR?}/${INSTNAME?} ]; then
        rm -rf ${SOCKETDIR?}/${INSTNAME?}
    fi

    # remove any /usr/lib and /lib db2 links, if they exist
    for rel in $DB2V5DIR $DB2V61DIR $DB2V71DIR
    do
        rc=1
        ls -l /usr/lib | grep ${rel?} 2> /dev/null 1> /dev/null
        if [ $? -ne 0 ]; then
            ls -l /lib | grep ${rel?} 2> /dev/null 1> /dev/null
            if [ $? -ne 0 ]; then
                rc=0
            fi
        fi
        if [ ${rc?} -ne 0 ]; then
            if [ -f ${rel?}/cfg/db2rmln ]; then
                ${rel?}/cfg/db2rmln
            fi
        fi
    done
 fi
 # end of non online upgrade code

    trax init_icreate
}

init_nrcfg ()
{
    trac init_nrcfg $@
    set ${setopts?}

    find_homedir ${INSTNAME?}
    INSTHOME=${USERHOME?}

    # Issue an error message if the das directory exists.
    if [ -d ${INSTHOME?}/das ]; then
        display_msg ${DB2CAT?} 77 \
             'DBI1077E The user %s is being used by the DB2 \
Administration Server and thus can not be used to create the DB2  instance. \n' ${INSTNAME?}
        stop_prog 1
    fi

    # Load all IPC config params
    if [ -f ${PROGDIR?}/db2ipcld ]; then
        ${PROGDIR?}/db2ipcld
    fi

    # Set the value of vars INSTHOME and INSTPGRP
    # and check their validity
    get_instance

    # if we want to create of correct bit width, reset after get_instance
    INSTBITWIDTH=${BITWIDTH:-${INSTBITWIDTH?}}

    # Issue an error message if instance already exists
    ${DB2DIR?}/instance/db2iset -q ${INSTNAME?} 1>/dev/null 2>/dev/null
    if [ $? -eq 0 ]; then
        display_msg ${DB2CAT?} 292 \
            'DBI1292E The instance %s is already in the instance list.\n' \
            ${INSTNAME?}
        stop_prog 1
    fi

    # Define special variables
    def_specials

    # Ensure that the AUTHTYPE value is valid
    chk_authtype

    # Verify FencedID info if a DB2 server is installed
    prepare_itype

    # Issue an error message if any of the directory does not have access
    # permission in the sqllib path.
    curdir=`/bin/pwd`
    cd ${INSTHOME?}
    /bin/pwd 1> /dev/null 2> /dev/null
    if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 88 \
            'DBI1088E An invalid access permission detected for directory %s.\n' \
            ${INSTHOME?}
        stop_prog 1
    fi
    cd ${curdir?}

    # Check that home dir is on a valid filesystem
    chk_fsystype ${INSTHOME?}

    # Check that home dir filesystem has enough space
    chk_fsysspace ${INSTHOME?} ${SPACEREQ?}

    # If there is UNIX socket directory for the instance, remove it
    if [ -d ${SOCKETDIR?}/${INSTNAME?} ]; then
        rm -rf ${SOCKETDIR?}/${INSTNAME?}
    fi

    trax init_nrcfg
}

cr_instance ()
{
    trac cr_instance $@
    set ${setopts?}
    # If we pass this point, undo all changes if any error occurs
    UNDOCHG=${TRUE?}

    # Set the filemode creation mask of the current shell
    umask ${UMASK?}

    # Add instance name to the instance list
    add_instlist ${INSTNAME?} ${DB2VER?}
    if [ $? -ne ${TRUE?} ]; then
        stop_prog 1
    fi

    # Create "sqllib" dir
    create_sqllib

    update_instuse ${INSTNAME?} "BitWidth" ${HIGHEST_BIT?}

    # Copy all the License Support files
    copy_licsupp

    # Create FencedID Info file, if needed
    create_fencinfo

    # Set up admin server group list
    setup_das_groups

    # Copy default DBM config file
    copy_dbmcfg
    if [ $? -ne ${TRUE?} ]; then
        display_msg ${DB2CAT?} 281 \
            'DBI1281E The database manager configuration file could not be initialized.\n'
        stop_prog 1
    fi

    # Create "db2nodes.cfg" file, if  
    make_db2nodes

    # Copy the adm files
    update_adm

    # Copy the acs files
    update_acs ${DB2DIR?} new ${FALSE?}

    # Copy all the "setuid" programs to instance's sqllib dir
    copy_setuid

    # Support for Content Extender Text Component
    if [ -d ${DB2DIR?}/db2ext -a -f ${DB2DIR?}/bin/db2text ]
    then
        create_db2ext
    fi

    # Create the instance "profile" files
    make_profiles
    
    # Update the DBM config file
    if [ ${SKIP_UPDT_DBM?} -ne ${TRUE?} ]; then 
    updt_dbmcfg
    fi

    _update_instuse

   # call db2addicons to add DB2 desktop entries for the instance
   if [ -f ${INSTHOME?}/sqllib/bin/db2addicons ]; then
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2addicons" 1>/dev/null 2>/dev/null
   fi
   
   # Support for the DB2 Text Search component (TEXT_SEARCH)
   if [ -f ${DB2DIR?}/bin/db2ts ]
   then
       create_db2tss
   fi

   # Update itma cfg file for the instance
   itma_updatecfg a ${INSTNAME?} ${DB2DIR?}

      if [ -f ${INSTHOME?}/sqllib/bin/db2ftok ]; then
          ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2ftok"
      fi
   
   #Merge db2systm file
   #if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] && [ -f ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/db2systm ]
   #then
   #    # Update the new DBM cfg using info from the shared db2systm
   #    shared_db2systm=${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/db2systm
   #    local_db2systm=${INSTHOME?}/sqllib/db2systm
   #    ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2imdbm ${local_db2systm?} \
   #    ${shared_db2systm?} ${HIGHEST_BIT?} ${HIGHEST_BIT?} ${INSTNAME?}" 1>/dev/null 2>/dev/null
   #    rc=$?
#
#       if [ ${rc?} -ne 0 ]; then
#          if [ ${DEBUG?} -eq ${TRUE?} ]; then
#             dmsg "Return Code of dbm cfg merge = ${rc?}"
#          fi
#          # Restore the default dbm cfg file
#          rm -f ${local_db2systm?}
#          copy_dbmcfg
#          display_msg ${DB2CAT?} 282 \
#          'DBI1282W The database manager configuration files could not be merged. \
#          The previous database manager configuration file is %s. \
#          The previous instance type is %s, and the current instance type is %s.\n' \
#          ${local_db2systm?} `display_inst_type ${INSTTYPE?}` `display_inst_type ${INSTTYPE?}`
#       fi
#   fi
   
   #Clean the db2nodes.cfg if there is a physical file in local host and SD instance
   if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] && [ ! -h ${INSTHOME?}/sqllib/db2nodes.cfg ]
   then
       cat /dev/null > ${INSTHOME?}/sqllib/db2nodes.cfg
   fi
   
   if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] && [ ! -h ${INSTHOME?}/sqllib/db2systm ]
   then
   ln -s ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/db2systm  ${INSTHOME?}/sqllib/db2systm
   fi 
   setup_dsf      

   trax cr_instance
}

cr_instance_online()
{
    trac cr_instance_online $@
    set ${setopts?}
    # If we pass this point, undo all changes if any error occurs
    UNDOCHG=${TRUE?}

    # Set the filemode creation mask of the current shell
    umask ${UMASK?}

    # Add instance name to the instance list
#    add_instlist ${INSTNAME?} ${DB2VER?}
#    if [ $? -ne ${TRUE?} ]; then
#        stop_prog 1
#    fi

    # Create "sqllib" dir
    create_sqllib_online

    update_instuse_online ${INSTNAME?} "BitWidth" ${HIGHEST_BIT?}

    # Copy all the License Support files
    copy_licsupp_online

    # Create FencedID Info file, if needed
    create_fencinfo

    # Set up admin server group list
    setup_das_groups

    # Copy default DBM config file
    copy_dbmcfg_online
    if [ $? -ne ${TRUE?} ]; then
        display_msg ${DB2CAT?} 281 \
            'DBI1281E The database manager configuration file could not be initialized.\n'
        #stop_prog 1
    fi

    # Create "db2nodes.cfg" file, if  
    make_db2nodes

    # Copy the adm files
    update_adm_online

    # Copy the acs files
    update_acs_online ${DB2DIR?} new ${FALSE?}

    # Copy all the "setuid" programs to instance's sqllib dir
    copy_setuid_online

    # Support for Content Extender Text Component
    if [ -d ${DB2DIR?}/db2ext -a -f ${DB2DIR?}/bin/db2text ]
    then
        create_db2ext_online
    fi

    # Create the instance "profile" files
    make_profiles_online
    
    # Update the DBM config file
    #if [ ${SKIP_UPDT_DBM?} -ne ${TRUE?} ]; then 
    #updt_dbmcfg_online
    #fi

    _update_instuse_online

   # call db2addicons to add DB2 desktop entries for the instance
#   if [ -f ${INSTHOME?}/sqllib/bin/db2addicons ]; then
#        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib_v107/bin/db2addicons" 1>/dev/null 2>/dev/null
#   fi
#   

   # Support for the DB2 Text Search component (TEXT_SEARCH)
   if [ -f ${DB2DIR?}/bin/db2ts ]
   then
       create_db2tss_online
   fi

   #setup_dsf_ver      

   trax cr_instance_online
}

exe_nrcfg ()
{
    trac exe_nrcfg $@
    set ${setopts?}

    # If we pass this point, undo all changes if any error occurs
    UNDOCHG=${TRUE?}

    # Set the filemode creation mask of the current shell
    umask ${UMASK?}

    chk_ulimit

    # Create "sqllib" dir
    nr_create_sqllib

    update_instuse ${INSTNAME?} "BitWidth" ${HIGHEST_BIT?}

    # Copy all the License Support files
    nr_copy_licsupp

    # Copy default DBM config file
    nr_copy_dbmcfg
    if [ $? -ne ${TRUE?} ]; then
        display_msg ${DB2CAT?} 281 \
            'DBI1281E The database manager configuration file could not be initialized.\n'
        stop_prog 1
    fi

    # Create "db2nodes.cfg" file, if needed
    nr_make_db2nodes

    DB2LOCAL=`echo $DB2LOCAL`
    if [ ! -f ${DB2LOCAL?}/.mount ]; then
      mkpermission -R "ug+x" ${INSTHOME?}/sqllib/adm
    fi

    # Call db2iuadm_nr to sets permissions for all files in the
    # adm directory
    ${DB2DIR?}/instance/db2iuadm_nr ${INSTHOME?}/sqllib ${INSTNAME?} ${INSTPGRP?} \
             ${INSTNAME?} ${INSTPGRP} ${INSTTYPE?} "set" ${setopts?}

    # Copy all the "setuid" programs to instance's sqllib dir
    nr_copy_setuid

    # Support for the DB2 Text Search component (TEXT_SEARCH)
    
    if [ -f ${DB2DIR?}/bin/db2ts ]
    then
        create_db2tss
    fi

    # Create the instance "profile" files
    make_profiles
    # Create the install "db2rfe.cfg" file
    make_db2rfe_cfg

    # source db2profile
    # INSTPROF="${INSTHOME?}/sqllib/db2profile"
    if [ -f ${INSTPROF?} ]; then
        . ${INSTPROF?}
    fi

    # Update the DBM config file
    nr_updt_dbmcfg

    # generate the ftok for the engine
    if [ -f ${INSTHOME?}/sqllib/bin/db2ftok ]; then
        ${INSTHOME?}/sqllib/bin/db2ftok
    fi
    _update_instuse

    # Add instance name to the instance list
    add_instlist ${INSTNAME?} ${DB2VER?}
    if [ $? -ne ${TRUE?} ]; then
        stop_prog 1
    fi

    # call db2addicons to add DB2 desktop entries for the instance
    if [ -f ${INSTHOME?}/sqllib/bin/db2addicons ]; then
        ${INSTHOME?}/sqllib/bin/db2addicons 1>/dev/null 2>/dev/null
    fi
    
    trax exe_nrcfg
}

#-----------------------------------------------------------------------
# Name       - modify_profile
# Function   - Modify the instance owner's profile with db2profile.            
#          This is called only if db2setup is used to create the id.
# Parameters - None
#-----------------------------------------------------------------------
modify_profile()
{
    trac modify_profile $@
    set ${setopts?}

    unset modprofile modlogin
    modprofile=${FALSE?}
    modlogin=${FALSE?}

    # Find out if the instance owner's home directory contains a .profile 
    # or .login file.  If .profile exists, then add the line . ${INSTHOME?}/sqllib/db2profile
    # at the end.  If .login exists, then add the line source ${INSTHOME?}/sqllib/db2cshrc at
    # the end.

    if [ -f ${INSTHOME?}/.profile ]; then
        chmod u+w ${INSTHOME?}/.profile
    fi
    
    if [ -f ${INSTHOME?}/.profile -a -w ${INSTHOME?}/.profile ]; then
        modprofile=${TRUE?}
        egrep -v '#' ${INSTHOME?}/.profile | \
            grep "\. ${INSTHOME?}/sqllib/db2profile" 1>/dev/null 2>/dev/null
        if [ $? -ne 0 ]; then
            echo "
# The following three lines have been added by IBM DB2 instance utilities.
if [ -f ${INSTHOME?}/sqllib/db2profile ]; then
    . ${INSTHOME?}/sqllib/db2profile
fi

" >> ${INSTHOME?}/.profile 2>/dev/null
            if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 768 \
                    'DBI1768W Unable to modify %s or %s for user %s.\n' \
                    ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc ${INSTNAME?} \
                    ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc
            fi
        fi
    fi

# For Linux, default shell is bash, add this to the .bashrc as well

    if [ -f ${INSTHOME?}/.bashrc ]; then
        chmod u+w ${INSTHOME?}/.bashrc
    fi

    if [ -f ${INSTHOME?}/.bashrc -a -w ${INSTHOME?}/.bashrc ]; then
        modprofile=${TRUE?}
        egrep -v '#' ${INSTHOME?}/.bashrc | \
            grep "\. ${INSTHOME?}/sqllib/db2profile" 1>/dev/null 2>/dev/null
        if [ $? -ne 0 ]; then
            echo "
# The following three lines have been added by UDB DB2.
if [ -f ${INSTHOME?}/sqllib/db2profile ]; then
    . ${INSTHOME?}/sqllib/db2profile
fi

" >> ${INSTHOME?}/.bashrc 2>/dev/null
            if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 768 \
                    'DBI1768W Unable to modify %s or %s for user %s.\n' \
                    ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc ${INSTNAME?} \
                    ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc
            fi
        fi
    fi

    if [ -f ${INSTHOME?}/.login ]; then
        chmod u+w ${INSTHOME?}/.login
    fi
 
    if [ -f ${INSTHOME?}/.login -a -w ${INSTHOME?}/.login ]; then
        modlogin=${TRUE?}
        egrep -v '#' ${INSTHOME?}/.login | \
            grep "source ${INSTHOME?}/sqllib/db2cshrc" 1>/dev/null 2>/dev/null
        if [ $? -ne 0 ]; then
            echo "
# The following two lines have been added by UDB DB2.
if ( -f ${INSTHOME?}/sqllib/db2cshrc ) source ${INSTHOME?}/sqllib/db2cshrc

" >> ${INSTHOME?}/.login 2>/dev/null
            if [ $? -ne 0 ]; then
        display_msg ${DB2CAT?} 768 \
                    'DBI1768W Unable to modify %s or %s for user %s.\n' \
                    ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc ${INSTNAME?} \
                    ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc
            fi
        fi
    fi

    if [ ${modprofile?} -eq ${FALSE?} -a ${modlogin?} -eq ${FALSE?} ]; then
        display_msg ${DB2CAT?} 768 \
            'DBI1768W Unable to modify %s or %s for user %s.\n' \
            ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc ${INSTNAME?} \
            ${INSTHOME?}/sqllib/db2profile ${INSTHOME?}/sqllib/db2cshrc
    fi
  
    trax modify_profile
}

#-----------------------------------------------------------------------
# Name       - clean_profile
# Function   - Modify the instance owner's profile by commenting out db2profile
# Parameters - None
#-----------------------------------------------------------------------
clean_profile()
{
    trac clean_profile $@
    set ${setopts?}

    unset tmpprofile tmplogin
    tmpprofile="/tmp/.db2.profile.backup"
    tmplogin="/tmp/.db2.login.backup"
    clnprofile=${FALSE?}
    clnlogin=${FALSE?}

    # Find out if the instance owner's home directory contains a .profile
    # file, and if this file contains the line .sqllib/profile.  If so, comment
    # out this line after a successful instance drop.  Do the same to the
    # .login file, this time commenting out the line source sqllib/db2cshrc
    # line.
    if [ -f ${INSTHOME?}/.profile -a -w ${INSTHOME?}/.profile ]; then
        clnprofile=${TRUE?}
        cat ${INSTHOME?}/.profile | \
            sed 's/^\(\. sqllib\/db2profile\)/\#\1/' \
            > ${tmpprofile?} 2>/dev/null
        if [ $? -ne 0 ]; then
            display_msg ${DB2CAT?} 769 \
                'DBI1769I Unable to remove DB2 profile entry from the .profile or the .login file of user %s.\n' ${INSTNAME?} 
        else
            cp ${tmpprofile?} ${INSTHOME?}/.profile
            rm -f ${tmpprofile?} 1>/dev/null 2>/dev/null
        fi
    fi

    if [ -f ${INSTHOME?}/.login -a -w ${INSTHOME?}/.login ]; then
        clnlogin=${TRUE?}
        cat ${INSTHOME?}/.login | \
            sed 's/^\(source sqllib\/db2cshrc\)/\#\1/' \
            > ${tmplogin?} 2>/dev/null
        if [ $? -ne 0 ]; then
            display_msg ${DB2CAT?} 769 \
                'DBI1769I Unable to remove DB2 profile entry from the .profile or the .login file of user %s.\n' ${INSTNAME?}
        else
            cp ${tmplogin?} ${INSTHOME?}/.login
            rm -f ${tmplogin?} 1>/dev/null 2>/dev/null
        fi
    fi

    if [ ${clnprofile?} -eq ${FALSE?} -a ${clnlogin?} -eq ${FALSE?} ]; then
        display_msg ${DB2CAT?} 769 \
            'DBI1769W Unable to remove DB2 profile entry from the .profile or the .login file of user %s.\n' ${INSTNAME?}
    fi

    trax clean_profile
}

setup_config_file()
{
    set ${setopts?}

}

clean_config_file ()
{
    set ${setopts?}

}

#-----------------------------------------------------------------------
# Name       - pre_iupdate
# Function   - Copy files and do things that need to be done before an update
# Parameters - None
#-----------------------------------------------------------------------
pre_iupdate()
{
    trac pre_iupdate $@
    set ${setopts?}

    # run db2licd -xxx if it exists and if required
    if [ ${INSTBLDLVL?} = ${CURBLDLVL?} -o ${DB2DIR?} != ${db2proddir?} ]; then
        if [ -f ${INSTHOME?}/sqllib/adm/db2licd ]; then
            ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/adm/db2licd -xxx"
        fi
    fi

###
    # Copy the new version of db2trc
    cp ${DB2DIR?}/adm/db2trc ${INSTHOME?}/sqllib/adm/db2trc \
               1>/dev/null 2>/dev/null
    chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/adm/db2trc
    mkpermission "u=rxs,g=rxs,o=x" ${INSTHOME?}/sqllib/adm/db2trc

    # Get rid of the temp file.
    if [ -f ${INSTHOME?}/sqllib/tmp/generate.spf ]; then
        rm -f ${INSTHOME?}/sqllib/tmp/generate.spf
    fi   

    trax pre_iupdate
}

pre_nrupdate()
{
    trac pre_nrupdate $@
    set ${setopts?}

    # run db2licd -xxx if it exists and if required
    if [ ${INSTBLDLVL?} = ${CURBLDLVL?} -o ${DB2DIR?} != ${db2proddir?} ]; then
        if [ -f ${INSTHOME?}/sqllib/adm/db2licd ]; then
            ${INSTHOME?}/sqllib/adm/db2licd -xxx
        fi
    fi

###

    # Get rid of the temp file.
    if [ -f ${INSTHOME?}/sqllib/tmp/generate.spf ]; then
        rm -f ${INSTHOME?}/sqllib/tmp/generate.spf
    fi   

    trax pre_nrupdate
}

# Initialize the instance update process
# Ensure that everthing is OK to update the instance
# Sets env variables DB2INSTVER, DB2IPRDDIR, and OLDSQLLIB.
init_iupdate()
{
    trac init_iupdate $@
    set ${setopts?}
    # Set the value of vars INSTHOME and INSTPGRP
    # and check their validity
    get_instance

    # Define special variables
    def_specials

    # check if this is root instance
    query_instuse ${INSTNAME?} "InstallerID" 0
    InstallerID="${INSTUSE_VALUE?}"
    if [ ${InstallerID?} -ne 0 ]; then
        display_msg ${DB2CAT?} 155 \
            'DBI1155E  The command failed for the DB2 non-root instance %s.\n' ${INSTNAME?}
        stop_prog 1
    fi

    # Get which version of DB2 in use by this instance
    chk_version ${INSTNAME?}
    DB2INSTVER=$?                 # DB2 version for the instance INSTNAME
    DB2IPRDDIR=${db2proddir?}     # Product dir of DB2 used by this instance

    # If the instance is not using the current version of DB2,
    # it cannot be updated
    if [ ${DB2INSTVER?} -ne ${DB2VER?} ]; then
        if [ ! -d ${INSTHOME?}/sqllib ]; then
           display_msg ${DB2CAT?} 147 \
               'DBI1147E db2iupdt failed to update the user ID .\n' ${INSTNAME?}
        else
           display_msg ${DB2CAT?} 122 \
            'DBI1122E Instance %s cannot be updated.\n' ${INSTNAME?}
        fi
        stop_prog 1
    fi

    # First check if we are updating an instance running against the current path
    # In that case set IUPDTDOWN to 0 as this will be the case when a FixPak in backed out.
    if [ ${INSTHOME?}/sqllib/.instuse ]; then   # file exists
        query_instuse_string ${INSTNAME?} DB2DIR ""
        UPINSTPATH=${INSTUSE_VALUE?}
        if [ "X${DB2DIR?}" = "X${UPINSTPATH?}" ]; then
            IUPDTDOWN=0
        fi
    fi

    get_bldlevel ${INSTHOME?}/sqllib/cfg
    INSTBLDLVL=${bldlvlvalue?}

    # Is it a downgrade scenario? If it is, is it allowed? 
    # If it's allowed, force user to pass -D / -f level
    if chk_vrmfis ${INSTNAME?}; then
       if chk_downgrade ${INSTNAME?}; then
           if [ ${IUPDTDOWN?} -ne 0 ]; then
               _stop_iupdate_D
           fi
       fi
    fi

    # Ensure that the AUTHTYPE value is valid
    chk_authtype

    # check bitwidth
    if [ ${BITWIDTH:-0} -eq 0 ]
    then
        # default to no-change.
        BITWIDTH=${INSTBITWIDTH?}
    fi

    # Issue an error message and exit if the sqllib/adm dir does not exist.
    if [ ! -d ${INSTHOME?}/sqllib/adm ] ; then
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' \
            ${INSTHOME?}/sqllib/adm
        stop_prog 1
    fi

    chk_itype
    INSTTYPE_ORIG=${INSTTYPE?}

    # Check if it's partitioned ese to non-ese
    chk_partitioned_ese_to_no_ese

    # check if it's instance owning node
    if [ ${FORCEDPF?} -ne 0 -a ${INSTTYPE?} -ne ${ITYPE_SD} ]; then
        chk_dpf ${INSTHOME?}
    fi

    # Verify FencedID info if a DB2 server is installed
    prepare_itype
    
    is_sd_copy
    if [ $? -eq ${TRUE?} ] && [ ${KEEPITYPE?} -eq ${FALSE?} ]
    then
        INSTTYPE=${ITYPE_SD?}
    fi
    
    if [ ${INSTTYPE?} -ne ${ITYPE_CLN?} ]; then
        verify_fencinfo
    fi

    # Run the pre_iupdate routine to copy over needed files before the update
    # starts.
    pre_iupdate

    # Stop DB2 ACS services
    db2_acs_stop_disable  ${INSTNAME?} "stop" "${DB2DIR?}" "${DB2DIR?}/instance/db2iupdt"

    # Set the env variable BAKDB2SYSTM and NEWDB2SYSTM
    NEWDB2SYSTM="${INSTHOME?}/sqllib/db2systm"              # New db2systm
    BAKDB2SYSTM="${SQLLIBBACKUP?}/${OLDDB2SYSTM?}"         # Backup db2systm

    # Set the instance profile variables.
    INSTPROF="${INSTHOME?}/sqllib/db2profile"     # db2profile for the instance
    EXT=`ls ${INSTPROF?}* | wc -l | awk '{ print \$1 }' 2> /dev/null`
    INSTPROFBAK="${INSTHOME?}/sqllib/db2profile.bak.${EXT?}"
    INSTCSHRC="${INSTHOME?}/sqllib/db2cshrc"      # db2cshrc for the instance
    EXT=`ls ${INSTCSHRC?}* | wc -l | awk '{ print \$1 }' 2> /dev/null`
    INSTCSHRCBAK="${INSTHOME?}/sqllib/db2cshrc.bak.${EXT?}"
    INSTENVPRO="${INSTHOME?}/sqllib/profile.env"      # profile.env for the instance
    INSTENVPROBAK="${INSTHOME?}/sqllib/backup_profile.env"

    if [ -f "${INSTENVPRO?}" ]; then
        cp -p "${INSTENVPRO?}" "${INSTENVPROBAK?}" >/dev/null 2>&1
        if [ $? -ne ${TRUE?} ] ; then
          stop_prog 1
        fi
    fi 

    # Backup all the instance specific files
    backup_instinfo ${SQLLIBBACKUP?}

    trax init_iupdate
}

init_nrupdate()
{
    trac init_nrupdate $@
    set ${setopts?}

    # Set the value of vars INSTHOME and INSTPGRP
    # and check their validity
    get_instance

    # Define special variables
    def_specials

    # Get which version of DB2 in use by this instance
    chk_version ${INSTNAME?}
    DB2INSTVER=$?                 # DB2 version for the instance INSTNAME
    DB2IPRDDIR=${db2proddir?}     # Product dir of DB2 used by this instance

    # If the instance is not using the current version of DB2,
    # it cannot be updated
    if [ ${DB2INSTVER?} -ne ${DB2VER?} ]; then
        if [ ! -d ${INSTHOME?}/sqllib ]; then
           display_msg ${DB2CAT?} 195 \
               'DBI1195E db2nrupdt failed to update the user %s.\n' ${INSTNAME?}
        else
           display_msg ${DB2CAT?} 122 \
            'DBI1122E Instance %s cannot be updated.\n' ${INSTNAME?}
        fi
        stop_prog 1
    fi

    # First check if we are updating an instance running against the current path
    # In that case set IUPDTDOWN to 0 as this will be the case when a FixPak in backed out.
    if [ ${INSTHOME?}/sqllib/.instuse ]; then   # file exists
        query_instuse_string ${INSTNAME?} DB2DIR ""
        UPINSTPATH=${INSTUSE_VALUE?}
        if [ "X${DB2DIR?}" = "X${UPINSTPATH?}" ]; then
            IUPDTDOWN=0
        fi
    fi

    get_bldlevel ${INSTHOME?}/sqllib/cfg
    INSTBLDLVL=${bldlvlvalue?}

    # Is it a downgrade scenario? If it is, is it allowed?
    # If it's allowed, force user to pass -D / -f level
    if chk_vrmfis ${INSTNAME?}; then
       if chk_downgrade ${INSTNAME?}; then
           if [ ${IUPDTDOWN?} -ne 0 ]; then
               _stop_iupdate_D
           fi
       fi
    fi

    # Ensure that the AUTHTYPE value is valid
    chk_authtype

    # check bitwidth
    if [ ${BITWIDTH:-0} -eq 0 ]
    then
        # default to no-change.
        BITWIDTH=${INSTBITWIDTH?}
    fi

    # Issue an error message and exit if the sqllib/adm dir does not exist.
    if [ ! -d ${INSTHOME?}/sqllib/adm ] ; then
        display_msg ${DB2CAT?} 81 \
            'DBI1081E The file or directory %s is missing.\n' \
            ${INSTHOME?}/sqllib/adm
        stop_prog 1
    fi

    chk_itype
    INSTTYPE_ORIG=${INSTTYPE?}

    # Verify FencedID info if a DB2 server is installed
    prepare_itype

    # Run the pre_iupdate routine to copy over needed files before the update
    # starts.
    pre_nrupdate

    # Set the env variable BAKDB2SYSTM and NEWDB2SYSTM
    NEWDB2SYSTM="${INSTHOME?}/sqllib/db2systm"              # New db2systm
    BAKDB2SYSTM="${SQLLIBBACKUP?}/${OLDDB2SYSTM?}"         # Backup db2systm

    # Set the instance profile variables.
    INSTPROF="${INSTHOME?}/sqllib/db2profile"     # db2profile for the instance
    EXT=`ls ${INSTPROF?}* | wc -l | awk '{ print \$1 }' 2> /dev/null`
    INSTPROFBAK="${INSTHOME?}/sqllib/db2profile.bak.${EXT?}"
    INSTCSHRC="${INSTHOME?}/sqllib/db2cshrc"      # db2cshrc for the instance
    EXT=`ls ${INSTCSHRC?}* | wc -l | awk '{ print \$1 }' 2> /dev/null`
    INSTCSHRCBAK="${INSTHOME?}/sqllib/db2cshrc.bak.${EXT?}"
    INSTENVPRO="${INSTHOME?}/sqllib/profile.env"      # profile.env for the instance
    INSTENVPROBAK="${INSTHOME?}/sqllib/backup_profile.env"

    # Backup all the instance specific files
    nr_backup_instinfo ${SQLLIBBACKUP?}

    trax init_nrupdate
}

update_profiles()
{
    trac update_profiles $@
    set ${setopts?}

    # backup our current profiles.
    mv "${INSTPROF?}" "${INSTPROFBAK?}"   >/dev/null 2>&1
    if [ $? -ne ${TRUE?} ] ; then
        stop_prog 1
    fi
    mv "${INSTCSHRC?}" "${INSTCSHRCBAK?}" >/dev/null 2>&1
    if [ $? -ne ${TRUE?} ] ; then
        stop_prog 1
    fi

    # remake them.
    make_profiles

    # have they changed?
    changed=`diff "${INSTPROF?}" "${INSTPROFBAK?}" | wc -l`
    if [ "${changed?}" -eq "0" ]; then
        dmsg "${INSTPROF?} has not changed."
        rm "${INSTPROFBAK?}"
    fi
    changed=`diff "${INSTCSHRC?}" "${INSTCSHRCBAK?}" | wc -l`
    if [ "${changed?}" -eq "0" ]; then
        dmsg "${INSTCSHRC?} has not changed."
        rm "${INSTCSHRCBAK?}"
    fi

    trax update_profiles
}

update_instance()
{
    trac update_instance $@
    set ${setopts?}

    status=${FALSE?}                  # Return code
    acs_exist=${FALSE?}
    # Check if sqllib/acs exists
    if [ -d ${INSTHOME?}/sqllib/acs ]; then
       acs_exist=${TRUE?}
    fi

    # If we pass this point, undo all changes if any error occurs
    UNDOCHG=${TRUE?}

    #Get the DB2 installation location in the original instance  
    db2dir_original=${DB2DIR?}
    if [ ${INSTHOME?}/sqllib/.instuse ]; then   # file exists
        query_instuse_string ${INSTNAME?} DB2DIR ""
        db2dir_original=${INSTUSE_VALUE?}
    fi

    itma_running ${INSTNAME?}
    is_itma_running=$?

    #stop itm agent for this instance if its original db2 copy has
    #itma installed and the original instance type is not client
    if [ -x ${db2dir_original?}/itma/bin/itmcmd ]; then
       if [ ${INSTTYPE_ORIG?} -ne ${ITYPE_CLN?} ]; then 
          if [ -d ${INSTHOME?}/sqllib/log ]; then
             db2itmalog="${INSTHOME?}/sqllib/log/${DB2ITMALOG?}"
             ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "date >> ${db2itmalog?}" 1>/dev/null 2>/dev/null
             if [ ${DEBUG?} -eq ${TRUE?} ]; then
                ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${db2dir_original?}/itma/bin/itmcmd \
                     agent -o ${INSTNAME?} stop ud 2>&1 | tee -a ${db2itmalog?}" 
             else
                 ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${db2dir_original?}/itma/bin/itmcmd \
                     agent -o ${INSTNAME?} stop ud 2>&1 | tee -a ${db2itmalog?}" 1>/dev/null 2>/dev/null
             fi
          else 
              ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${db2dir_original?}/itma/bin/itmcmd \
                     agent -o ${INSTNAME?} stop ud"
          fi
       fi 
    fi

    #remove instance needs to be done before sqllib change
    if [ ${db2dir_original?} != ${DB2DIR?} ]; then
        rm_instlist ${INSTNAME?} ${DB2VER?} ${db2dir_original?}
    fi

    # create the sqllib again, as new directories may now be available
    # or new permissions to be set (or reset)
    create_sqllib

    update_instuse ${INSTNAME?} "BitWidth" ${HIGHEST_BIT?}
    INSTBITWIDTH=${BITWIDTH?}
    # regenerate the dir names.

    # Remove the existing dbm cfg file
    rm -f ${NEWDB2SYSTM?}

    # Copy new DBM config file
    copy_dbmcfg
    if [ $? -ne ${TRUE?} ] ; then
        stop_prog 1
    fi

    # Check to see if the instance changed to a EEE instance
    chk_itype
    if [ ${INSTTYPE_ORIG?} -ne ${INSTTYPE?} ] && \
       [ ${INSTTYPE?} -eq ${ITYPE_EEE?} ] && \
       [ ! -f ${INSTHOME?}/sqllib/db2nodes.cfg ]; then
        make_db2nodes
    fi
    
    # from non-SD to SD needs db2nodes.cfg
    if [ ${INSTTYPE_ORIG?} -ne ${INSTTYPE?} ] && \
       [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] && \
       [ ! -f ${INSTHOME?}/sqllib/db2nodes.cfg ]; then
        make_db2nodes
    fi 

    # Update files in adm dir
    update_adm

    # Copy all the "setuid" programs to instance's sqllib dir
    copy_setuid

    # Merging of dbm cfg needed only for few opeartions.
    IS_MDBM_REQ=${TRUE?}

    #for instance update in purescale , installer  should not merge the dmcfg file
    if  [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] ; then
        IS_MDBM_REQ=${FALSE?}
    fi
    
    # we need  merge the dbmcfg file for the instance type convertion to purescale
    if [ ${INSTTYPE_ORIG?} -ne ${INSTTYPE?} ] &&  \
       [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] ; then
        IS_MDBM_REQ=${TRUE?}
    fi

    if [ ${IS_MDBM_REQ?} -eq ${TRUE?} ]; then
         # Update the new DBM cfg using info from the old db2systm
         ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2imdbm ${NEWDB2SYSTM?} \
                     ${BAKDB2SYSTM?} ${BITWIDTH?} ${ORIGBITWIDTH?} ${INSTNAME?}" 1>/dev/null 2>/dev/null
         rc=$?

         if [ ${rc?} -ne 0 ]; then
             if [ ${DEBUG?} -eq ${TRUE?} ]; then
                 dmsg "Return Code of dbm cfg merge = ${rc?}"
             fi
             # Restore the default dbm cfg file
             rm -f ${NEWDB2SYSTM?}
             copy_dbmcfg
             # Update the DBM config file
             updt_dbmcfg
             display_msg ${DB2CAT?} 282 \
                'DBI1282W The database manager configuration files could not be merged. \
                 The previous database manager configuration file is %s. \
                 The previous instance type is %s, and the current instance type is %s.\n' \
                 ${BAKDB2SYSTM?} `display_inst_type ${INSTTYPE_ORIG?}` `display_inst_type ${INSTTYPE?}`
         fi
    fi
    # Support for Content Extender Text Component
    if [ -d ${DB2DIR?}/db2ext -a -f ${DB2DIR?}/bin/db2text ]
    then
        create_db2ext
    fi

    # Copy all the License Support files
    copy_licsupp

    # Create FencedID Info file, if needed
    create_fencinfo

    # Set up admin server group list"
    setup_das_groups

    # Ensure db2profile/db2cshrc are updated.
    update_profiles

    # Update the instance for all DB2 functions (OLAP etc) that
    # it had been set up for.
    update_instftn

    # Create .ftok file if it does not exist already
    if [ ! -f ${INSTHOME?}/sqllib/.ftok -a ! -h ${INSTHOME?}/sqllib/.ftok ]; then
        rm -f ${INSTHOME?}/sqllib/.ftok 2> /dev/null
        if [ -f ${INSTHOME?}/sqllib/bin/db2ftok ]; then
            ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2ftok"
        fi
    fi
    if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]
    then
       if [ -h ${INSTHOME?}/sqllib/.ftok -a -f ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/.ftok ]
       then
          rm -f ${INSTHOME?}/sqllib/.ftok 2> /dev/null
          cp -p ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared/.ftok ${INSTHOME?}/sqllib/.ftok
       fi
    fi

    _update_instuse

    # Support for the DB2 Text Search component (TEXT_SEARCH)
    tssHome="${INSTHOME?}/sqllib/db2tss"
    if [ ${DEBUG?} -eq ${TRUE?} ]; then
       DEBUGFLAG="-d";
    else
       DEBUGFLAG="";
    fi

    # db2tss update is required 
    IS_DB2TS_REQ=${TRUE?}

    #for instance update in purescale, installer  should not update db2ts
    if [ ${INSTTYPE_ORIG?} -ne ${INSTTYPE?} ] &&  \
       [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] ; then
        IS_DB2TS_REQ=${FALSE?}
    fi

    if [ -f ${DB2DIR?}/bin/db2ts ] && [ ${IS_DB2TS_REQ?} -eq ${TRUE?} ]; then
        if [ -d ${tssHome?} ]; then
           ## check to see if text search was configured or not
           ## if not, then do nothing
           ## if yes, then check if the text search instance services are running & stop them
           ## if we stopped text search, start it again at the end, otherwise do nothing

##           if [ ${DEBUG?} -eq ${TRUE?} ]; then
##              ${DB2DIR?}/instance/db2ickts -d -k ${INSTNAME?}
##           else 
##              ${DB2DIR?}/instance/db2ickts -s ${INSTNAME?}
##           fi 
           ${DB2DIR?}/instance/db2ickts ${DEBUGFLAG?} -k ${INSTNAME?}

           if [ $? -eq 0 ]; then
##              if [ ${DEBUG?} -eq ${TRUE?} ]; then
##                 ${DB2DIR?}/instance/db2ickts -d -t ${INSTNAME?}
##              else
##                 ${DB2DIR?}/instance/db2ickts -t ${INSTNAME?}
##              fi
              ${DB2DIR?}/instance/db2ickts ${DEBUGFLAG?} -t ${INSTNAME?}

              if [ $? -eq 0 ]; then
##                 if [ ${DEBUG?} -eq ${TRUE?} ]; then
##                    ${DB2DIR?}/instance/db2ickts -d -s ${INSTNAME?}
##                 else
##                    ${DB2DIR?}/instance/db2ickts -s ${INSTNAME?}
##                 fi
                   ${DB2DIR?}/instance/db2ickts ${DEBUGFLAG?} -s ${INSTNAME?}
                   westoppedtextsearch=${TRUE?}
              else
                 westoppedtextsearch=${FALSE?}
              fi

              ${DB2DIR?}/instance/db2ickts ${DEBUGFLAG?} -t ${INSTNAME?}

              update_db2tss
              output1=`${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${tssHome?}/bin/configTool configureParams -configPath ${tssHome?}/config -installPath ${DB2DIR?}/db2tss 2>&1"`
              if [ ${DEBUG?} -eq ${TRUE?} ]; then
                 dmsg "${output1?}"
              fi
              if [ ${westoppedtextsearch?} -eq ${TRUE?} ]; then
                 output2=`${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "db2ts start for text"`
                 if [ ${DEBUG?} -eq ${TRUE?} ]; then
                    dmsg "${output2?}"
                 fi
              fi
           else
              ## Update db2tss links even when text search isn't configured since they may still be pointing to the old install path.
              update_db2tss
           fi
        else
           create_db2tss
        fi
    else
        if [ -d ${tssHome?} ]; then
           rm -rf ${INSTHOME?}/sqllib/db2tss >/dev/null 2>&1
        fi
    fi

    if [ -f ${INSTHOME?}/sqllib/cfg/SSLconfig.ini ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/SSLconfig.ini
        mkpermission "u=r,go=" ${INSTHOME?}/sqllib/cfg/SSLconfig.ini
    fi

    if [ -f ${INSTHOME?}/sqllib/cfg/SSLconfig.ini ]; then
        chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/sqllib/cfg/SSLconfig.ini
        mkpermission "u=r,go=" ${INSTHOME?}/sqllib/cfg/SSLconfig.ini
    fi

    if [ ${db2dir_original?} != ${DB2DIR?} ]; then
        add_instlist ${INSTNAME?} ${DB2VER?}
        cleanup_old_links ${INSTHOME?}/sqllib/function ${db2dir_original?}
    else
        # register this instance as being updated
        ${DB2DIR?}/bin/db2greg -updinstrec service=DB2,instancename=${INSTNAME?}
    fi
    if [ -f ${INSTENVPROBAK?} ]; then
        rm -f ${INSTENVPRO?}
        mv ${INSTENVPROBAK?} ${INSTENVPRO?}
        if [ $? -ne ${TRUE?} ] ; then
           stop_prog 1
        fi
    fi
    if [ -f ${INSTENVPRO?} ]; then
        chgowngrp ${INSTNAME?} ${INSTPGRP?} ${INSTENVPRO?}
        mkpermission "ug=rw,o=r" ${INSTENVPRO?}
    fi

    ${DB2DIR?}/bin/db2greg -updinstrec instancename=${INSTNAME?}
    # Mark the instance as no longer in maintenance.
    ${DB2DIR?}/bin/db2greg -updinstrec "instancename=${INSTNAME?}!maintenance=0"

    # Update DB2 ACS files
    update_acs ${db2dir_original?} "update" ${acs_exist?}

    # Update itma cfg file for the instance
    if [ ${db2dir_original?} != ${DB2DIR?} ]; then
       itma_updatecfg r ${INSTNAME?} ${db2dir_original?} 
    fi
    itma_updatecfg a ${INSTNAME?} ${DB2DIR?}

    # call db2addicons to add/update DB2 desktop entries for the instance
    if [ -f ${INSTHOME?}/sqllib/bin/db2addicons ]; then
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/bin/db2addicons" 1>/dev/null 2>/dev/null
    fi
    
    # If the itma agent was running before the instance update, we now need to restart it if applicable
    if [ -x ${DB2DIR?}/itma/bin/itmcmd ]; then
       if [ ${INSTTYPE?} -ne ${ITYPE_CLN?} -a ${is_itma_running?} -eq ${TRUE?} ]; then 
          if [ -d ${INSTHOME?}/sqllib/log ]; then
             db2itmalog="${INSTHOME?}/sqllib/log/${DB2ITMALOG?}"
             ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "date >> ${db2itmalog?}" 1>/dev/null 2>/dev/null
             if [ ${DEBUG?} -eq ${TRUE?} ]; then
                ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/itma/bin/itmcmd \
                    agent -o ${INSTNAME?} start ud 2>&1 | tee -a ${db2itmalog?}"
             else
                 ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/itma/bin/itmcmd \
                     agent -o ${INSTNAME?} start ud 2>&1 | tee -a ${db2itmalog?}" 1>/dev/null 2>/dev/null
             fi
          else 
             ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "${INSTHOME?}/sqllib/itma/bin/itmcmd agent -o ${INSTNAME?} start ud"
          fi
       fi 
    fi

    is_dpf ${instname?} ${db2ver?}

    if [ $? -eq ${TRUE?} -a -f ${INSTHOME?}/sqllib/adm/db2iclean ]; then
      clean_dpf_log_dir
      ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/bin/rah \"${INSTHOME?}/sqllib/adm/db2iclean -di 2>&1 1>/dev/null \" 2>&1 1>/dev/null"
      clean_dpf_log_dir
      ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/adm/db2iclean -a 2>&1 1>/dev/null"
      clean_dpf_log_dir
       ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "${INSTHOME?}/sqllib/bin/rah \"${INSTHOME?}/sqllib/adm/db2iclean -a 2>&1 1>/dev/null \" 2>&1 1>/dev/null"

      dpf_log_dir="${INSTHOME?}/sqllib/ctrl/.cleandpf"
      if [ -d ${dpf_log_dir?} ]; then
        rm -rf ${dpf_log_dir?}
      fi
    fi

    setup_dsf

    # note that this may modify the new db2 COPY,  as per PCR068082.
    handle_gskit_symlink ${db2dir_original?} 32
    handle_gskit_symlink ${db2dir_original?} 64

    trax update_instance
}

nr_update_instance()
{
    trac nr_update_instance $@
    set ${setopts?}
    MOUNTPOINT1=$1
    NFSMOUNT=$2

    status=${FALSE?}                  # Return code

    # If we pass this point, undo all changes if any error occurs
    UNDOCHG=${TRUE?}

    #Get the DB2 installation location in the original instance  
    db2dir_original=${DB2DIR?}
    if [ ${INSTHOME?}/sqllib/.instuse ]; then   # file exists
        query_instuse_string ${INSTNAME?} DB2DIR ""
        db2dir_original=${INSTUSE_VALUE?}
    fi

    update_instuse ${INSTNAME?} "BitWidth" ${HIGHEST_BIT?}
    INSTBITWIDTH=${BITWIDTH?}
    # regenerate the dir names.

    # Remove the existing dbm cfg file
    rm -f ${NEWDB2SYSTM?}

    # Copy new DBM config file
    nr_copy_dbmcfg
    if [ $? -ne ${TRUE?} ] ; then
        stop_prog 1
    fi

    # Check to see if the instance changed to a EEE instance
    chk_itype
    if [ ${INSTTYPE_ORIG?} -ne ${INSTTYPE?} ] && \
       [ ${INSTTYPE?} -eq ${ITYPE_EEE?} ] && \
       [ ! -f ${INSTHOME?}/sqllib/db2nodes.cfg ]; then
        nr_make_db2nodes
    fi 

    if [ -f ${DB2LOCAL?}/.mount ]; then 
       updt_local_install ${INSTNAME?} ${MOUNTPOINT1?}
    fi

    # create the sqllib again, as new directories may now be available
    # or new permissions to be set (or reset)
    nr_create_sqllib

    #mkpermission -R "ug+x" ${INSTHOME?}/sqllib/adm

    # Call db2iuadm_nr to sets permissions for all files in the
    # adm directory
    ${DB2DIR?}/instance/db2iuadm_nr ${INSTHOME?}/sqllib ${INSTNAME?} ${INSTPGRP?} \
             ${INSTNAME?} ${INSTPGRP} ${INSTTYPE?} "set" ${setopts?}

    # Copy all the "setuid" programs to instance's sqllib dir
    nr_copy_setuid

    # Update the new DBM cfg using info from the old db2systm
    ${INSTHOME?}/sqllib/bin/db2imdbm ${NEWDB2SYSTM?} \
           ${BAKDB2SYSTM?} ${BITWIDTH?} ${ORIGBITWIDTH?} ${INSTNAME?} 1>/dev/null 2>/dev/null
    rc=$?

    if [ ${rc?} -ne 0 ]; then
        # dbm cfg merge failed. Restore the file backed up in sqllib/backup
        cp -f ${BAKDB2SYSTM?} ${NEWDB2SYSTM?}
        # In a non-root install, there is no reason to update the dbm cfg
        # since they are already up to date.
        if [ ${DEBUG?} -eq ${TRUE?} ]; then
            dmsg "Return Code of dbm cfg merge = ${rc?}"
        fi
    fi
    
    # Update DBM cfg parameter JDK_PATH
    JDKPATH=`${INSTHOME?}/sqllib/bin/db2jdkp`
    db2 "update database manager configuration using JDK_PATH '${JDKPATH?}'" 1>/dev/null 2>/dev/null

    # Copy all the License Support files
    nr_copy_licsupp

    # Ensure db2profile/db2cshrc are updated.
    update_profiles
    # Create the install "db2rfe.cfg" file
    make_db2rfe_cfg

    # Update the instance for all DB2 functions (OLAP etc) that
    # it had been set up for.
    update_instftn

    # Create .ftok file if it does not exist already
    if [ ! -f ${INSTHOME?}/sqllib/.ftok -a ! -h ${INSTHOME?}/sqllib/.ftok ]; then
        rm -f ${INSTHOME?}/sqllib/.ftok 2> /dev/null
        if [ -f ${INSTHOME?}/sqllib/bin/db2ftok ]; then
            ${INSTHOME?}/sqllib/bin/db2ftok
        fi
    fi

    # register this instance as being updated
    ${DB2DIR?}/bin/db2greg -updinstrec service=DB2,instancename=${INSTNAME?}
    _update_instuse

    tssHome="${INSTHOME?}/sqllib/db2tss"
    # Support for the DB2 Text Search component (TEXT_SEARCH)
    if [ -f ${DB2DIR?}/bin/db2ts ]
    then
        create_db2tss
    else
        if [ -d ${INSTHOME?}/sqllib/db2tss ]; then
           rm -rf ${INSTHOME?}/sqllib/db2tss >/dev/null 2>&1
        fi
    fi

    if [ -f ${INSTENVPROBAK?} ]; then
        rm -f ${INSTENVPRO?}
        mv ${INSTENVPROBAK?} ${INSTENVPRO?}
        if [ $? -ne ${TRUE?} ] ; then
           stop_prog 1
        fi
    fi
    if [ -f ${INSTENVPRO?} ]; then
        mkpermission "ug=rw,o=r" ${INSTENVPRO?}
    fi
    
    # call db2addicons to add/update DB2 desktop entries for the instance
    if [ -f ${INSTHOME?}/sqllib/bin/db2addicons ]; then
        ${INSTHOME?}/sqllib/bin/db2addicons 1>/dev/null 2>/dev/null
    fi
    
    trax nr_update_instance
}

# undo_chg - Undo all necessary changes before exiting
undo_chg ()
{
    trac undo_chg $@
    set ${setopts?}

    # If undo is false, do nothing
    if [ ${UNDOCHG?} -eq ${FALSE?} ]; then
        return ${TRUE?}
    fi

    case ${PROGNAME?} in
        db2icrt_local)
            # If KEEPSQLLIB is false, remove sqllib dir and
            # remove instance's name from the list
            if [ ${KEEPSQLLIB?} -eq ${FALSE?} ]; then
                rm_instlist ${INSTNAME?} ${DB2VER?}
                rm -rf ${INSTHOME?}/sqllib
            fi ;;
        db2nrcfg)
            # If KEEPSQLLIB is false, remove sqllib dir and
            # remove instance's name from the list
            if [ ${KEEPSQLLIB?} -eq ${FALSE?} ]; then
                rm_instlist ${INSTNAME?} ${DB2VER?}
            fi ;;
        db2iupdt_local)
            # Keep the old db2systm file
            if [ -f ${BAKDB2SYSTM?} ]; then
                rm -f ${NEWDB2SYSTM?}
                cp ${BAKDB2SYSTM?} ${NEWDB2SYSTM?}
                chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${NEWDB2SYSTM?}
                mkpermission "ug=rw,o=r" ${NEWDB2SYSTM?}
            fi
            # Keep the old db2profile/db2cshrc
            if [ -f ${INSTPROFBAK?} ]; then
                rm -f ${INSTPROF?}
                mv ${INSTPROFBAK?} ${INSTPROF?}
            fi
            if [ -f ${INSTCSHRCBAK?} ]; then
                rm -f ${INSTCSHRC?}
                mv ${INSTCSHRCBAK?} ${INSTCSHRC?}
            fi
            if [ -f ${INSTENVPROBAK?} -a -f ${INSTENVPRO?} ]; then
                rm -f ${INSTENVPRO?}
                mv ${INSTENVPROBAK?} ${INSTENVPRO?}
                chgowngrp ${INSTNAME?} ${INSTPGRP?} ${INSTENVPRO?}
                mkpermission "ug=rw,o=r" ${INSTENVPRO?}
            fi
            # Add instance back to old version's list
            chk_instlist ${INSTNAME?} ${DB2INSTVER?} ${DB2IPRDDIR?} 
            if [ $? -eq ${FALSE?} ]; then
                add_instlist ${INSTNAME?} ${DB2INSTVER?} ${INSTTYPE_ORIG?} ${DB2IPRDDIR?}
            fi
            ;;
        db2nrupdt)
            # Keep the old db2systm file
            if [ -f ${BAKDB2SYSTM?} ]; then
                rm -f ${NEWDB2SYSTM?}
                cp ${BAKDB2SYSTM?} ${NEWDB2SYSTM?}
                mkpermission "ug=rw,o=r" ${NEWDB2SYSTM?}
            fi
            # Keep the old db2profile/db2cshrc
            if [ -f ${INSTPROFBAK?} ]; then
                rm -f ${INSTPROF?}
                mv ${INSTPROFBAK?} ${INSTPROF?}
            fi
            if [ -f ${INSTCSHRCBAK?} ]; then
                rm -f ${INSTCSHRC?}
                mv ${INSTCSHRCBAK?} ${INSTCSHRC?}
            fi
            if [ -f ${INSTENVPROBAK?} -a -f ${INSTENVPRO?} ]; then
                rm -f ${INSTENVPRO?}
                mv ${INSTENVPROBAK?} ${INSTENVPRO?}
                mkpermission "ug=rw,o=r" ${INSTENVPRO?}
            fi
            ;;
        db2iupgrade_local)
            if [ -d ${INSTHOME?}/${OLDSQLLIB?} ] ; then
                if [ -d ${INSTHOME?}/sqllib ] ; then
                    # If instance is added to the list, remove it
                    chk_instlist ${INSTNAME?} ${DB2VER?}
                    if [ $? -eq ${TRUE?} ]; then
                        rm_instlist ${INSTNAME?} ${DB2VER?}
                    fi
                    rm -rf ${INSTHOME?}/sqllib
                fi
                mv ${INSTHOME?}/${OLDSQLLIB?} ${INSTHOME?}/sqllib
            fi

            # Keep the old profile.env file
            if [ -f ${INSTENVPROBAK?} ]; then
               rm -f ${INSTENVPROBAK?}
            fi
            if [ -f ${INSTENVPRO?} ]; then
               cp ${INSTENVPRO?} ${INSTENVPROBAK?}
            fi
            if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ] && [ ${IS_FIRST_HOST?} -eq ${TRUE?} ]; then
                if [ -d ${SD_INSTPROF?}/${INSTNAME?}/${OLDSQLLIBSHARED?} ] ; then
                    if [ -d ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared ] ; then
                        rm -rf ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared
                    fi
                    mv ${SD_INSTPROF?}/${INSTNAME?}/${OLDSQLLIBSHARED?}  ${SD_INSTPROF?}/${INSTNAME?}/sqllib_shared
                fi
            fi
            
            # Add instance back to old version's list
            chk_instlist ${INSTNAME?} ${DB2INSTVER?} ${DB2IPRDDIR?} 
            if [ $? -eq ${FALSE?} ]; then
                add_instlist ${INSTNAME?} ${DB2INSTVER?} ${INSTTYPE?} ${DB2IPRDDIR?}
            fi

            # Restore the profile.env file which has been deleted by db2iset -d
            if [ -f ${INSTENVPROBAK?} ]; then
               mv ${INSTENVPROBAK?} ${INSTENVPRO?}
            fi

            # Add icons back for Linux if upgrade was tried from V8 
            if [ "X${OLDSQLLIB?}" = "Xsqllib_v81" -a -x ${DB2IPRDDIR?}/bin/db2icons ]; then
                 ${DB2IPRDDIR?}/instance/db2iexec -n ${INSTNAME?} "${DB2IPRDDIR?}/bin/db2icons \
                      ${INSTNAME?}" 1>/dev/null 2>/dev/null
            fi
            
            ;;
    esac

    trax undo_chg
}

# Defined special variable which are shared by
# more than one program/script
def_specials ()
{
    set ${setopts?}

    # setup the current bldlevel
    get_bldlevel ${DB2DIR?}/cfg
    CURBLDLVL=${bldlvlvalue?}

    # Initialize variable for valid command names
    # Special variables needed to stop or drop instance
    EXIT_APPL_ACTIVE=10
    EXIT_SRV_MISSING=20

    # Backup dir name under sqllib
    BAKDIRNAME="backup"

    # Dir sqllib/backup
    SQLLIBBACKUP="${INSTHOME?}/sqllib/${BAKDIRNAME?}"

    # Backup/old files
    OLDDB2SYSTM="db2systm.old"      # Old db2systm file
    OLDDB2PROFILE="db2profile.old"  # Old db2profile
    OLDDB2CSHRC="db2cshrc.old"      # Old db2cshrc
    LSTDBDIR="dbdir.lst"            # List sys db dir
    LSTNODEDIR="nodedir.lst"        # List node dir
    LSTDCSDIR="dcsdir.lst"          # List dcs gateway dir
    LSTDBMCFG="dbmcfg.lst"          # List dbm cfg file
    LOGDIRMIGR="dirmigr.log"        # Log of dir upgrade
}

# Variables to identify the instance type (client, server, EEE, etc..)
ITYPE_EEE=1           # Instance type for EEE instance
ITYPE_DAS=2           # Instance type for DAS
ITYPE_SRV=3           # Instance type for server instance
ITYPE_CLN=4           # Instance type for client instance
ITYPE_DLN=5           # Instance type for DataLinker
ITYPE_PER=6           # Instance type for standalone requestor (PE)
ITYPE_SD=7            # Instance type for Shared Database (SD)
ITYPE_UNK=10          # Instance type is unknown

display_inst_type ()
{
    case $# in
    0)
        echo "unknown"
    ;;
    *)
        case $1 in
        ${ITYPE_SD?})
            echo "ese_dsf"
        ;;
        ${ITYPE_EEE?})
            echo "ese"
        ;;
        ${ITYPE_DAS?})
            echo "das"
        ;;
        ${ITYPE_SRV?})
            echo "wse"
        ;;
        ${ITYPE_CLN?})
            echo "client"
        ;;
        ${ITYPE_DLN?})
            echo "datalink"
        ;;
        ${ITYPE_PER?})
            echo "standalone"
        ;;
        *)
            echo "unknown"
        ;;
        esac
    esac
}

log_instance_activity ()
{
    INSTHOME=${INSTHOME:=""}
    log_finished=${log_finished:="X"}

    if [ ! -n "${INSTHOME?}" -o ! -d ${INSTHOME?}/sqllib/log ]; then
        return 0
    fi

    final_rc="$1"
    msg="$2"
    instance_log="${INSTHOME?}/sqllib/log/instance.log"

    if [ ${log_finished?} = ${instance_log?} ]; then
        return 0
    fi

    query_instuse_string ${INSTNAME?} V ""
    ver=${INSTUSE_VALUE?}
    query_instuse_string ${INSTNAME?} R ""
    rel=${INSTUSE_VALUE?}
    query_instuse_string ${INSTNAME?} M ""
    mod=${INSTUSE_VALUE?}
    query_instuse_string ${INSTNAME?} F ""
    fix=${INSTUSE_VALUE?}
    query_instuse_string ${INSTNAME?} I ""
    int=${INSTUSE_VALUE?}
    query_instuse_string ${INSTNAME?} S ""
    ins=${INSTUSE_VALUE?}
    query_instuse_string ${INSTNAME?} SpecialBuild ""
    bld=${INSTUSE_VALUE?}
    lvl=`cat ${INSTHOME?}/sqllib/cfg/bldlevel`

    PROGARGS=${PROGARGS:=""}
    full_cmd="${PROGDIR?}/${PROGNAME?} ${PROGARGS?}"
    head_line="------------------------------------------------------------"
    date_line="Date::`date +'%x %A %X %Z'`"
    host_line="Host::`hostname`"
    cmd_line="Command::${full_cmd?}"
    insttype_line="Insttype::${INSTTYPE?}"
    level_line="Level::VRMF=${ver?}.${rel?}.${mod?}.${fix?},Interim=${int?},SpecialInstall=${ins?},SpecialBuild=${bld?},bld_level=${lvl?}"
    msg_line="Message::${msg?}"
    rc_line="ReturnCode::${final_rc?}"

    if [ `${DB2DIR?}/bin/db2usrinf -E` -eq 0 ]; then
        if [ ! -f ${instance_log?} ]; then
            ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "touch ${instance_log?}"
        fi
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${head_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${date_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${host_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${cmd_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${insttype_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${level_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${msg_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${rc_line?} >> ${instance_log?}"
        ${DB2DIR?}/instance/db2iexec -n ${INSTNAME?} "echo ${head_line?} >> ${instance_log?}"
    else
        if [ ! -f ${instance_log?} ]; then
            touch ${instance_log?}
        fi
        echo ${head_line?} >> ${instance_log?}
        echo ${date_line?} >> ${instance_log?}
        echo ${host_line?} >> ${instance_log?}
        echo ${cmd_line?} >> ${instance_log?}
        echo ${insttype_line?} >> ${instance_log?}
        echo ${level_line?} >> ${instance_log?}
        echo ${msg_line?} >> ${instance_log?}
        echo ${rc_line?} >> ${instance_log?}
        echo ${head_line?} >> ${instance_log?}
    fi
        
    log_finished=${instance_log?}
}
#--------------------------------------------------------------------------
# Name          - set_sd_instprof
# Function      - Initializes the INSTPROF variable.  If instance name is passed then
#               attempts to retrieve value for the specific instance otherwise
#               assigns the default INSTPROF global reg variable value.
#
# Parameters    - InstanceName[GA ONLY and optional]
#
# Returns       - TRUE if successful
#                 FALSE otherwise
#--------------------------------------------------------------------------
set_sd_instprof ()
{
   trac set_sd_instprof $@
   set ${setopts?}
   set_sd_instprof_rc=${TRUE?}
    
   #Try to get INSTNAME global reg variable
   if [ "X${INSTNAME?}" != "X" ]
   then
      SD_INSTPROF=`${DB2DIR?}/bin/db2greg -getvarrec service=INSTPROF,variable=${INSTNAME?},installpath=- | grep "^[ ]*Value[ ]*=" | awk -F'|' '{print $2}' 2>/dev/null`
      if [ "X${SD_INSTPROF?}" = "X" ]
      then
         #Default global reg variable for INSTPROF
         SD_INSTPROF=`${DB2DIR?}/bin/db2greg -getvarrec service=DEFAULT_INSTPROF,variable=DEFAULT,installpath=- | grep "^[ ]*Value[ ]*=" | awk -F'|' '{print $2}' 2>/dev/null`
         if [ "X${SD_INSTPROF?}" = "X" ]
         then
            set_sd_instprof_rc=${FALSE?}           
         fi
      fi
   else
      set_sd_instprof_rc=${FALSE?}
   fi
    
   trax set_sd_instprof
   return ${set_sd_instprof_rc?}
}
#--------------------------------------------------------------------------
# Name          - is_sd_instance
# Function      - Checks whether this DB2 Copy is SD and user wants to 
#                 create SD Instance.  This is only used when instance is not 
#                 created.  If there is instance, we must use .instuse to check.
#
# Parameters    - None
#
# Returns       - TRUE if successful
#                 FALSE otherwise
#--------------------------------------------------------------------------
is_sd_instance()
{
   is_sd_instance_rc=${TRUE?}
   is_sd_copy
   
   if [ $? -ne ${TRUE?} ]; then
      is_sd_instance_rc=${FALSE?}
   elif [ "X${CFGFILETYPE?}" != "XDSF" -a "X${CFGFILETYPE?}" != "Xdsf" -a "X${CFGFILETYPE?}" != "X" ]; then
      is_sd_instance_rc=${FALSE?}
   fi
   
   return ${is_sd_instance_rc?}
}
#--------------------------------------------------------------------------
# Name          - is_sd_copy
# Function      - Checks whether this DB2 Copy is SD or not.  It uses db2sd.lvl 
#                 to make the decision.
#
# Parameters    - None
#
# Returns       - TRUE if successful
#                 FALSE otherwise
#--------------------------------------------------------------------------
is_sd_copy ()
{
   trac is_sd_copy $@
   set ${setopts?}
    
   is_sd_copy_rc=${FALSE?}
   if [ -f ${DB2DIR?}/.metadata/CF/spec ]
   then
      is_sd_copy_rc=${TRUE?}
   else
      is_sd_copy_rc=${FALSE?}
   fi
   trax is_sd_copy
   return ${is_sd_copy_rc?}
}

#--------------------------------------------------------------------------
# Name          - set_ssh_pub_key
# Function      - Creates public ssh key 
#
# Parameters    - None
#
# Returns       - TRUE if successful
#                 FALSE otherwise
#--------------------------------------------------------------------------
set_ssh_pub_key()
{
   trac set_ssh_pub_key $@
   
   if [ ! -d ${INSTHOME?}/.ssh ]; then
      mkdir ${INSTHOME?}/.ssh
   fi
   
   chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/.ssh
   mkpermission "u=rwx,go=rx" ${INSTHOME?}/.ssh
   
   if [ ! -f ${INSTHOME?}/.ssh/id_rsa ]; then
      ${DB2DIR?}/instance/db2iexec ${INSTNAME?} "ssh-keygen -b 2048 -t rsa -f ${INSTHOME?}/.ssh/id_rsa -N \"\"" 2>&1 1>/dev/null
   fi
   
   line=`cat ${INSTHOME?}/.ssh/id_rsa.pub`
   grep -- "${line?}" ${SD_INSTPROF?}/${INSTNAME?}/.ssh/authorized_keys 2>&1 1>/dev/null
   if [ $? -ne ${TRUE?} ]; then
      lock ${SD_INSTPROF?}/${INSTNAME?}/.ssh/authorized_keys.lock 30
         echo "${line?}" >> ${SD_INSTPROF?}/${INSTNAME?}/.ssh/authorized_keys
      unlock ${SD_INSTPROF?}/${INSTNAME?}/.ssh/authorized_keys.lock
   fi
   
   if [ ! -f ${INSTHOME?}/.ssh/authorized_keys ]; then
      touch ${INSTHOME?}/.ssh/authorized_keys
   fi
   chg_owngrp ${INSTNAME?} ${INSTPGRP?} ${INSTHOME?}/.ssh/authorized_keys
   mkpermission "u=rw,go=r" ${INSTHOME?}/.ssh/authorized_keys
   
   trax set_ssh_pub_key
   return ${TRUE?}
}

#--------------------------------------------------------------------------
# Name          - set_ssh_pub_key_user
# Function      - Creates public ssh key for the user specified
#
# Parameters    - USERNAME
#                 USERGROUP
#
# Returns       - TRUE if successful
#                 FALSE otherwise
#--------------------------------------------------------------------------
set_ssh_pub_key_user()
{
   trac set_ssh_pub_key_user $@

   username=$1
   USERGROUP=$2

   if [ "X${username?}" = "X" ] || [ "X${USERGROUP?}" = "X" ]
   then
      dmsg "Usage: set_ssh_pub_key_user <USERNAME> <USERGROUP>"
      trax set_ssh_pub_key_user
      return ${FALSE?}
   fi

   USERHOME=`${DB2DIR?}/bin/db2usrinf -d ${username?}`
   
   if [ ! -d ${USERHOME?}/.ssh ]; then
      mkdir ${USERHOME?}/.ssh
   fi
   
   chg_owngrp ${username?} ${USERGROUP?} ${USERHOME?}/.ssh
   mkpermission "u=rwx,go=rx" ${USERHOME?}/.ssh
   
   if [ ! -f ${USERHOME?}/.ssh/id_rsa ]; then
      ${DB2DIR?}/instance/db2iexec ${username?} "ssh-keygen -b 2048 -t rsa -f ${USERHOME?}/.ssh/id_rsa -N \"\"" 2>&1 1>/dev/null
   fi
   
   line=`cat ${USERHOME?}/.ssh/id_rsa.pub`
   grep -- "${line?}" ${SD_INSTPROF?}/${username?}/.ssh/authorized_keys 2>&1 1>/dev/null
   if [ $? -ne ${TRUE?} ]; then
      lock ${SD_INSTPROF?}/${username?}/.ssh/authorized_keys.lock 30
         echo "${line?}" >> ${SD_INSTPROF?}/${username?}/.ssh/authorized_keys
      unlock ${SD_INSTPROF?}/${username?}/.ssh/authorized_keys.lock
   fi
   
   if [ ! -f ${USERHOME?}/.ssh/authorized_keys ]; then
      touch ${USERHOME?}/.ssh/authorized_keys
   fi
   chg_owngrp ${username?} ${USERGROUP?} ${USERHOME?}/.ssh/authorized_keys
   mkpermission "u=rw,go=r" ${USERHOME?}/.ssh/authorized_keys
   
   trax set_ssh_pub_key_user
   return ${TRUE?}
}

#--------------------------------------------------------------------------
# Name          - lock
# Function      - Creates a mutex lock
#
# Parameters    - $1 Lock directory
#                 $2 Timeout value in seconds (default is 10sec)
#
# Returns       - TRUE
#--------------------------------------------------------------------------
lock ()
{
   lockdir=$1       # mutex lock directory
   timeout=${2:-10} # default timeout 10sec

   until mkdir -m 755 "${lockdir?}" 2>/dev/null
   do
      sleep 1
      timeout=`expr ${timeout?} - 1`
      if [ ${timeout?} -lt 1 ]; then
         break
      fi
   done

   touch "${lockdir?}/$$"
   return ${TRUE?}
}

#--------------------------------------------------------------------------
# Name          - unlock
# Function      - Removes a mutex lock
#
# Parameters    - $1 Lock directory
#
# Returns       - TRUE
#--------------------------------------------------------------------------
unlock ()
{
   lockdir=$1       # mutex lock directory
   if [ -f "${lockdir?}/$$" ]; then
      rm -rf "${lockdir?}"
   fi

   return ${TRUE?}
}

setup_dsf()
{
    #Update the shared files for SD Instance
    if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]
    then
       set_shared_files ${DB2DIR?}/instance/sdSharedFileList ${PROGNAME?}
    fi

    initial_setup=${FALSE?}

    if [ ${PROGNAME?} = "db2iupdt_local" ]; then
        if [ ${INSTTYPE_ORIG?} -ne ${INSTTYPE?} -a ${INSTTYPE?} -eq ${ITYPE_SD?} ]; then
            initial_setup=${TRUE?}
        fi
    fi

    if [ ${PROGNAME?} = "db2icrt_local" ]; then
        if [ ${INSTTYPE?} -eq ${ITYPE_SD?} ]; then
            initial_setup=${TRUE?}
        fi
    fi

    if [ ${initial_setup?} -eq ${TRUE?} ]; then
       set_ssh_pub_key
       
       if [ ${ISDB2SSHID?} -eq ${TRUE?} ]; then
           set_ssh_pub_key_user ${DB2SSHUSERNAME?} ${DB2SSHGROUP?}
       fi
    fi
}

# Date stamp - yymmdd
DATESTAMP=`date +"%y""%m""%d"`

# A variable to identify when extra cleanup is required
# if this variable is setup TRUE
UNDOCHG=${FALSE?}

# Name of FencedID info file (in INSTHOME/sqllib/ctrl dir)
# where name of the FencedID is stored.
FENCINFOFNAME=".fencedID"

# A file (in INSTHOME/sqllib/ctrl dir) to mark
# type (Client, EEE, etc.) of the instance
ITYPEFNAME=".insttype"

# A file to keep track of install-copy configuration
CHGPATHCFG="${DB2DIR?}/cfg/installcopy.cfg"

# A flag used in instance update to keep the instance type
KEEPITYPE=${FALSE?}

# By default, debug mode is off/false
DEBUG=${FALSE?}

# Flag to check if messages are to be displayed
NODISPLAY=${FALSE?}

# Unsupported filesys types for instance home dir
UNSUPPFSTYPES="afs"

# UNIX socket dir
SOCKETDIR="/tmp/db2_011_05"

# License file name for enhanced ACS
ACS_LIC="*.lic"

# Temporary file
USERIFILE="${TMPDIR?}/${PROGNAME?}.user.${PROCID?}"   # keep info about a userid
DB2INSTLOG="${TMPDIR?}/${PROGNAME?}.log.${PROCID?}"   # DB2 log file
TMPFILE1="${TMPDIR?}/${PROGNAME?}.tmp1.${PROCID?}"    # Temporary file 1
TMPFILE2="${TMPDIR?}/${PROGNAME?}.tmp2.${PROCID?}"    # Temporary file 2
TMPFILE3="${TMPDIR?}/${PROGNAME?}.tmp3.${PROCID?}"    # Temporary file 3
TMPFILE4="${TMPDIR?}/${PROGNAME?}.tmp4.${PROCID?}"    # Temporary file 4

# Variables to identify version number for all DB2 products
DB2VER_V1=1                # DB2 version identifier for DB2 V1 products
DB2VER_V2=2                # DB2 version identifier for DB2 V2 products
DB2VER_DJ=211              # DB2 version identifier for DJ V2.1.1 products
DB2VER_V5=5                # DB2 version identifier for DB2 V5 products
DB2VER_V61=61              # DB2 version identifier for DB2 V6.1 products
DB2VER_V6=${DB2VER_V61?}   # DB2 version identifier for DB2 V6 products
DB2VER_V71=71              # DB2 version identifier for DB2 V7.1 products
DB2VER_V7=${DB2VER_V71?}   # DB2 version identifier for DB2 V7 products
DB2VER_V81=81              # DB2 version identifier for DB2 V8.1 products
DB2VER_V8=${DB2VER_V81?}   # DB2 version identifier for DB2 V8 products
DB2VER_V91=91              # DB2 version identifier for DB2 V9.1 products 
DB2VER_V9=${DB2VER_V91?}   # DB2 version identifier for DB2 V9 products
DB2VER_V95=95              # DB2 version identifier for DB2 V9.5 products 
DB2VER_PE11=11             # DB2 version identifier for DB2 PE V1.1 product
DB2VER_PE12=12             # DB2 version identifier for DB2 PE V1.2 product
DB2VER_V97=97              # DB2 version identifier for DB2 V9.7 products
DB2VER_V98=98              # DB2 version identifier for DB2 V9.8 products
DB2VER_V101=101            # DB2 version identifier for DB2 V10.1 products
DB2VER_V105=105            # DB2 version identifier for DB2 V10.5 products
DB2VER_V106=106            # DB2 version identifier for DB2 V10.6 products
DB2VER_V107=107            # DB2 version identifier for DB2 V10.7 products
DB2VER_V108=108            # DB2 version identifier for DB2 V10.8 products
DB2VER_V111=111            # DB2 version identifier for DB2 V11.1 products
DB2VER_UNKNOWN=199         # A number to identify unknown version of DB2
CurSPECIALBUILD=""

DB2V2DIR="/usr/IBMdb2/V2.1"         # Product directory for DB2 V2
DB2V5DIR="/usr/IBMdb2/V5.0"         # Product directory for DB2 V5
DB2V61DIR="/usr/IBMdb2/V6.1"        # Product directory for DB2 V6.1
DB2V71DIR="/usr/IBMdb2/V7.1"        # Product directory for DB2 V7.1

# Set the DB2 version and profuct dir to the latest verion of DB2
DB2VER=${DB2VER_CURRENT?}  # Version number for the LATEST version of DB2

DB2RegDir="/var/db2"

if [ ! -d "${DB2RegDir?}" ]; then
    if [ `${DB2DIR?}/bin/db2usrinf -E` -eq 0 ]; then
        mkdir -p ${DB2RegDir?}
        if [ $? -ne 0 ] ; then
           display_msg ${DB2CAT?} 84 \
               'DBI1084E An attempt to create %s failed.\n' \
               ${DB2RegDir?}
           stop_prog 1
        fi
        mkpermission "u=+rwx,go=+rx" ${DB2RegDir?}
    fi
fi

